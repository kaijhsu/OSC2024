## Background
### Exception Types in ARM
- Synchronous Exception
  - caused by the currently executed instruction
    - such as access an unexist memory location
    - `svc` can be used to send software interrupt 
- IRQ Interrupt Request
  - normal asynchronous interrupt
  - generated by external hardware
- FIQ Fast Interrupt Request
  - if prioritizing exception, fast interrupts will be handled by separate exception handler
  - linux don't use it and we don't neither
- SError System Error
  - asynchronous and generated by external hardware. `SError` indicates some error condition
### Exception vectors
- 

## Exception Level

Exception Level (EL)

EL0
- Application All user programs
- cpu can only use `x0` to `x30`, `sp` register
- common operations (eg `str` `ldr`
- process run in EL0 can't not modify virtual memory setting, hence can only use it's memory

EL1
- OS usually works at EL1
- can access the register which configuring virtual memory settings as well as some system registers

EL2
- hypervisor 虛擬機器監視器
- when running virtual machine, host machine os runs at EL2, guest OS runs at EL1
- allow host OS to isolate guest OSes like how OS isolates user processes

EL3 | Firmware    |
- provide full hardware isolation between the software running in secure world and insecure world
- App from an insecure world can in no way access the info belongs to secure world

## Exception Handling

ELx (x is the target exception level)

- SPSR_ELx
  - `Saved Program Status Register`, stores current processor state for restore after exception.
- ELR_ELx
  - `Exception link register`, it stores current pc which as return address after exception finished.
- ESR_ELx
- `eret`
  - Exception handler calls `eret` to restores processor state from `SPSR_ELn` and resume pc from `ELR_ELn`
- PSTATE
  - DAIF allows access to the interrupt mask bit
  - [reference](https://developer.arm.com/documentation/ddi0601/2023-12/AArch64-Registers/DAIF--Interrupt-Mask-Bits)
  - IF 1, the interrupt is mask
  - D: Process state D mask
    - Watchpoint, Breakpoint, and Software Step exceptions targeted at the current Exception level are masked if 1
    - When the target EL of the debug exception is higher than the current EL, the exception is not masked by this bit
  - A: SError exception mask bit
  - I: IRQ mask bit.
  - F: FIQ mask bit.

### Exception Handling Workflow
When a exception arrived, CPU does the following
- save the current processor's state `PSTATE` in `SPSR_ELx` (x for the target exception level)
- save the exception return address in `ELR_ELx`
- disagble its interrupt, `PSTATE.<D,A,I,F>` are set to 1
- if the exception is a synchronous exception or an SError interrupt, save the cause of that exception in `ESR_ELx`
- switch to the target EL and start at the corresponding vector address.

After the ceception handler finishes, it issues `eret` to return from the exception. then
- restore prograom counter from `ELR_ELx`
- restore `PSTATE` from `SPSR_ELx`
- switch to the corresponding EL according to `SPSR_ELx` 

## Vector Table
As the last step of exception handling, CPU switch to the target EL and access corresponding vector address.
the base address of the vector table is saved in `VBAR_ELx`
- the left side is the cause of an exception
- the right side is the relationship between the exception EL and the target EL
- we focus on Synchronous and IRQ exception
  - EL1 -> EL1, EL0 -> EL1
  - let kernel and user programs using different stacks (use `SP_ELx`)
  - That are 
    - Exception from the currentEL while using `SP_ELx`
    - Exception from a lower EL and at least one lower EL is AARCH64 
![](https://nycu-caslab.github.io/OSC2024/_images/vector_table.jpg)

## Interrupt
Let's change user input/output from busy waiting to using interrupt method

### Interrupt Controllers
Rpi3 has two levels of interrupt controllers.
- The first level controller
  - routes interrupt to each CPU core, so each CPU core can have its timer interrupt and send interrupt processor Interrupts between each other.
  - The details is [here](https://github.com/Tekki/raspberrypi-documentation/blob/master/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf)
- The second level controller
  - routes interrupt from peripherals such as UART and system timer, they are aggregated and sent to the first level interrupt controller as GPU IRQ.
  - The details is [page 109](https://cs140e.sergio.bz/docs/BCM2837-ARM-Peripherals.pdf)

## Critical Section
Code can't be excuted concurrently for protect the shared data.
- disable the CPU's interrupt in critical sections
- or limit interrupt handlers from calling part of the APIs that access the shared data

# Implementation
You can now search symbol `LAB3` to see the modification.
## Exception Level Switch
### `LAB3-1` EL2 to EL1 
By spec we can use the following to switch EL2 to EL1
```assembly
    ...
    bl from_el2_to_el1
    # the next instruction runs in EL1
    ...
from_el2_to_el1:
    mov x0, (1 << 31) // EL1 uses aarch64
    msr hcr_el2, x0
    mov x0, 0x3c5 // EL1h (SPSel = 1) with interrupt disabled
    msr spsr_el2, x0
    msr elr_el2, lr
    eret // return to EL1
```

Since our `printf` and some functions might use some special register, uses `-mgeneral-regs-only` c complier flag to limit the register used, or do some extra setting like this.
```
el2_to_el1:
    // disable MMU
    ldr     x1, =SCTLR_VALUE_MMU_DISABLED
    msr     sctlr_el1, x1
    // make el0, el1 can use Floating point and Advanced SIMD
    ldr     x1, =CPACR_EL1_VALUE
    msr     CPACR_EL1, x1
    // set AArch64 for el2
    ldr     x1, =HCR_EL2_VALUE
    msr     hcr_el2, x1
    // mask all interrupt, and set interrupt level to el1h
    ldr     x1, =SPSR_EL2_VALUE
    msr     spsr_el2, x1
    msr     elr_el2, lr
    eret
```
### `LAB3-2` EL1 to EL0
- How to set `spsr_el1` to `0x3c0` and `elr_el1` to go to the program's start addr?
  - why `spsr_el1` to `0x3c0`?
    - [spsr register](https://developer.arm.com/documentation/ddi0601/2023-12/AArch64-Registers/SPSR-EL1--Saved-Program-Status-Register--EL1-)
    - `0x3c0` == `0011 1100 0000`
    - `1` D bit[9] Debug exception mask, `PSTATE.D` 
    - `1` A bit[8] SError exception mask `PSTATE.A`
    - `1` I bit[7] IRQ interrupt mask `PSTATE.I`
    - `1` F bit[6] FIQ interrupt mask `PSTATE.F`
    - `0`   bit[5] reserved
    - `0`   bit[4] AArch64 execution state
    - `0000` M bit[3:0], AArch64 Exception level and selected Stack Pointer.
- How to load a user program
  - Create a user program and put it in initramfs.cpio 
- How to start executing the user code?
  - Create a shell command to load program

### `LAB3-3` EL0 to EL1
- When EL0 call `svc`, the cpu look exception vector table to execute handler
  - build exception vector table
    - the table should align to `0x800`, we use `.align 11` to align to $2^11 == 0x800 = 2048$
## Exception Handling
- implement exception handler

### Context saving
- do context saving and restoring

## Interrupt
### `LAB3-4` Core Timer Interrupt
- How to configure rpi3 CPU core timer?
  - `cntpct_el0` timer current count
  - `cntp_cval_el0` interrupt the cpu if `cntpct_el0 >= cntp_cval_el0`
  - `cntp_tval_el0`: (`cntp_cval_el0 - cntpct_el0`) expired timer
- To enable timer we need set `cntp_ctl_el0` to 1
- unmask the timer interrupt from the first level interrupt controller
- enable the CPU core's interrupt
- How to get `cpu_time`?
  - get frenquency and cycles by `cntpct_el0` `cntfrq_el0`
 
## Rpi3 Peripheral interrupt
- [Interrupte Manual p109](https://cs140e.sergio.bz/docs/BCM2837-ARM-Peripherals.pdf)


## Concurrent IRQ Handling
- Goal
  - Prioritized execution for critical handler
- Why
  - Less critical IRQ might block More critical IRQ
- How
  - decouple interrupt handler
  - Task queue
    - 當一個特定來源 A 的 Interrupt 抵達
    - 關閉此來源 A 的 Interrupt ( mask the device's interrupt )
    - 搬運 buffer 資料 (DMA/COPY)
    - 開啟其他的 Interrupt 並繼續執行 IRQ 搬移資料後的工作
    - 工作完成後，重新開啟此來源 A 的 Interrupt
- `lab3-6-2` Nested Interrupt
  -  beside save general register, also save `spsr_el1` `elr_el1`
- Preemption
  - 


