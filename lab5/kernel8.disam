
kernel8.elf      檔案格式 elf64-littleaarch64


.text.boot 區段的反組譯：

0000000000080000 <_start>:
   80000:	aa0003fd 	mov	x29, x0
   80004:	d53800a0 	mrs	x0, mpidr_el1
   80008:	92401c00 	and	x0, x0, #0xff
   8000c:	b4000080 	cbz	x0, 8001c <master>
   80010:	14000001 	b	80014 <proc_hang>

0000000000080014 <proc_hang>:
   80014:	d503205f 	wfe
   80018:	17ffffff 	b	80014 <proc_hang>

000000000008001c <master>:
   8001c:	940019f9 	bl	86800 <el2_to_el1>
   80020:	10055200 	adr	x0, 8aa60 <read_st>
   80024:	100574a1 	adr	x1, 8aeb8 <_mframe_begin>
   80028:	cb000021 	sub	x1, x1, x0
   8002c:	9400200f 	bl	88068 <memzero>
   80030:	b26d03ff 	mov	sp, #0x80000               	// #524288
   80034:	aa1d03e0 	mov	x0, x29
   80038:	9400136c 	bl	84de8 <kernel_main>

.text 區段的反組譯：

0000000000080800 <getpid>:
#include "exception.h"
#include "mailbox.h"
#include "initramfs.h"


void getpid(uint64_t* sp){
   80800:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80804:	910003fd 	mov	x29, sp
   80808:	f9000fe0 	str	x0, [sp, #24]
    sp[0] = get_cur_tid();
   8080c:	94001df5 	bl	87fe0 <get_cur_tid>
   80810:	aa0003e1 	mov	x1, x0
   80814:	f9400fe0 	ldr	x0, [sp, #24]
   80818:	f9000001 	str	x1, [x0]
    kprintf("syscall return pid %d\n", sp[0]);
   8081c:	f9400fe0 	ldr	x0, [sp, #24]
   80820:	f9400000 	ldr	x0, [x0]
   80824:	aa0003e4 	mov	x4, x0
   80828:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   8082c:	910c0003 	add	x3, x0, #0x300
   80830:	52800162 	mov	w2, #0xb                   	// #11
   80834:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80838:	9101e001 	add	x1, x0, #0x78
   8083c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80840:	91022000 	add	x0, x0, #0x88
   80844:	9400096b 	bl	82df0 <uart_printf>
}
   80848:	d503201f 	nop
   8084c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   80850:	d65f03c0 	ret

0000000000080854 <uart_read>:

void uart_read(uint64_t* sp){
   80854:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   80858:	910003fd 	mov	x29, sp
   8085c:	f9000bf3 	str	x19, [sp, #16]
   80860:	f90017e0 	str	x0, [sp, #40]
    char* buf = (char*)sp[0];
   80864:	f94017e0 	ldr	x0, [sp, #40]
   80868:	f9400000 	ldr	x0, [x0]
   8086c:	f90023e0 	str	x0, [sp, #64]
    size_t size = sp[1];
   80870:	f94017e0 	ldr	x0, [sp, #40]
   80874:	f9400400 	ldr	x0, [x0, #8]
   80878:	f9001fe0 	str	x0, [sp, #56]
    for(int i=0; i<size; ++i)
   8087c:	b9004fff 	str	wzr, [sp, #76]
   80880:	1400000a 	b	808a8 <uart_read+0x54>
        buf[i] = uart_recv();
   80884:	b9804fe0 	ldrsw	x0, [sp, #76]
   80888:	f94023e1 	ldr	x1, [sp, #64]
   8088c:	8b000033 	add	x19, x1, x0
   80890:	94000891 	bl	82ad4 <uart_recv>
   80894:	12001c00 	and	w0, w0, #0xff
   80898:	39000260 	strb	w0, [x19]
    for(int i=0; i<size; ++i)
   8089c:	b9404fe0 	ldr	w0, [sp, #76]
   808a0:	11000400 	add	w0, w0, #0x1
   808a4:	b9004fe0 	str	w0, [sp, #76]
   808a8:	b9804fe0 	ldrsw	x0, [sp, #76]
   808ac:	f9401fe1 	ldr	x1, [sp, #56]
   808b0:	eb00003f 	cmp	x1, x0
   808b4:	54fffe88 	b.hi	80884 <uart_read+0x30>  // b.pmore
    // return size
    sp[0] = size;
   808b8:	f94017e0 	ldr	x0, [sp, #40]
   808bc:	f9401fe1 	ldr	x1, [sp, #56]
   808c0:	f9000001 	str	x1, [x0]
}
   808c4:	d503201f 	nop
   808c8:	f9400bf3 	ldr	x19, [sp, #16]
   808cc:	a8c57bfd 	ldp	x29, x30, [sp], #80
   808d0:	d65f03c0 	ret

00000000000808d4 <uart_write>:

void uart_write(uint64_t* sp){
   808d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   808d8:	910003fd 	mov	x29, sp
   808dc:	f9000fe0 	str	x0, [sp, #24]
    char *buf = (char*)sp[0];
   808e0:	f9400fe0 	ldr	x0, [sp, #24]
   808e4:	f9400000 	ldr	x0, [x0]
   808e8:	f9001be0 	str	x0, [sp, #48]
    size_t size = sp[1];
   808ec:	f9400fe0 	ldr	x0, [sp, #24]
   808f0:	f9400400 	ldr	x0, [x0, #8]
   808f4:	f90017e0 	str	x0, [sp, #40]
    int i=0;
   808f8:	b9003fff 	str	wzr, [sp, #60]
    for(i=0; i<size && buf[i] != '\0'; ++i)
   808fc:	b9003fff 	str	wzr, [sp, #60]
   80900:	14000009 	b	80924 <uart_write+0x50>
        uart_send(buf[i]);
   80904:	b9803fe0 	ldrsw	x0, [sp, #60]
   80908:	f9401be1 	ldr	x1, [sp, #48]
   8090c:	8b000020 	add	x0, x1, x0
   80910:	39400000 	ldrb	w0, [x0]
   80914:	94000857 	bl	82a70 <uart_send>
    for(i=0; i<size && buf[i] != '\0'; ++i)
   80918:	b9403fe0 	ldr	w0, [sp, #60]
   8091c:	11000400 	add	w0, w0, #0x1
   80920:	b9003fe0 	str	w0, [sp, #60]
   80924:	b9803fe0 	ldrsw	x0, [sp, #60]
   80928:	f94017e1 	ldr	x1, [sp, #40]
   8092c:	eb00003f 	cmp	x1, x0
   80930:	540000e9 	b.ls	8094c <uart_write+0x78>  // b.plast
   80934:	b9803fe0 	ldrsw	x0, [sp, #60]
   80938:	f9401be1 	ldr	x1, [sp, #48]
   8093c:	8b000020 	add	x0, x1, x0
   80940:	39400000 	ldrb	w0, [x0]
   80944:	7100001f 	cmp	w0, #0x0
   80948:	54fffde1 	b.ne	80904 <uart_write+0x30>  // b.any
    // return i
    sp[0] = i;
   8094c:	b9803fe1 	ldrsw	x1, [sp, #60]
   80950:	f9400fe0 	ldr	x0, [sp, #24]
   80954:	f9000001 	str	x1, [x0]
}
   80958:	d503201f 	nop
   8095c:	a8c47bfd 	ldp	x29, x30, [sp], #64
   80960:	d65f03c0 	ret

0000000000080964 <exec>:

void exec(uint64_t* sp){
   80964:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
   80968:	910003fd 	mov	x29, sp
   8096c:	f90027e0 	str	x0, [sp, #72]
    char* name = (char*)sp[0];
   80970:	f94027e0 	ldr	x0, [sp, #72]
   80974:	f9400000 	ldr	x0, [x0]
   80978:	f90047e0 	str	x0, [sp, #136]
    // char** argv = (char **)sp[1];
    
    // // access user program image
    cpio_path path = cpio_search(name);
   8097c:	910163e0 	add	x0, sp, #0x58
   80980:	aa0003e8 	mov	x8, x0
   80984:	f94047e0 	ldr	x0, [sp, #136]
   80988:	940010da 	bl	84cf0 <cpio_search>
    if(path.namesize == 0)
   8098c:	f94037e0 	ldr	x0, [sp, #104]
   80990:	f100001f 	cmp	x0, #0x0
   80994:	54000161 	b.ne	809c0 <exec+0x5c>  // b.any
        throw(, "file not found: %s", name);
   80998:	f94047e4 	ldr	x4, [sp, #136]
   8099c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809a0:	910c2003 	add	x3, x0, #0x308
   809a4:	52800502 	mov	w2, #0x28                  	// #40
   809a8:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809ac:	9101e001 	add	x1, x0, #0x78
   809b0:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809b4:	91032000 	add	x0, x0, #0xc8
   809b8:	9400090e 	bl	82df0 <uart_printf>
   809bc:	14000018 	b	80a1c <exec+0xb8>
    else if(path.mode != CPIO_FILE)
   809c0:	b9407be0 	ldr	w0, [sp, #120]
   809c4:	7100e01f 	cmp	w0, #0x38
   809c8:	54000160 	b.eq	809f4 <exec+0x90>  // b.none
        throw(, "Not a file: %s", name);
   809cc:	f94047e4 	ldr	x4, [sp, #136]
   809d0:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809d4:	910c2003 	add	x3, x0, #0x308
   809d8:	52800542 	mov	w2, #0x2a                  	// #42
   809dc:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809e0:	9101e001 	add	x1, x0, #0x78
   809e4:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   809e8:	91042000 	add	x0, x0, #0x108
   809ec:	94000901 	bl	82df0 <uart_printf>
   809f0:	1400000b 	b	80a1c <exec+0xb8>
    
    return thread_exec(path);
   809f4:	910043e0 	add	x0, sp, #0x10
   809f8:	910163e1 	add	x1, sp, #0x58
   809fc:	a9400c22 	ldp	x2, x3, [x1]
   80a00:	a9000c02 	stp	x2, x3, [x0]
   80a04:	a9410c22 	ldp	x2, x3, [x1, #16]
   80a08:	a9010c02 	stp	x2, x3, [x0, #16]
   80a0c:	a9420c22 	ldp	x2, x3, [x1, #32]
   80a10:	a9020c02 	stp	x2, x3, [x0, #32]
   80a14:	910043e0 	add	x0, sp, #0x10
   80a18:	94000edc 	bl	84588 <thread_exec>
}
   80a1c:	a8c97bfd 	ldp	x29, x30, [sp], #144
   80a20:	d65f03c0 	ret

0000000000080a24 <mailbox_syscall>:


void mailbox_syscall(uint64_t* sp){
   80a24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   80a28:	910003fd 	mov	x29, sp
   80a2c:	f9000fe0 	str	x0, [sp, #24]
    unsigned long ch = sp[0];
   80a30:	f9400fe0 	ldr	x0, [sp, #24]
   80a34:	f9400000 	ldr	x0, [x0]
   80a38:	f90017e0 	str	x0, [sp, #40]
    unsigned int* mbox = (void*)sp[1];
   80a3c:	f9400fe0 	ldr	x0, [sp, #24]
   80a40:	91002000 	add	x0, x0, #0x8
   80a44:	f9400000 	ldr	x0, [x0]
   80a48:	f90013e0 	str	x0, [sp, #32]
    mailbox_call(ch, mbox);
   80a4c:	f94017e0 	ldr	x0, [sp, #40]
   80a50:	12001c00 	and	w0, w0, #0xff
   80a54:	f94013e1 	ldr	x1, [sp, #32]
   80a58:	9400009a 	bl	80cc0 <mailbox_call>
}
   80a5c:	d503201f 	nop
   80a60:	a8c37bfd 	ldp	x29, x30, [sp], #48
   80a64:	d65f03c0 	ret

0000000000080a68 <syscall_handler>:


void syscall_handler(uint64_t* sp, void *pc){
   80a68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   80a6c:	910003fd 	mov	x29, sp
   80a70:	f9000fe0 	str	x0, [sp, #24]
   80a74:	f9000be1 	str	x1, [sp, #16]
    uint64_t syscall_num = sp[8];
   80a78:	f9400fe0 	ldr	x0, [sp, #24]
   80a7c:	f9402000 	ldr	x0, [x0, #64]
   80a80:	f90017e0 	str	x0, [sp, #40]
    switch (syscall_num) {
   80a84:	f94017e0 	ldr	x0, [sp, #40]
   80a88:	f100201f 	cmp	x0, #0x8
   80a8c:	54000ee0 	b.eq	80c68 <syscall_handler+0x200>  // b.none
   80a90:	f94017e0 	ldr	x0, [sp, #40]
   80a94:	f100201f 	cmp	x0, #0x8
   80a98:	54000fc8 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80a9c:	f94017e0 	ldr	x0, [sp, #40]
   80aa0:	f1001c1f 	cmp	x0, #0x7
   80aa4:	54000cc0 	b.eq	80c3c <syscall_handler+0x1d4>  // b.none
   80aa8:	f94017e0 	ldr	x0, [sp, #40]
   80aac:	f1001c1f 	cmp	x0, #0x7
   80ab0:	54000f08 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80ab4:	f94017e0 	ldr	x0, [sp, #40]
   80ab8:	f100181f 	cmp	x0, #0x6
   80abc:	54000aa0 	b.eq	80c10 <syscall_handler+0x1a8>  // b.none
   80ac0:	f94017e0 	ldr	x0, [sp, #40]
   80ac4:	f100181f 	cmp	x0, #0x6
   80ac8:	54000e48 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80acc:	f94017e0 	ldr	x0, [sp, #40]
   80ad0:	f100141f 	cmp	x0, #0x5
   80ad4:	540008a0 	b.eq	80be8 <syscall_handler+0x180>  // b.none
   80ad8:	f94017e0 	ldr	x0, [sp, #40]
   80adc:	f100141f 	cmp	x0, #0x5
   80ae0:	54000d88 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80ae4:	f94017e0 	ldr	x0, [sp, #40]
   80ae8:	f100101f 	cmp	x0, #0x4
   80aec:	54000660 	b.eq	80bb8 <syscall_handler+0x150>  // b.none
   80af0:	f94017e0 	ldr	x0, [sp, #40]
   80af4:	f100101f 	cmp	x0, #0x4
   80af8:	54000cc8 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80afc:	f94017e0 	ldr	x0, [sp, #40]
   80b00:	f1000c1f 	cmp	x0, #0x3
   80b04:	54000440 	b.eq	80b8c <syscall_handler+0x124>  // b.none
   80b08:	f94017e0 	ldr	x0, [sp, #40]
   80b0c:	f1000c1f 	cmp	x0, #0x3
   80b10:	54000c08 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80b14:	f94017e0 	ldr	x0, [sp, #40]
   80b18:	f100081f 	cmp	x0, #0x2
   80b1c:	54000320 	b.eq	80b80 <syscall_handler+0x118>  // b.none
   80b20:	f94017e0 	ldr	x0, [sp, #40]
   80b24:	f100081f 	cmp	x0, #0x2
   80b28:	54000b48 	b.hi	80c90 <syscall_handler+0x228>  // b.pmore
   80b2c:	f94017e0 	ldr	x0, [sp, #40]
   80b30:	f100001f 	cmp	x0, #0x0
   80b34:	540000a0 	b.eq	80b48 <syscall_handler+0xe0>  // b.none
   80b38:	f94017e0 	ldr	x0, [sp, #40]
   80b3c:	f100041f 	cmp	x0, #0x1
   80b40:	540001a0 	b.eq	80b74 <syscall_handler+0x10c>  // b.none
   80b44:	14000053 	b	80c90 <syscall_handler+0x228>
    case 0:
        kprintf("syscall getpid\n");
   80b48:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80b4c:	910c4003 	add	x3, x0, #0x310
   80b50:	52800762 	mov	w2, #0x3b                  	// #59
   80b54:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80b58:	9101e001 	add	x1, x0, #0x78
   80b5c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80b60:	91050000 	add	x0, x0, #0x140
   80b64:	940008a3 	bl	82df0 <uart_printf>
        getpid(sp);
   80b68:	f9400fe0 	ldr	x0, [sp, #24]
   80b6c:	97ffff25 	bl	80800 <getpid>
        break;
   80b70:	14000051 	b	80cb4 <syscall_handler+0x24c>
    case 1:
        // kprintf("syscall getpid\n");
        uart_read(sp);
   80b74:	f9400fe0 	ldr	x0, [sp, #24]
   80b78:	97ffff37 	bl	80854 <uart_read>
        break;
   80b7c:	1400004e 	b	80cb4 <syscall_handler+0x24c>
    case 2:
        // kprintf("syscall getpid\n");
        uart_write(sp);
   80b80:	f9400fe0 	ldr	x0, [sp, #24]
   80b84:	97ffff54 	bl	808d4 <uart_write>
        break;
   80b88:	1400004b 	b	80cb4 <syscall_handler+0x24c>
    case 3:
        kprintf("syscall exec\n");
   80b8c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80b90:	910c4003 	add	x3, x0, #0x310
   80b94:	528008e2 	mov	w2, #0x47                  	// #71
   80b98:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80b9c:	9101e001 	add	x1, x0, #0x78
   80ba0:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80ba4:	9105e000 	add	x0, x0, #0x178
   80ba8:	94000892 	bl	82df0 <uart_printf>
        exec(sp);
   80bac:	f9400fe0 	ldr	x0, [sp, #24]
   80bb0:	97ffff6d 	bl	80964 <exec>
        break;
   80bb4:	14000040 	b	80cb4 <syscall_handler+0x24c>
    case 4:
        kprintf("syscall fork\n");
   80bb8:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80bbc:	910c4003 	add	x3, x0, #0x310
   80bc0:	52800962 	mov	w2, #0x4b                  	// #75
   80bc4:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80bc8:	9101e001 	add	x1, x0, #0x78
   80bcc:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80bd0:	9106c000 	add	x0, x0, #0x1b0
   80bd4:	94000887 	bl	82df0 <uart_printf>
        thread_fork(sp, pc);
   80bd8:	f9400be1 	ldr	x1, [sp, #16]
   80bdc:	f9400fe0 	ldr	x0, [sp, #24]
   80be0:	94000d83 	bl	841ec <thread_fork>
        break;
   80be4:	14000034 	b	80cb4 <syscall_handler+0x24c>
    case 5:
        kprintf("syscall exit\n");
   80be8:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80bec:	910c4003 	add	x3, x0, #0x310
   80bf0:	528009e2 	mov	w2, #0x4f                  	// #79
   80bf4:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80bf8:	9101e001 	add	x1, x0, #0x78
   80bfc:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c00:	9107a000 	add	x0, x0, #0x1e8
   80c04:	9400087b 	bl	82df0 <uart_printf>
        thread_exit();
   80c08:	94000d3c 	bl	840f8 <thread_exit>
        break;
   80c0c:	1400002a 	b	80cb4 <syscall_handler+0x24c>
    case 6:
        kprintf("syscall mailbox\n");
   80c10:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c14:	910c4003 	add	x3, x0, #0x310
   80c18:	52800a62 	mov	w2, #0x53                  	// #83
   80c1c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c20:	9101e001 	add	x1, x0, #0x78
   80c24:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c28:	91088000 	add	x0, x0, #0x220
   80c2c:	94000871 	bl	82df0 <uart_printf>
        mailbox_syscall(sp);
   80c30:	f9400fe0 	ldr	x0, [sp, #24]
   80c34:	97ffff7c 	bl	80a24 <mailbox_syscall>
        break;
   80c38:	1400001f 	b	80cb4 <syscall_handler+0x24c>
    case 7:
        kprintf("syscall kill\n");
   80c3c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c40:	910c4003 	add	x3, x0, #0x310
   80c44:	52800ae2 	mov	w2, #0x57                  	// #87
   80c48:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c4c:	9101e001 	add	x1, x0, #0x78
   80c50:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c54:	91096000 	add	x0, x0, #0x258
   80c58:	94000866 	bl	82df0 <uart_printf>
        thread_kill(sp);
   80c5c:	f9400fe0 	ldr	x0, [sp, #24]
   80c60:	94000d31 	bl	84124 <thread_kill>
        break;
   80c64:	14000014 	b	80cb4 <syscall_handler+0x24c>
    case 8:
        kprintf("syscall schedule\n");
   80c68:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c6c:	910c4003 	add	x3, x0, #0x310
   80c70:	52800b62 	mov	w2, #0x5b                  	// #91
   80c74:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c78:	9101e001 	add	x1, x0, #0x78
   80c7c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c80:	910a4000 	add	x0, x0, #0x290
   80c84:	9400085b 	bl	82df0 <uart_printf>
        thread_schedule();
   80c88:	94000c94 	bl	83ed8 <thread_schedule>
        break;
   80c8c:	1400000a 	b	80cb4 <syscall_handler+0x24c>
    default:
        kprintf("syscall unknown\n");
   80c90:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80c94:	910c4003 	add	x3, x0, #0x310
   80c98:	52800be2 	mov	w2, #0x5f                  	// #95
   80c9c:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80ca0:	9101e001 	add	x1, x0, #0x78
   80ca4:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80ca8:	910b2000 	add	x0, x0, #0x2c8
   80cac:	94000851 	bl	82df0 <uart_printf>
        while(1);
   80cb0:	14000000 	b	80cb0 <syscall_handler+0x248>
        break;
    }
}
   80cb4:	d503201f 	nop
   80cb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
   80cbc:	d65f03c0 	ret

0000000000080cc0 <mailbox_call>:
#include "mailbox.h"

volatile unsigned int __attribute__((aligned(16))) mailbox[36];

// return 0 if fail
int mailbox_call(unsigned char channel, volatile unsigned int mailbox[]){
   80cc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   80cc4:	910003fd 	mov	x29, sp
   80cc8:	39007fe0 	strb	w0, [sp, #31]
   80ccc:	f9000be1 	str	x1, [sp, #16]
    unsigned int align_check = (unsigned int)mailbox;
   80cd0:	f9400be0 	ldr	x0, [sp, #16]
   80cd4:	b9002fe0 	str	w0, [sp, #44]
    if(align_check & 0xF)
   80cd8:	b9402fe0 	ldr	w0, [sp, #44]
   80cdc:	12000c00 	and	w0, w0, #0xf
   80ce0:	7100001f 	cmp	w0, #0x0
   80ce4:	54000160 	b.eq	80d10 <mailbox_call+0x50>  // b.none
        throw(-1, "mailbox address aligned wrong");
   80ce8:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80cec:	910f4003 	add	x3, x0, #0x3d0
   80cf0:	52800122 	mov	w2, #0x9                   	// #9
   80cf4:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80cf8:	910c8001 	add	x1, x0, #0x320
   80cfc:	90000040 	adrp	x0, 88000 <load_all_sp+0x18>
   80d00:	910cc000 	add	x0, x0, #0x330
   80d04:	9400083b 	bl	82df0 <uart_printf>
   80d08:	12800000 	mov	w0, #0xffffffff            	// #-1
   80d0c:	1400002a 	b	80db4 <mailbox_call+0xf4>


    // 1. Combine the message address (upper 28 bits) with channel number (lower 4 bits)
    unsigned int mes_addr = (unsigned int)&mailbox;
   80d10:	910043e0 	add	x0, sp, #0x10
   80d14:	b9002be0 	str	w0, [sp, #40]
    unsigned int write_val = (mes_addr & ~0xF) | (channel & 0xF);
   80d18:	b9402be0 	ldr	w0, [sp, #40]
   80d1c:	121c6c01 	and	w1, w0, #0xfffffff0
   80d20:	39407fe0 	ldrb	w0, [sp, #31]
   80d24:	12000c00 	and	w0, w0, #0xf
   80d28:	2a000020 	orr	w0, w1, w0
   80d2c:	b90027e0 	str	w0, [sp, #36]

    // 2. Check if Mailbox 0 status register’s full flag is set.
    while(get32(MAILBOX_STATUS) & MAILBOX_FULL)
   80d30:	14000002 	b	80d38 <mailbox_call+0x78>
        asm volatile("nop");
   80d34:	d503201f 	nop
    while(get32(MAILBOX_STATUS) & MAILBOX_FULL)
   80d38:	d2971300 	mov	x0, #0xb898                	// #47256
   80d3c:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   80d40:	94001520 	bl	861c0 <get32>
   80d44:	7100001f 	cmp	w0, #0x0
   80d48:	54ffff6b 	b.lt	80d34 <mailbox_call+0x74>  // b.tstop

    // 3. If not, write to Mailbox 1 Read/Write register.
    put32(MAILBOX_WRITE, write_val);
   80d4c:	b94027e1 	ldr	w1, [sp, #36]
   80d50:	d2971400 	mov	x0, #0xb8a0                	// #47264
   80d54:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   80d58:	94001518 	bl	861b8 <put32>

    while(1){
        // 4. Check if Mailbox 0 status register’s empty flag is set.
        while(get32(MAILBOX_STATUS) & MAILBOX_EMPTY)
   80d5c:	14000002 	b	80d64 <mailbox_call+0xa4>
            asm volatile("nop");
   80d60:	d503201f 	nop
        while(get32(MAILBOX_STATUS) & MAILBOX_EMPTY)
   80d64:	d2971300 	mov	x0, #0xb898                	// #47256
   80d68:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   80d6c:	94001515 	bl	861c0 <get32>
   80d70:	12020000 	and	w0, w0, #0x40000000
   80d74:	7100001f 	cmp	w0, #0x0
   80d78:	54ffff41 	b.ne	80d60 <mailbox_call+0xa0>  // b.any

        // 5. If not, read from Mailbox 0 Read/Write register.
        // 6. Check if the value is the same as you wrote in step 1.
        if(get32(MAILBOX_READ) == write_val)
   80d7c:	d2971000 	mov	x0, #0xb880                	// #47232
   80d80:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   80d84:	9400150f 	bl	861c0 <get32>
   80d88:	2a0003e1 	mov	w1, w0
   80d8c:	b94027e0 	ldr	w0, [sp, #36]
   80d90:	6b01001f 	cmp	w0, w1
   80d94:	54fffe81 	b.ne	80d64 <mailbox_call+0xa4>  // b.any
            // mailbox[1] will be written to val if success
            return mailbox[1] == MAILBOX_RESPONSE;
   80d98:	f9400be0 	ldr	x0, [sp, #16]
   80d9c:	91001000 	add	x0, x0, #0x4
   80da0:	b9400001 	ldr	w1, [x0]
   80da4:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
   80da8:	6b00003f 	cmp	w1, w0
   80dac:	1a9f17e0 	cset	w0, eq  // eq = none
   80db0:	12001c00 	and	w0, w0, #0xff
    }
    return 0;
}
   80db4:	a8c37bfd 	ldp	x29, x30, [sp], #48
   80db8:	d65f03c0 	ret

0000000000080dbc <get_arm_memory>:

int get_arm_memory(unsigned int *base_addr, unsigned int *mem_size){
   80dbc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80dc0:	910003fd 	mov	x29, sp
   80dc4:	f9000fe0 	str	x0, [sp, #24]
   80dc8:	f9000be1 	str	x1, [sp, #16]
    mailbox[0] = 8 * 4;
   80dcc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80dd0:	f9446400 	ldr	x0, [x0, #2248]
   80dd4:	52800401 	mov	w1, #0x20                  	// #32
   80dd8:	b9000001 	str	w1, [x0]
    mailbox[1] = MAILBOX_REQUEST;
   80ddc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80de0:	f9446400 	ldr	x0, [x0, #2248]
   80de4:	b900041f 	str	wzr, [x0, #4]
    mailbox[2] = MAILBOX_TAG_GETARMMEM;
   80de8:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80dec:	f9446400 	ldr	x0, [x0, #2248]
   80df0:	528000a1 	mov	w1, #0x5                   	// #5
   80df4:	72a00021 	movk	w1, #0x1, lsl #16
   80df8:	b9000801 	str	w1, [x0, #8]
    mailbox[3] = 8;
   80dfc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e00:	f9446400 	ldr	x0, [x0, #2248]
   80e04:	52800101 	mov	w1, #0x8                   	// #8
   80e08:	b9000c01 	str	w1, [x0, #12]
    mailbox[4] = 0;
   80e0c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e10:	f9446400 	ldr	x0, [x0, #2248]
   80e14:	b900101f 	str	wzr, [x0, #16]
    mailbox[5] = 0;
   80e18:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e1c:	f9446400 	ldr	x0, [x0, #2248]
   80e20:	b900141f 	str	wzr, [x0, #20]
    mailbox[6] = 0;
   80e24:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e28:	f9446400 	ldr	x0, [x0, #2248]
   80e2c:	b900181f 	str	wzr, [x0, #24]
    mailbox[7] = MAILBOX_TAG_END;
   80e30:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e34:	f9446400 	ldr	x0, [x0, #2248]
   80e38:	b9001c1f 	str	wzr, [x0, #28]
    if(!mailbox_call(MAILBOX_CH_PROP, mailbox))
   80e3c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e40:	f9446401 	ldr	x1, [x0, #2248]
   80e44:	52800100 	mov	w0, #0x8                   	// #8
   80e48:	97ffff9e 	bl	80cc0 <mailbox_call>
   80e4c:	7100001f 	cmp	w0, #0x0
   80e50:	54000061 	b.ne	80e5c <get_arm_memory+0xa0>  // b.any
        return -1;
   80e54:	12800000 	mov	w0, #0xffffffff            	// #-1
   80e58:	1400000c 	b	80e88 <get_arm_memory+0xcc>
    *base_addr = mailbox[5];
   80e5c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e60:	f9446400 	ldr	x0, [x0, #2248]
   80e64:	b9401401 	ldr	w1, [x0, #20]
   80e68:	f9400fe0 	ldr	x0, [sp, #24]
   80e6c:	b9000001 	str	w1, [x0]
    *mem_size = mailbox[6];
   80e70:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80e74:	f9446400 	ldr	x0, [x0, #2248]
   80e78:	b9401801 	ldr	w1, [x0, #24]
   80e7c:	f9400be0 	ldr	x0, [sp, #16]
   80e80:	b9000001 	str	w1, [x0]
    return 0;
   80e84:	52800000 	mov	w0, #0x0                   	// #0
}
   80e88:	a8c27bfd 	ldp	x29, x30, [sp], #32
   80e8c:	d65f03c0 	ret

0000000000080e90 <get_board_serial>:

int get_board_serial(unsigned long long *board_serial){
   80e90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80e94:	910003fd 	mov	x29, sp
   80e98:	f9000fe0 	str	x0, [sp, #24]
    mailbox[0] = 8 * 4;                 // message len in bytes
   80e9c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ea0:	f9446400 	ldr	x0, [x0, #2248]
   80ea4:	52800401 	mov	w1, #0x20                  	// #32
   80ea8:	b9000001 	str	w1, [x0]
    mailbox[1] = MAILBOX_REQUEST;       // tell this is request message
   80eac:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80eb0:	f9446400 	ldr	x0, [x0, #2248]
   80eb4:	b900041f 	str	wzr, [x0, #4]
    mailbox[2] = MAILBOX_TAG_GETSERIAL; // tag identifier,
   80eb8:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ebc:	f9446400 	ldr	x0, [x0, #2248]
   80ec0:	52800081 	mov	w1, #0x4                   	// #4
   80ec4:	72a00021 	movk	w1, #0x1, lsl #16
   80ec8:	b9000801 	str	w1, [x0, #8]
    mailbox[3] = 8;                     // output buffer size in bytes
   80ecc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ed0:	f9446400 	ldr	x0, [x0, #2248]
   80ed4:	52800101 	mov	w1, #0x8                   	// #8
   80ed8:	b9000c01 	str	w1, [x0, #12]
    mailbox[4] = MAILBOX_REQUEST;       // tag request
   80edc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ee0:	f9446400 	ldr	x0, [x0, #2248]
   80ee4:	b900101f 	str	wzr, [x0, #16]
    mailbox[5] = 0;                     // output value buffer
   80ee8:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80eec:	f9446400 	ldr	x0, [x0, #2248]
   80ef0:	b900141f 	str	wzr, [x0, #20]
    mailbox[6] = 0;                     // output value buffer
   80ef4:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ef8:	f9446400 	ldr	x0, [x0, #2248]
   80efc:	b900181f 	str	wzr, [x0, #24]
    mailbox[7] = MAILBOX_TAG_END;       // describe end of tag
   80f00:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f04:	f9446400 	ldr	x0, [x0, #2248]
   80f08:	b9001c1f 	str	wzr, [x0, #28]
    if(!mailbox_call(MAILBOX_CH_PROP, mailbox))
   80f0c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f10:	f9446401 	ldr	x1, [x0, #2248]
   80f14:	52800100 	mov	w0, #0x8                   	// #8
   80f18:	97ffff6a 	bl	80cc0 <mailbox_call>
   80f1c:	7100001f 	cmp	w0, #0x0
   80f20:	54000061 	b.ne	80f2c <get_board_serial+0x9c>  // b.any
        return -1;
   80f24:	12800000 	mov	w0, #0xffffffff            	// #-1
   80f28:	1400000e 	b	80f60 <get_board_serial+0xd0>
    *board_serial = (((unsigned long long) mailbox[5]) << 32) | mailbox[6];
   80f2c:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f30:	f9446400 	ldr	x0, [x0, #2248]
   80f34:	b9401400 	ldr	w0, [x0, #20]
   80f38:	2a0003e0 	mov	w0, w0
   80f3c:	d3607c01 	lsl	x1, x0, #32
   80f40:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f44:	f9446400 	ldr	x0, [x0, #2248]
   80f48:	b9401800 	ldr	w0, [x0, #24]
   80f4c:	2a0003e0 	mov	w0, w0
   80f50:	aa000021 	orr	x1, x1, x0
   80f54:	f9400fe0 	ldr	x0, [sp, #24]
   80f58:	f9000001 	str	x1, [x0]
    return 0;
   80f5c:	52800000 	mov	w0, #0x0                   	// #0
}
   80f60:	a8c27bfd 	ldp	x29, x30, [sp], #32
   80f64:	d65f03c0 	ret

0000000000080f68 <get_board_revision>:

int get_board_revision(unsigned int *board_revision){
   80f68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   80f6c:	910003fd 	mov	x29, sp
   80f70:	f9000fe0 	str	x0, [sp, #24]
    mailbox[0] = 7*4;
   80f74:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f78:	f9446400 	ldr	x0, [x0, #2248]
   80f7c:	52800381 	mov	w1, #0x1c                  	// #28
   80f80:	b9000001 	str	w1, [x0]
    mailbox[1] = MAILBOX_REQUEST;
   80f84:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f88:	f9446400 	ldr	x0, [x0, #2248]
   80f8c:	b900041f 	str	wzr, [x0, #4]
    mailbox[2] = MAILBOX_TAG_GETREVISION;
   80f90:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80f94:	f9446400 	ldr	x0, [x0, #2248]
   80f98:	52800041 	mov	w1, #0x2                   	// #2
   80f9c:	72a00021 	movk	w1, #0x1, lsl #16
   80fa0:	b9000801 	str	w1, [x0, #8]
    mailbox[3] = 4;
   80fa4:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80fa8:	f9446400 	ldr	x0, [x0, #2248]
   80fac:	52800081 	mov	w1, #0x4                   	// #4
   80fb0:	b9000c01 	str	w1, [x0, #12]
    mailbox[4] = 0;
   80fb4:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80fb8:	f9446400 	ldr	x0, [x0, #2248]
   80fbc:	b900101f 	str	wzr, [x0, #16]
    mailbox[5] = 0; // value buffer
   80fc0:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80fc4:	f9446400 	ldr	x0, [x0, #2248]
   80fc8:	b900141f 	str	wzr, [x0, #20]
    mailbox[6] = MAILBOX_TAG_END;
   80fcc:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80fd0:	f9446400 	ldr	x0, [x0, #2248]
   80fd4:	b900181f 	str	wzr, [x0, #24]
    if(!mailbox_call(MAILBOX_CH_PROP, mailbox))
   80fd8:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80fdc:	f9446401 	ldr	x1, [x0, #2248]
   80fe0:	52800100 	mov	w0, #0x8                   	// #8
   80fe4:	97ffff37 	bl	80cc0 <mailbox_call>
   80fe8:	7100001f 	cmp	w0, #0x0
   80fec:	54000061 	b.ne	80ff8 <get_board_revision+0x90>  // b.any
        return -1;
   80ff0:	12800000 	mov	w0, #0xffffffff            	// #-1
   80ff4:	14000007 	b	81010 <get_board_revision+0xa8>
    *board_revision = mailbox[5];
   80ff8:	d0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   80ffc:	f9446400 	ldr	x0, [x0, #2248]
   81000:	b9401401 	ldr	w1, [x0, #20]
   81004:	f9400fe0 	ldr	x0, [sp, #24]
   81008:	b9000001 	str	w1, [x0]
    return 0;
   8100c:	52800000 	mov	w0, #0x0                   	// #0
}
   81010:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81014:	d65f03c0 	ret

0000000000081018 <print_board_info>:




void print_board_info() {
   81018:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   8101c:	910003fd 	mov	x29, sp

    unsigned long long board_serial;
    unsigned int board_revision;
    unsigned int base_addr = 0;
   81020:	b90023ff 	str	wzr, [sp, #32]
    unsigned int mem_size = 0;
   81024:	b9001fff 	str	wzr, [sp, #28]
    get_board_serial(&board_serial);
   81028:	9100a3e0 	add	x0, sp, #0x28
   8102c:	97ffff99 	bl	80e90 <get_board_serial>
    get_board_revision(&board_revision);
   81030:	910093e0 	add	x0, sp, #0x24
   81034:	97ffffcd 	bl	80f68 <get_board_revision>
    get_arm_memory(&base_addr, &mem_size);
   81038:	910073e1 	add	x1, sp, #0x1c
   8103c:	910083e0 	add	x0, sp, #0x20
   81040:	97ffff5f 	bl	80dbc <get_arm_memory>

    uart_printf("board serial: 0x%x%x\n", board_serial >> 32, board_serial);
   81044:	f94017e0 	ldr	x0, [sp, #40]
   81048:	d360fc00 	lsr	x0, x0, #32
   8104c:	f94017e1 	ldr	x1, [sp, #40]
   81050:	aa0103e2 	mov	x2, x1
   81054:	aa0003e1 	mov	x1, x0
   81058:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8105c:	910de000 	add	x0, x0, #0x378
   81060:	94000764 	bl	82df0 <uart_printf>
    uart_printf("board revision: 0x%x\n", board_revision);
   81064:	b94027e0 	ldr	w0, [sp, #36]
   81068:	2a0003e1 	mov	w1, w0
   8106c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81070:	910e4000 	add	x0, x0, #0x390
   81074:	9400075f 	bl	82df0 <uart_printf>
    uart_printf("arm base_addr: 0x%x, mem_size: 0x%x\n", base_addr, mem_size);
   81078:	b94023e0 	ldr	w0, [sp, #32]
   8107c:	b9401fe1 	ldr	w1, [sp, #28]
   81080:	2a0103e2 	mov	w2, w1
   81084:	2a0003e1 	mov	w1, w0
   81088:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8108c:	910ea000 	add	x0, x0, #0x3a8
   81090:	94000758 	bl	82df0 <uart_printf>

    return ;
   81094:	d503201f 	nop
}
   81098:	a8c37bfd 	ldp	x29, x30, [sp], #48
   8109c:	d65f03c0 	ret

00000000000810a0 <set_interrupt_el1>:
#include "utils.h"
#include "mini_uart.h"
#include "syscall.h"
#include "arm/sysregs.h"

void set_interrupt_el1(int enable){
   810a0:	d10043ff 	sub	sp, sp, #0x10
   810a4:	b9000fe0 	str	w0, [sp, #12]
    if(enable)  asm("msr DAIFClr, 0xf");
   810a8:	b9400fe0 	ldr	w0, [sp, #12]
   810ac:	7100001f 	cmp	w0, #0x0
   810b0:	54000060 	b.eq	810bc <set_interrupt_el1+0x1c>  // b.none
   810b4:	d5034fff 	msr	daifclr, #0xf
    else        asm("msr DAIFSet, 0xf");
}
   810b8:	14000002 	b	810c0 <set_interrupt_el1+0x20>
    else        asm("msr DAIFSet, 0xf");
   810bc:	d5034fdf 	msr	daifset, #0xf
}
   810c0:	d503201f 	nop
   810c4:	910043ff 	add	sp, sp, #0x10
   810c8:	d65f03c0 	ret

00000000000810cc <el_spelx_irq>:

void el_spelx_irq(uint64_t* sp){
   810cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   810d0:	910003fd 	mov	x29, sp
   810d4:	f9000fe0 	str	x0, [sp, #24]
    set_interrupt_el1(0);
   810d8:	52800000 	mov	w0, #0x0                   	// #0
   810dc:	97fffff1 	bl	810a0 <set_interrupt_el1>

    unsigned long long irq = *(unsigned long long *)CORE0_IRQ_SRC;
   810e0:	d2800c00 	mov	x0, #0x60                  	// #96
   810e4:	f2a80000 	movk	x0, #0x4000, lsl #16
   810e8:	f9400000 	ldr	x0, [x0]
   810ec:	f90017e0 	str	x0, [sp, #40]
    if(irq & SYSTEM_TIMER_IRQ_1){
   810f0:	f94017e0 	ldr	x0, [sp, #40]
   810f4:	927f0000 	and	x0, x0, #0x2
   810f8:	f100001f 	cmp	x0, #0x0
   810fc:	54000120 	b.eq	81120 <el_spelx_irq+0x54>  // b.none
        set_core_timer(0);
   81100:	52800000 	mov	w0, #0x0                   	// #0
   81104:	9400141d 	bl	86178 <set_core_timer>
        timer_handler();
   81108:	94000a06 	bl	83920 <timer_handler>
        set_core_timer(1);
   8110c:	52800020 	mov	w0, #0x1                   	// #1
   81110:	9400141a 	bl	86178 <set_core_timer>
        irq &= ~SYSTEM_TIMER_IRQ_1;
   81114:	f94017e0 	ldr	x0, [sp, #40]
   81118:	927ef800 	and	x0, x0, #0xfffffffffffffffd
   8111c:	f90017e0 	str	x0, [sp, #40]
    }

    if(irq & GPU_IRQ){
   81120:	f94017e0 	ldr	x0, [sp, #40]
   81124:	92780000 	and	x0, x0, #0x100
   81128:	f100001f 	cmp	x0, #0x0
   8112c:	54000580 	b.eq	811dc <el_spelx_irq+0x110>  // b.none
        unsigned int pending = get32(IRQ_PENDING_1);
   81130:	d2964080 	mov	x0, #0xb204                	// #45572
   81134:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   81138:	94001422 	bl	861c0 <get32>
   8113c:	b90027e0 	str	w0, [sp, #36]
        if(pending & AUX_INT){
   81140:	b94027e0 	ldr	w0, [sp, #36]
   81144:	12030000 	and	w0, w0, #0x20000000
   81148:	7100001f 	cmp	w0, #0x0
   8114c:	54000300 	b.eq	811ac <el_spelx_irq+0xe0>  // b.none
            unsigned int irq_src = get32(AUX_MU_IIR_REG);
   81150:	d28a0900 	mov	x0, #0x5048                	// #20552
   81154:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   81158:	9400141a 	bl	861c0 <get32>
   8115c:	b90023e0 	str	w0, [sp, #32]
            if(irq_src & AUX_MU_IIR_REG_WRITE){
   81160:	b94023e0 	ldr	w0, [sp, #32]
   81164:	121f0000 	and	w0, w0, #0x2
   81168:	7100001f 	cmp	w0, #0x0
   8116c:	54000060 	b.eq	81178 <el_spelx_irq+0xac>  // b.none
                uart_irq_write();
   81170:	94000866 	bl	83308 <uart_irq_write>
   81174:	14000017 	b	811d0 <el_spelx_irq+0x104>
            }
            else if(irq_src & AUX_MU_IIR_REG_READ){
   81178:	b94023e0 	ldr	w0, [sp, #32]
   8117c:	121e0000 	and	w0, w0, #0x4
   81180:	7100001f 	cmp	w0, #0x0
   81184:	54000260 	b.eq	811d0 <el_spelx_irq+0x104>  // b.none
                *(unsigned int *)AUX_MU_IER_REG &= ~(AUX_MU_IER_REG_RECEIVE_INTERRUPT);
   81188:	d28a0880 	mov	x0, #0x5044                	// #20548
   8118c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   81190:	b9400001 	ldr	w1, [x0]
   81194:	d28a0880 	mov	x0, #0x5044                	// #20548
   81198:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   8119c:	121f7821 	and	w1, w1, #0xfffffffe
   811a0:	b9000001 	str	w1, [x0]
                uart_irq_read();
   811a4:	94000880 	bl	833a4 <uart_irq_read>
   811a8:	1400000a 	b	811d0 <el_spelx_irq+0x104>
            }
        }
        else{
            debug("unknown gpu irq pending %l", pending);
   811ac:	b94027e4 	ldr	w4, [sp, #36]
   811b0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   811b4:	91138003 	add	x3, x0, #0x4e0
   811b8:	528004e2 	mov	w2, #0x27                  	// #39
   811bc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   811c0:	910f8001 	add	x1, x0, #0x3e0
   811c4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   811c8:	910fc000 	add	x0, x0, #0x3f0
   811cc:	94000709 	bl	82df0 <uart_printf>
        }
        irq &= ~GPU_IRQ;
   811d0:	f94017e0 	ldr	x0, [sp, #40]
   811d4:	9277f800 	and	x0, x0, #0xfffffffffffffeff
   811d8:	f90017e0 	str	x0, [sp, #40]
    }

    *(unsigned long long *)CORE0_IRQ_SRC = 0;
   811dc:	d2800c00 	mov	x0, #0x60                  	// #96
   811e0:	f2a80000 	movk	x0, #0x4000, lsl #16
   811e4:	f900001f 	str	xzr, [x0]
    if(irq) debug("unprocess irq %d", irq);
   811e8:	f94017e0 	ldr	x0, [sp, #40]
   811ec:	f100001f 	cmp	x0, #0x0
   811f0:	54000140 	b.eq	81218 <el_spelx_irq+0x14c>  // b.none
   811f4:	f94017e4 	ldr	x4, [sp, #40]
   811f8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   811fc:	91138003 	add	x3, x0, #0x4e0
   81200:	528005a2 	mov	w2, #0x2d                  	// #45
   81204:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81208:	910f8001 	add	x1, x0, #0x3e0
   8120c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81210:	9110e000 	add	x0, x0, #0x438
   81214:	940006f7 	bl	82df0 <uart_printf>
    set_interrupt_el1(1);
   81218:	52800020 	mov	w0, #0x1                   	// #1
   8121c:	97ffffa1 	bl	810a0 <set_interrupt_el1>
}
   81220:	d503201f 	nop
   81224:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81228:	d65f03c0 	ret

000000000008122c <el_spel0_sync>:

void el_spel0_sync(uint64_t* sp){
   8122c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81230:	910003fd 	mov	x29, sp
   81234:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   81238:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8123c:	9113c003 	add	x3, x0, #0x4f0
   81240:	52800642 	mov	w2, #0x32                  	// #50
   81244:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81248:	910f8001 	add	x1, x0, #0x3e0
   8124c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81250:	9111c000 	add	x0, x0, #0x470
   81254:	940006e7 	bl	82df0 <uart_printf>
}
   81258:	d503201f 	nop
   8125c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81260:	d65f03c0 	ret

0000000000081264 <el_spel0_irq>:

void el_spel0_irq(uint64_t* sp){
   81264:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81268:	910003fd 	mov	x29, sp
   8126c:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   81270:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81274:	91140003 	add	x3, x0, #0x500
   81278:	528006c2 	mov	w2, #0x36                  	// #54
   8127c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81280:	910f8001 	add	x1, x0, #0x3e0
   81284:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81288:	9111c000 	add	x0, x0, #0x470
   8128c:	940006d9 	bl	82df0 <uart_printf>
}
   81290:	d503201f 	nop
   81294:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81298:	d65f03c0 	ret

000000000008129c <el_spel0_fiq>:

void el_spel0_fiq(uint64_t* sp){
   8129c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   812a0:	910003fd 	mov	x29, sp
   812a4:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   812a8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812ac:	91144003 	add	x3, x0, #0x510
   812b0:	52800742 	mov	w2, #0x3a                  	// #58
   812b4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812b8:	910f8001 	add	x1, x0, #0x3e0
   812bc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812c0:	9111c000 	add	x0, x0, #0x470
   812c4:	940006cb 	bl	82df0 <uart_printf>
}
   812c8:	d503201f 	nop
   812cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
   812d0:	d65f03c0 	ret

00000000000812d4 <el_spel0_error>:

void el_spel0_error(uint64_t* sp){
   812d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   812d8:	910003fd 	mov	x29, sp
   812dc:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   812e0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812e4:	91148003 	add	x3, x0, #0x520
   812e8:	528007c2 	mov	w2, #0x3e                  	// #62
   812ec:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812f0:	910f8001 	add	x1, x0, #0x3e0
   812f4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   812f8:	9111c000 	add	x0, x0, #0x470
   812fc:	940006bd 	bl	82df0 <uart_printf>
}
   81300:	d503201f 	nop
   81304:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81308:	d65f03c0 	ret

000000000008130c <el_spelx_sync>:

void el_spelx_sync(uint64_t* sp, void* pc){
   8130c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81310:	910003fd 	mov	x29, sp
   81314:	f9000fe0 	str	x0, [sp, #24]
   81318:	f9000be1 	str	x1, [sp, #16]
    set_interrupt_el1(0);
   8131c:	52800000 	mov	w0, #0x0                   	// #0
   81320:	97ffff60 	bl	810a0 <set_interrupt_el1>
    uint64_t esr;
    asm volatile("mrs %0, esr_el1":"=r"(esr));
   81324:	d5385200 	mrs	x0, esr_el1
   81328:	f90017e0 	str	x0, [sp, #40]
    uint64_t ec = ESR_GET_EC(esr);
   8132c:	f94017e0 	ldr	x0, [sp, #40]
   81330:	d35afc00 	lsr	x0, x0, #26
   81334:	92401400 	and	x0, x0, #0x3f
   81338:	f90013e0 	str	x0, [sp, #32]
    if(ec == ESR_EC_SVC)
   8133c:	f94013e0 	ldr	x0, [sp, #32]
   81340:	f100541f 	cmp	x0, #0x15
   81344:	540000a1 	b.ne	81358 <el_spelx_sync+0x4c>  // b.any
        syscall_handler(sp, pc);
   81348:	f9400be1 	ldr	x1, [sp, #16]
   8134c:	f9400fe0 	ldr	x0, [sp, #24]
   81350:	97fffdc6 	bl	80a68 <syscall_handler>
   81354:	1400000b 	b	81380 <el_spelx_sync+0x74>
    else{
        kprintf("error, unknown esr class %x\n", ec);
   81358:	f94013e4 	ldr	x4, [sp, #32]
   8135c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81360:	9114c003 	add	x3, x0, #0x530
   81364:	52800922 	mov	w2, #0x49                  	// #73
   81368:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8136c:	910f8001 	add	x1, x0, #0x3e0
   81370:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81374:	91126000 	add	x0, x0, #0x498
   81378:	9400069e 	bl	82df0 <uart_printf>
        while(1);
   8137c:	14000000 	b	8137c <el_spelx_sync+0x70>
    }
    set_interrupt_el1(1);
   81380:	52800020 	mov	w0, #0x1                   	// #1
   81384:	97ffff47 	bl	810a0 <set_interrupt_el1>
}
   81388:	d503201f 	nop
   8138c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81390:	d65f03c0 	ret

0000000000081394 <el_spelx_fiq>:

void el_spelx_fiq(uint64_t* sp){
   81394:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81398:	910003fd 	mov	x29, sp
   8139c:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   813a0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813a4:	91150003 	add	x3, x0, #0x540
   813a8:	52800a02 	mov	w2, #0x50                  	// #80
   813ac:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813b0:	910f8001 	add	x1, x0, #0x3e0
   813b4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813b8:	9111c000 	add	x0, x0, #0x470
   813bc:	9400068d 	bl	82df0 <uart_printf>
}
   813c0:	d503201f 	nop
   813c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   813c8:	d65f03c0 	ret

00000000000813cc <el_spelx_error>:

void el_spelx_error(uint64_t* sp){
   813cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   813d0:	910003fd 	mov	x29, sp
   813d4:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   813d8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813dc:	91154003 	add	x3, x0, #0x550
   813e0:	52800a82 	mov	w2, #0x54                  	// #84
   813e4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813e8:	910f8001 	add	x1, x0, #0x3e0
   813ec:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   813f0:	9111c000 	add	x0, x0, #0x470
   813f4:	9400067f 	bl	82df0 <uart_printf>
}
   813f8:	d503201f 	nop
   813fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81400:	d65f03c0 	ret

0000000000081404 <elh_64_sync>:

void elh_64_sync(uint64_t* sp, void* pc){
   81404:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81408:	910003fd 	mov	x29, sp
   8140c:	f9000fe0 	str	x0, [sp, #24]
   81410:	f9000be1 	str	x1, [sp, #16]
    set_interrupt_el1(0);
   81414:	52800000 	mov	w0, #0x0                   	// #0
   81418:	97ffff22 	bl	810a0 <set_interrupt_el1>
    uint64_t esr;
    asm volatile("mrs %0, esr_el1":"=r"(esr));
   8141c:	d5385200 	mrs	x0, esr_el1
   81420:	f90017e0 	str	x0, [sp, #40]
    uint64_t ec = ESR_GET_EC(esr);
   81424:	f94017e0 	ldr	x0, [sp, #40]
   81428:	d35afc00 	lsr	x0, x0, #26
   8142c:	92401400 	and	x0, x0, #0x3f
   81430:	f90013e0 	str	x0, [sp, #32]
    if(ec == ESR_EC_SVC)
   81434:	f94013e0 	ldr	x0, [sp, #32]
   81438:	f100541f 	cmp	x0, #0x15
   8143c:	540000a1 	b.ne	81450 <elh_64_sync+0x4c>  // b.any
        syscall_handler(sp, pc);
   81440:	f9400be1 	ldr	x1, [sp, #16]
   81444:	f9400fe0 	ldr	x0, [sp, #24]
   81448:	97fffd88 	bl	80a68 <syscall_handler>
   8144c:	1400000a 	b	81474 <elh_64_sync+0x70>
    else
        kprintf("error, unknown esr class %x\n", ec);
   81450:	f94013e4 	ldr	x4, [sp, #32]
   81454:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81458:	91158003 	add	x3, x0, #0x560
   8145c:	52800be2 	mov	w2, #0x5f                  	// #95
   81460:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81464:	910f8001 	add	x1, x0, #0x3e0
   81468:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8146c:	91126000 	add	x0, x0, #0x498
   81470:	94000660 	bl	82df0 <uart_printf>
    set_interrupt_el1(1);
   81474:	52800020 	mov	w0, #0x1                   	// #1
   81478:	97ffff0a 	bl	810a0 <set_interrupt_el1>
}
   8147c:	d503201f 	nop
   81480:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81484:	d65f03c0 	ret

0000000000081488 <elh_64_irq>:

void elh_64_irq(uint64_t* sp){
   81488:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8148c:	910003fd 	mov	x29, sp
   81490:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   81494:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81498:	9115c003 	add	x3, x0, #0x570
   8149c:	52800c82 	mov	w2, #0x64                  	// #100
   814a0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   814a4:	910f8001 	add	x1, x0, #0x3e0
   814a8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   814ac:	9111c000 	add	x0, x0, #0x470
   814b0:	94000650 	bl	82df0 <uart_printf>
    while(1);
   814b4:	14000000 	b	814b4 <elh_64_irq+0x2c>

00000000000814b8 <elh_64_fiq>:
}

void elh_64_fiq(uint64_t* sp){
   814b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   814bc:	910003fd 	mov	x29, sp
   814c0:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   814c4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   814c8:	91160003 	add	x3, x0, #0x580
   814cc:	52800d22 	mov	w2, #0x69                  	// #105
   814d0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   814d4:	910f8001 	add	x1, x0, #0x3e0
   814d8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   814dc:	9111c000 	add	x0, x0, #0x470
   814e0:	94000644 	bl	82df0 <uart_printf>
}
   814e4:	d503201f 	nop
   814e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   814ec:	d65f03c0 	ret

00000000000814f0 <elh_64_error>:

void elh_64_error(uint64_t* sp){
   814f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   814f4:	910003fd 	mov	x29, sp
   814f8:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   814fc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81500:	91164003 	add	x3, x0, #0x590
   81504:	52800da2 	mov	w2, #0x6d                  	// #109
   81508:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8150c:	910f8001 	add	x1, x0, #0x3e0
   81510:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81514:	9111c000 	add	x0, x0, #0x470
   81518:	94000636 	bl	82df0 <uart_printf>
}
   8151c:	d503201f 	nop
   81520:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81524:	d65f03c0 	ret

0000000000081528 <elh_32_sync>:

void elh_32_sync(uint64_t* sp){
   81528:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8152c:	910003fd 	mov	x29, sp
   81530:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   81534:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81538:	91168003 	add	x3, x0, #0x5a0
   8153c:	52800e22 	mov	w2, #0x71                  	// #113
   81540:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81544:	910f8001 	add	x1, x0, #0x3e0
   81548:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8154c:	9111c000 	add	x0, x0, #0x470
   81550:	94000628 	bl	82df0 <uart_printf>
}
   81554:	d503201f 	nop
   81558:	a8c27bfd 	ldp	x29, x30, [sp], #32
   8155c:	d65f03c0 	ret

0000000000081560 <elh_32_irq>:

void elh_32_irq(uint64_t* sp){
   81560:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81564:	910003fd 	mov	x29, sp
   81568:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   8156c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81570:	9116c003 	add	x3, x0, #0x5b0
   81574:	52800ea2 	mov	w2, #0x75                  	// #117
   81578:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8157c:	910f8001 	add	x1, x0, #0x3e0
   81580:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81584:	9111c000 	add	x0, x0, #0x470
   81588:	9400061a 	bl	82df0 <uart_printf>
}
   8158c:	d503201f 	nop
   81590:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81594:	d65f03c0 	ret

0000000000081598 <elh_32_fiq>:

void elh_32_fiq(uint64_t* sp){
   81598:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8159c:	910003fd 	mov	x29, sp
   815a0:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   815a4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815a8:	91170003 	add	x3, x0, #0x5c0
   815ac:	52800f22 	mov	w2, #0x79                  	// #121
   815b0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815b4:	910f8001 	add	x1, x0, #0x3e0
   815b8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815bc:	9111c000 	add	x0, x0, #0x470
   815c0:	9400060c 	bl	82df0 <uart_printf>
}
   815c4:	d503201f 	nop
   815c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   815cc:	d65f03c0 	ret

00000000000815d0 <elh_32_error>:

void elh_32_error(uint64_t* sp){
   815d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   815d4:	910003fd 	mov	x29, sp
   815d8:	f9000fe0 	str	x0, [sp, #24]
    debug("");
   815dc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815e0:	91174003 	add	x3, x0, #0x5d0
   815e4:	52800fa2 	mov	w2, #0x7d                  	// #125
   815e8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815ec:	910f8001 	add	x1, x0, #0x3e0
   815f0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   815f4:	9111c000 	add	x0, x0, #0x470
   815f8:	940005fe 	bl	82df0 <uart_printf>
}
   815fc:	d503201f 	nop
   81600:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81604:	d65f03c0 	ret

0000000000081608 <hello>:
} cmd_t;




int hello(int argc, char *argv[]){
   81608:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8160c:	910003fd 	mov	x29, sp
   81610:	b9001fe0 	str	w0, [sp, #28]
   81614:	f9000be1 	str	x1, [sp, #16]
    uart_printf("Hello World! I'm main kernel!\n");
   81618:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8161c:	91178000 	add	x0, x0, #0x5e0
   81620:	940005f4 	bl	82df0 <uart_printf>
    return 0;
   81624:	52800000 	mov	w0, #0x0                   	// #0
}
   81628:	a8c27bfd 	ldp	x29, x30, [sp], #32
   8162c:	d65f03c0 	ret

0000000000081630 <board_info>:

int board_info(int argc, char *argv[]){
   81630:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81634:	910003fd 	mov	x29, sp
   81638:	b9001fe0 	str	w0, [sp, #28]
   8163c:	f9000be1 	str	x1, [sp, #16]
    print_board_info();
   81640:	97fffe76 	bl	81018 <print_board_info>
    return 0;
   81644:	52800000 	mov	w0, #0x0                   	// #0
}
   81648:	a8c27bfd 	ldp	x29, x30, [sp], #32
   8164c:	d65f03c0 	ret

0000000000081650 <ls>:

int ls(int argc, char *argv[]){
   81650:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81654:	910003fd 	mov	x29, sp
   81658:	b9001fe0 	str	w0, [sp, #28]
   8165c:	f9000be1 	str	x1, [sp, #16]
    cpio_ls();
   81660:	94000dcf 	bl	84d9c <cpio_ls>
    return 0;
   81664:	52800000 	mov	w0, #0x0                   	// #0
}
   81668:	a8c27bfd 	ldp	x29, x30, [sp], #32
   8166c:	d65f03c0 	ret

0000000000081670 <cat>:

int cat(int argc, char *argv[]){
   81670:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   81674:	910003fd 	mov	x29, sp
   81678:	b9001fe0 	str	w0, [sp, #28]
   8167c:	f9000be1 	str	x1, [sp, #16]
    if(argc < 2){
   81680:	b9401fe0 	ldr	w0, [sp, #28]
   81684:	7100041f 	cmp	w0, #0x1
   81688:	540000cc 	b.gt	816a0 <cat+0x30>
        uart_printf("Usage: cat <filepath>\n");
   8168c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81690:	91180000 	add	x0, x0, #0x600
   81694:	940005d7 	bl	82df0 <uart_printf>
        return -1;
   81698:	12800000 	mov	w0, #0xffffffff            	// #-1
   8169c:	1400002e 	b	81754 <cat+0xe4>
    }

    cpio_path path = cpio_search(argv[1]);
   816a0:	f9400be0 	ldr	x0, [sp, #16]
   816a4:	91002000 	add	x0, x0, #0x8
   816a8:	f9400000 	ldr	x0, [x0]
   816ac:	9100a3e1 	add	x1, sp, #0x28
   816b0:	aa0103e8 	mov	x8, x1
   816b4:	94000d8f 	bl	84cf0 <cpio_search>
    if(path.namesize == 0)
   816b8:	f9401fe0 	ldr	x0, [sp, #56]
   816bc:	f100001f 	cmp	x0, #0x0
   816c0:	54000121 	b.ne	816e4 <cat+0x74>  // b.any
        uart_printf("file not found %s\n", argv[1]);
   816c4:	f9400be0 	ldr	x0, [sp, #16]
   816c8:	91002000 	add	x0, x0, #0x8
   816cc:	f9400000 	ldr	x0, [x0]
   816d0:	aa0003e1 	mov	x1, x0
   816d4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   816d8:	91186000 	add	x0, x0, #0x618
   816dc:	940005c5 	bl	82df0 <uart_printf>
   816e0:	14000019 	b	81744 <cat+0xd4>
    else if(path.mode != CPIO_FILE)
   816e4:	b9404be0 	ldr	w0, [sp, #72]
   816e8:	7100e01f 	cmp	w0, #0x38
   816ec:	540000a0 	b.eq	81700 <cat+0x90>  // b.none
        uart_printf("not a file\n");
   816f0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   816f4:	9118c000 	add	x0, x0, #0x630
   816f8:	940005be 	bl	82df0 <uart_printf>
   816fc:	14000012 	b	81744 <cat+0xd4>
    else
        for(int i=0; i<path.filesize; ++i)
   81700:	b9005fff 	str	wzr, [sp, #92]
   81704:	1400000c 	b	81734 <cat+0xc4>
        uart_printf("%c", path.data[i]);
   81708:	f9401be1 	ldr	x1, [sp, #48]
   8170c:	b9805fe0 	ldrsw	x0, [sp, #92]
   81710:	8b000020 	add	x0, x1, x0
   81714:	39400000 	ldrb	w0, [x0]
   81718:	2a0003e1 	mov	w1, w0
   8171c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81720:	91190000 	add	x0, x0, #0x640
   81724:	940005b3 	bl	82df0 <uart_printf>
        for(int i=0; i<path.filesize; ++i)
   81728:	b9405fe0 	ldr	w0, [sp, #92]
   8172c:	11000400 	add	w0, w0, #0x1
   81730:	b9005fe0 	str	w0, [sp, #92]
   81734:	b9805fe1 	ldrsw	x1, [sp, #92]
   81738:	f94023e0 	ldr	x0, [sp, #64]
   8173c:	eb00003f 	cmp	x1, x0
   81740:	54fffe43 	b.cc	81708 <cat+0x98>  // b.lo, b.ul, b.last
    uart_printf("\n");
   81744:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81748:	91192000 	add	x0, x0, #0x648
   8174c:	940005a9 	bl	82df0 <uart_printf>
    return 0;
   81750:	52800000 	mov	w0, #0x0                   	// #0
}
   81754:	a8c67bfd 	ldp	x29, x30, [sp], #96
   81758:	d65f03c0 	ret

000000000008175c <load>:

int load(int argc, char *argv[]){
   8175c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
   81760:	910003fd 	mov	x29, sp
   81764:	b9004fe0 	str	w0, [sp, #76]
   81768:	f90023e1 	str	x1, [sp, #64]
    // LAB3-2 Load user program to memory
    if(argc < 2){
   8176c:	b9404fe0 	ldr	w0, [sp, #76]
   81770:	7100041f 	cmp	w0, #0x1
   81774:	540000cc 	b.gt	8178c <load+0x30>
        uart_printf("Usage: load <filename>\n");
   81778:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8177c:	91194000 	add	x0, x0, #0x650
   81780:	9400059c 	bl	82df0 <uart_printf>
        return -1;
   81784:	12800000 	mov	w0, #0xffffffff            	// #-1
   81788:	1400002f 	b	81844 <load+0xe8>
    }

    char* pathname = argv[1];
   8178c:	f94023e0 	ldr	x0, [sp, #64]
   81790:	f9400400 	ldr	x0, [x0, #8]
   81794:	f90047e0 	str	x0, [sp, #136]
    cpio_path path = cpio_search(pathname);
   81798:	910163e0 	add	x0, sp, #0x58
   8179c:	aa0003e8 	mov	x8, x0
   817a0:	f94047e0 	ldr	x0, [sp, #136]
   817a4:	94000d53 	bl	84cf0 <cpio_search>
    if(path.namesize == 0)
   817a8:	f94037e0 	ldr	x0, [sp, #104]
   817ac:	f100001f 	cmp	x0, #0x0
   817b0:	54000181 	b.ne	817e0 <load+0x84>  // b.any
        throw(-1, "file not found %s", pathname);
   817b4:	f94047e4 	ldr	x4, [sp, #136]
   817b8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   817bc:	912a4003 	add	x3, x0, #0xa90
   817c0:	52800782 	mov	w2, #0x3c                  	// #60
   817c4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   817c8:	9119a001 	add	x1, x0, #0x668
   817cc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   817d0:	9119e000 	add	x0, x0, #0x678
   817d4:	94000587 	bl	82df0 <uart_printf>
   817d8:	12800000 	mov	w0, #0xffffffff            	// #-1
   817dc:	1400001a 	b	81844 <load+0xe8>
    else if(path.mode != CPIO_FILE)
   817e0:	b9407be0 	ldr	w0, [sp, #120]
   817e4:	7100e01f 	cmp	w0, #0x38
   817e8:	54000160 	b.eq	81814 <load+0xb8>  // b.none
        throw(-1, "Not a file");
   817ec:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   817f0:	912a4003 	add	x3, x0, #0xa90
   817f4:	528007c2 	mov	w2, #0x3e                  	// #62
   817f8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   817fc:	9119a001 	add	x1, x0, #0x668
   81800:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81804:	911ac000 	add	x0, x0, #0x6b0
   81808:	9400057a 	bl	82df0 <uart_printf>
   8180c:	12800000 	mov	w0, #0xffffffff            	// #-1
   81810:	1400000d 	b	81844 <load+0xe8>

    kernel_load(path);
   81814:	910043e0 	add	x0, sp, #0x10
   81818:	910163e1 	add	x1, sp, #0x58
   8181c:	a9400c22 	ldp	x2, x3, [x1]
   81820:	a9000c02 	stp	x2, x3, [x0]
   81824:	a9410c22 	ldp	x2, x3, [x1, #16]
   81828:	a9010c02 	stp	x2, x3, [x0, #16]
   8182c:	a9420c22 	ldp	x2, x3, [x1, #32]
   81830:	a9020c02 	stp	x2, x3, [x0, #32]
   81834:	910043e0 	add	x0, sp, #0x10
   81838:	94000ba1 	bl	846bc <kernel_load>
    thread_schedule();
   8183c:	940009a7 	bl	83ed8 <thread_schedule>
    return 0;
   81840:	52800000 	mov	w0, #0x0                   	// #0
}
   81844:	a8c97bfd 	ldp	x29, x30, [sp], #144
   81848:	d65f03c0 	ret

000000000008184c <set>:

void set(long addr, unsigned int value) {
   8184c:	d10083ff 	sub	sp, sp, #0x20
   81850:	f90007e0 	str	x0, [sp, #8]
   81854:	b90007e1 	str	w1, [sp, #4]
    volatile unsigned int* point = (unsigned int*)addr;
   81858:	f94007e0 	ldr	x0, [sp, #8]
   8185c:	f9000fe0 	str	x0, [sp, #24]
    *point = value;
   81860:	f9400fe0 	ldr	x0, [sp, #24]
   81864:	b94007e1 	ldr	w1, [sp, #4]
   81868:	b9000001 	str	w1, [x0]
}
   8186c:	d503201f 	nop
   81870:	910083ff 	add	sp, sp, #0x20
   81874:	d65f03c0 	ret

0000000000081878 <reset>:

void reset(int tick) {
   81878:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8187c:	910003fd 	mov	x29, sp
   81880:	b9001fe0 	str	w0, [sp, #28]
    uart_printf("reboot after %d ticks\n", tick);
   81884:	b9401fe1 	ldr	w1, [sp, #28]
   81888:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8188c:	911ba000 	add	x0, x0, #0x6e8
   81890:	94000558 	bl	82df0 <uart_printf>
    set(PM_RSTC, PM_PASSWORD | 0x20);  // full reset
   81894:	52800401 	mov	w1, #0x20                  	// #32
   81898:	72ab4001 	movk	w1, #0x5a00, lsl #16
   8189c:	d2800380 	mov	x0, #0x1c                  	// #28
   818a0:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   818a4:	97ffffea 	bl	8184c <set>
    set(PM_WDOG, PM_PASSWORD | tick);  // number of watchdog tick
   818a8:	b9401fe1 	ldr	w1, [sp, #28]
   818ac:	52ab4000 	mov	w0, #0x5a000000            	// #1509949440
   818b0:	2a000020 	orr	w0, w1, w0
   818b4:	2a0003e1 	mov	w1, w0
   818b8:	d2800480 	mov	x0, #0x24                  	// #36
   818bc:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   818c0:	97ffffe3 	bl	8184c <set>
}
   818c4:	d503201f 	nop
   818c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   818cc:	d65f03c0 	ret

00000000000818d0 <cancel_reset>:

void cancel_reset() {
   818d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   818d4:	910003fd 	mov	x29, sp
    uart_printf("cancel reboot \n");
   818d8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   818dc:	911c0000 	add	x0, x0, #0x700
   818e0:	94000544 	bl	82df0 <uart_printf>
    set(PM_RSTC, PM_PASSWORD | 0);  // full reset
   818e4:	52ab4001 	mov	w1, #0x5a000000            	// #1509949440
   818e8:	d2800380 	mov	x0, #0x1c                  	// #28
   818ec:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   818f0:	97ffffd7 	bl	8184c <set>
    set(PM_WDOG, PM_PASSWORD | 0);  // number of watchdog tick
   818f4:	52ab4001 	mov	w1, #0x5a000000            	// #1509949440
   818f8:	d2800480 	mov	x0, #0x24                  	// #36
   818fc:	f2a7e200 	movk	x0, #0x3f10, lsl #16
   81900:	97ffffd3 	bl	8184c <set>
}
   81904:	d503201f 	nop
   81908:	a8c17bfd 	ldp	x29, x30, [sp], #16
   8190c:	d65f03c0 	ret

0000000000081910 <reboot>:


int reboot(int argc, char *argv[]){
   81910:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81914:	910003fd 	mov	x29, sp
   81918:	b9001fe0 	str	w0, [sp, #28]
   8191c:	f9000be1 	str	x1, [sp, #16]
    unsigned int tick = 10;
   81920:	52800140 	mov	w0, #0xa                   	// #10
   81924:	b9002fe0 	str	w0, [sp, #44]
    if(argc >= 2)
   81928:	b9401fe0 	ldr	w0, [sp, #28]
   8192c:	7100041f 	cmp	w0, #0x1
   81930:	540000cd 	b.le	81948 <reboot+0x38>
        tick = m_atoi(argv[1]);
   81934:	f9400be0 	ldr	x0, [sp, #16]
   81938:	91002000 	add	x0, x0, #0x8
   8193c:	f9400000 	ldr	x0, [x0]
   81940:	940001ed 	bl	820f4 <m_atoi>
   81944:	b9002fe0 	str	w0, [sp, #44]
    if(tick < 0)
        cancel_reset();
    else
        reset(tick);
   81948:	b9402fe0 	ldr	w0, [sp, #44]
   8194c:	97ffffcb 	bl	81878 <reset>
    return 0;
   81950:	52800000 	mov	w0, #0x0                   	// #0
}
   81954:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81958:	d65f03c0 	ret

000000000008195c <timeout_cb>:

void timeout_cb(void *arg){
   8195c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81960:	910003fd 	mov	x29, sp
   81964:	f9000fe0 	str	x0, [sp, #24]
    char *mesg = (char *)arg;
   81968:	f9400fe0 	ldr	x0, [sp, #24]
   8196c:	f90017e0 	str	x0, [sp, #40]
    uart_printf("\n[TIMEOUT] Mesg: %s, Sec: %d\n", mesg, get_cpu_time());
   81970:	940007c3 	bl	8387c <get_cpu_time>
   81974:	aa0003e2 	mov	x2, x0
   81978:	f94017e1 	ldr	x1, [sp, #40]
   8197c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81980:	911c4000 	add	x0, x0, #0x710
   81984:	9400051b 	bl	82df0 <uart_printf>
}
   81988:	d503201f 	nop
   8198c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81990:	d65f03c0 	ret

0000000000081994 <set_timeout>:

int set_timeout(int argc, char *argv[]){
   81994:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81998:	910003fd 	mov	x29, sp
   8199c:	b9001fe0 	str	w0, [sp, #28]
   819a0:	f9000be1 	str	x1, [sp, #16]
    if(argc != 3){
   819a4:	b9401fe0 	ldr	w0, [sp, #28]
   819a8:	71000c1f 	cmp	w0, #0x3
   819ac:	54000120 	b.eq	819d0 <set_timeout+0x3c>  // b.none
        uart_printf("Usage: %s <Mesg> <Second>\n", argv[0]);
   819b0:	f9400be0 	ldr	x0, [sp, #16]
   819b4:	f9400000 	ldr	x0, [x0]
   819b8:	aa0003e1 	mov	x1, x0
   819bc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   819c0:	911cc000 	add	x0, x0, #0x730
   819c4:	9400050b 	bl	82df0 <uart_printf>
        return -1;
   819c8:	12800000 	mov	w0, #0xffffffff            	// #-1
   819cc:	1400002f 	b	81a88 <set_timeout+0xf4>
    }
    unsigned long long sec = m_atoi(argv[2]);
   819d0:	f9400be0 	ldr	x0, [sp, #16]
   819d4:	91004000 	add	x0, x0, #0x10
   819d8:	f9400000 	ldr	x0, [x0]
   819dc:	940001c6 	bl	820f4 <m_atoi>
   819e0:	93407c00 	sxtw	x0, w0
   819e4:	f90017e0 	str	x0, [sp, #40]
    char *mesg = simple_malloc(m_strlen(argv[1])+1);
   819e8:	f9400be0 	ldr	x0, [sp, #16]
   819ec:	91002000 	add	x0, x0, #0x8
   819f0:	f9400000 	ldr	x0, [x0]
   819f4:	94000197 	bl	82050 <m_strlen>
   819f8:	11000400 	add	w0, w0, #0x1
   819fc:	94000d2b 	bl	84ea8 <simple_malloc>
   81a00:	f90013e0 	str	x0, [sp, #32]
    m_sprintf(mesg, "%s\0", argv[1]);
   81a04:	f9400be0 	ldr	x0, [sp, #16]
   81a08:	91002000 	add	x0, x0, #0x8
   81a0c:	f9400000 	ldr	x0, [x0]
   81a10:	aa0003e2 	mov	x2, x0
   81a14:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81a18:	911d4001 	add	x1, x0, #0x750
   81a1c:	f94013e0 	ldr	x0, [sp, #32]
   81a20:	940003eb 	bl	829cc <m_sprintf>
    if(timer_add(sec, timeout_cb, mesg)){
   81a24:	f94013e2 	ldr	x2, [sp, #32]
   81a28:	90000000 	adrp	x0, 81000 <get_board_revision+0x98>
   81a2c:	91257001 	add	x1, x0, #0x95c
   81a30:	f94017e0 	ldr	x0, [sp, #40]
   81a34:	940007fd 	bl	83a28 <timer_add>
   81a38:	7100001f 	cmp	w0, #0x0
   81a3c:	54000160 	b.eq	81a68 <set_timeout+0xd4>  // b.none
        debug(""); // add timer fail;
   81a40:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81a44:	912a6003 	add	x3, x0, #0xa98
   81a48:	52800e02 	mov	w2, #0x70                  	// #112
   81a4c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81a50:	9119a001 	add	x1, x0, #0x668
   81a54:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81a58:	911d6000 	add	x0, x0, #0x758
   81a5c:	940004e5 	bl	82df0 <uart_printf>
        return -1;
   81a60:	12800000 	mov	w0, #0xffffffff            	// #-1
   81a64:	14000009 	b	81a88 <set_timeout+0xf4>
    }
    uart_printf("\n[ADD TIMEOUT] Time: %d Mesg: %s, Sec: %d\n", get_cpu_time(), mesg, sec);
   81a68:	94000785 	bl	8387c <get_cpu_time>
   81a6c:	f94017e3 	ldr	x3, [sp, #40]
   81a70:	f94013e2 	ldr	x2, [sp, #32]
   81a74:	aa0003e1 	mov	x1, x0
   81a78:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81a7c:	911e0000 	add	x0, x0, #0x780
   81a80:	940004dc 	bl	82df0 <uart_printf>
    return 0;
   81a84:	52800000 	mov	w0, #0x0                   	// #0
}
   81a88:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81a8c:	d65f03c0 	ret

0000000000081a90 <demo_async>:

int demo_async(int argc, char **argv){
   81a90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81a94:	910003fd 	mov	x29, sp
   81a98:	b9001fe0 	str	w0, [sp, #28]
   81a9c:	f9000be1 	str	x1, [sp, #16]
    demo_uart_async();
   81aa0:	94000605 	bl	832b4 <demo_uart_async>
    return 0;
   81aa4:	52800000 	mov	w0, #0x0                   	// #0
}
   81aa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81aac:	d65f03c0 	ret

0000000000081ab0 <delay_timer>:

void delay_timer(void *arg){
   81ab0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   81ab4:	910003fd 	mov	x29, sp
   81ab8:	f9000bf3 	str	x19, [sp, #16]
   81abc:	f90017e0 	str	x0, [sp, #40]
    int sec = *(int *) arg;
   81ac0:	f94017e0 	ldr	x0, [sp, #40]
   81ac4:	b9400000 	ldr	w0, [x0]
   81ac8:	b9003fe0 	str	w0, [sp, #60]
    debug("delay timer");
   81acc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81ad0:	912aa003 	add	x3, x0, #0xaa8
   81ad4:	52800fc2 	mov	w2, #0x7e                  	// #126
   81ad8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81adc:	9119a001 	add	x1, x0, #0x668
   81ae0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81ae4:	911ec000 	add	x0, x0, #0x7b0
   81ae8:	940004c2 	bl	82df0 <uart_printf>
    unsigned long long start = get_cpu_cycles();
   81aec:	94001199 	bl	86150 <get_cpu_cycles>
   81af0:	f9001be0 	str	x0, [sp, #48]
    while(get_cpu_cycles() > start + get_cpu_frequency()*sec){
   81af4:	14000002 	b	81afc <delay_timer+0x4c>
        asm volatile("nop");
   81af8:	d503201f 	nop
    while(get_cpu_cycles() > start + get_cpu_frequency()*sec){
   81afc:	94001195 	bl	86150 <get_cpu_cycles>
   81b00:	aa0003f3 	mov	x19, x0
   81b04:	94001197 	bl	86160 <get_cpu_frequency>
   81b08:	aa0003e1 	mov	x1, x0
   81b0c:	b9803fe0 	ldrsw	x0, [sp, #60]
   81b10:	9b007c21 	mul	x1, x1, x0
   81b14:	f9401be0 	ldr	x0, [sp, #48]
   81b18:	8b000020 	add	x0, x1, x0
   81b1c:	eb00027f 	cmp	x19, x0
   81b20:	54fffec8 	b.hi	81af8 <delay_timer+0x48>  // b.pmore
    }
    debug("delay timer end");
   81b24:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81b28:	912aa003 	add	x3, x0, #0xaa8
   81b2c:	52801062 	mov	w2, #0x83                  	// #131
   81b30:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81b34:	9119a001 	add	x1, x0, #0x668
   81b38:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81b3c:	911fa000 	add	x0, x0, #0x7e8
   81b40:	940004ac 	bl	82df0 <uart_printf>
}
   81b44:	d503201f 	nop
   81b48:	f9400bf3 	ldr	x19, [sp, #16]
   81b4c:	a8c47bfd 	ldp	x29, x30, [sp], #64
   81b50:	d65f03c0 	ret

0000000000081b54 <mf_dump>:

int mf_dump(int argc, char **argv){
   81b54:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81b58:	910003fd 	mov	x29, sp
   81b5c:	b9001fe0 	str	w0, [sp, #28]
   81b60:	f9000be1 	str	x1, [sp, #16]
    int filter = -1;
   81b64:	12800000 	mov	w0, #0xffffffff            	// #-1
   81b68:	b9002fe0 	str	w0, [sp, #44]
    if(argc > 1)
   81b6c:	b9401fe0 	ldr	w0, [sp, #28]
   81b70:	7100041f 	cmp	w0, #0x1
   81b74:	540000cd 	b.le	81b8c <mf_dump+0x38>
        filter = m_atoi(argv[1]);
   81b78:	f9400be0 	ldr	x0, [sp, #16]
   81b7c:	91002000 	add	x0, x0, #0x8
   81b80:	f9400000 	ldr	x0, [x0]
   81b84:	9400015c 	bl	820f4 <m_atoi>
   81b88:	b9002fe0 	str	w0, [sp, #44]
    mframe_dump(filter);
   81b8c:	b9402fe0 	ldr	w0, [sp, #44]
   81b90:	94001074 	bl	85d60 <mframe_dump>
    return 0;
   81b94:	52800000 	mov	w0, #0x0                   	// #0
}
   81b98:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81b9c:	d65f03c0 	ret

0000000000081ba0 <mf_alloc>:

int mf_alloc(int argc, char **argv){
   81ba0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81ba4:	910003fd 	mov	x29, sp
   81ba8:	b9001fe0 	str	w0, [sp, #28]
   81bac:	f9000be1 	str	x1, [sp, #16]
    if(argc != 2){
   81bb0:	b9401fe0 	ldr	w0, [sp, #28]
   81bb4:	7100081f 	cmp	w0, #0x2
   81bb8:	540000c0 	b.eq	81bd0 <mf_alloc+0x30>  // b.none
        uart_printf("Usage: mf_alloc <bytes>\n");
   81bbc:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81bc0:	91208000 	add	x0, x0, #0x820
   81bc4:	9400048b 	bl	82df0 <uart_printf>
        return -1;
   81bc8:	12800000 	mov	w0, #0xffffffff            	// #-1
   81bcc:	1400000f 	b	81c08 <mf_alloc+0x68>
    }
    unsigned long bytes = m_atoi(argv[1]);
   81bd0:	f9400be0 	ldr	x0, [sp, #16]
   81bd4:	91002000 	add	x0, x0, #0x8
   81bd8:	f9400000 	ldr	x0, [x0]
   81bdc:	94000146 	bl	820f4 <m_atoi>
   81be0:	93407c00 	sxtw	x0, w0
   81be4:	f90017e0 	str	x0, [sp, #40]
    void* ptr = mframe_alloc(bytes);
   81be8:	f94017e0 	ldr	x0, [sp, #40]
   81bec:	94000e79 	bl	855d0 <mframe_alloc>
   81bf0:	f90013e0 	str	x0, [sp, #32]
    uart_printf("allocate frame at 0x%x\n", ptr);
   81bf4:	f94013e1 	ldr	x1, [sp, #32]
   81bf8:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81bfc:	91210000 	add	x0, x0, #0x840
   81c00:	9400047c 	bl	82df0 <uart_printf>
    return 0;
   81c04:	52800000 	mov	w0, #0x0                   	// #0
}
   81c08:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81c0c:	d65f03c0 	ret

0000000000081c10 <mf_free>:

int mf_free(int argc, char **argv){
   81c10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81c14:	910003fd 	mov	x29, sp
   81c18:	b9001fe0 	str	w0, [sp, #28]
   81c1c:	f9000be1 	str	x1, [sp, #16]
    if(argc != 2){
   81c20:	b9401fe0 	ldr	w0, [sp, #28]
   81c24:	7100081f 	cmp	w0, #0x2
   81c28:	540000c0 	b.eq	81c40 <mf_free+0x30>  // b.none
        uart_printf("Usage: mf_free <0xaddr>\n");
   81c2c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81c30:	91216000 	add	x0, x0, #0x858
   81c34:	9400046f 	bl	82df0 <uart_printf>
        return -1;
   81c38:	12800000 	mov	w0, #0xffffffff            	// #-1
   81c3c:	14000013 	b	81c88 <mf_free+0x78>
    }
    char* addr = (char*)(long)m_htoi(argv[1]);
   81c40:	f9400be0 	ldr	x0, [sp, #16]
   81c44:	91002000 	add	x0, x0, #0x8
   81c48:	f9400000 	ldr	x0, [x0]
   81c4c:	9400016e 	bl	82204 <m_htoi>
   81c50:	93407c00 	sxtw	x0, w0
   81c54:	f90017e0 	str	x0, [sp, #40]
    debug("free addr %x", addr);
   81c58:	f94017e4 	ldr	x4, [sp, #40]
   81c5c:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81c60:	912ae003 	add	x3, x0, #0xab8
   81c64:	528013e2 	mov	w2, #0x9f                  	// #159
   81c68:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81c6c:	9119a001 	add	x1, x0, #0x668
   81c70:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81c74:	9121e000 	add	x0, x0, #0x878
   81c78:	9400045e 	bl	82df0 <uart_printf>
    mframe_free(addr);
   81c7c:	f94017e0 	ldr	x0, [sp, #40]
   81c80:	94000ec2 	bl	85788 <mframe_free>

    return 0;
   81c84:	52800000 	mov	w0, #0x0                   	// #0
}
   81c88:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81c8c:	d65f03c0 	ret

0000000000081c90 <schedule>:

int schedule(int argc, char **argv){
   81c90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   81c94:	910003fd 	mov	x29, sp
   81c98:	b9001fe0 	str	w0, [sp, #28]
   81c9c:	f9000be1 	str	x1, [sp, #16]
    kprintf("start schedule");
   81ca0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81ca4:	912b0003 	add	x3, x0, #0xac0
   81ca8:	528014c2 	mov	w2, #0xa6                  	// #166
   81cac:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81cb0:	9119a001 	add	x1, x0, #0x668
   81cb4:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81cb8:	9122c000 	add	x0, x0, #0x8b0
   81cbc:	9400044d 	bl	82df0 <uart_printf>
    thread_schedule();
   81cc0:	94000886 	bl	83ed8 <thread_schedule>
    return 0;
   81cc4:	52800000 	mov	w0, #0x0                   	// #0
}
   81cc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   81ccc:	d65f03c0 	ret

0000000000081cd0 <help>:
    {"mf_alloc",    "mframe alloc test",    mf_alloc},
    {"mf_free",     "mframe free test",     mf_free},
    {"schedule",    "schedule thread",      schedule}
};

int help(int argc, char *argv[]){
   81cd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   81cd4:	910003fd 	mov	x29, sp
   81cd8:	b9001fe0 	str	w0, [sp, #28]
   81cdc:	f9000be1 	str	x1, [sp, #16]
    for(int i=0; i<sizeof(cmds)/sizeof(cmds[0]); ++i)
   81ce0:	b9002fff 	str	wzr, [sp, #44]
   81ce4:	1400001b 	b	81d50 <help+0x80>
        uart_printf("%s\t\t%s\n", cmds[i].name, cmds[i].description);
   81ce8:	b0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   81cec:	91246002 	add	x2, x0, #0x918
   81cf0:	b9802fe1 	ldrsw	x1, [sp, #44]
   81cf4:	aa0103e0 	mov	x0, x1
   81cf8:	d37ff800 	lsl	x0, x0, #1
   81cfc:	8b010000 	add	x0, x0, x1
   81d00:	d37df000 	lsl	x0, x0, #3
   81d04:	8b000040 	add	x0, x2, x0
   81d08:	f9400003 	ldr	x3, [x0]
   81d0c:	b0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   81d10:	91246002 	add	x2, x0, #0x918
   81d14:	b9802fe1 	ldrsw	x1, [sp, #44]
   81d18:	aa0103e0 	mov	x0, x1
   81d1c:	d37ff800 	lsl	x0, x0, #1
   81d20:	8b010000 	add	x0, x0, x1
   81d24:	d37df000 	lsl	x0, x0, #3
   81d28:	8b000040 	add	x0, x2, x0
   81d2c:	f9400400 	ldr	x0, [x0, #8]
   81d30:	aa0003e2 	mov	x2, x0
   81d34:	aa0303e1 	mov	x1, x3
   81d38:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81d3c:	91298000 	add	x0, x0, #0xa60
   81d40:	9400042c 	bl	82df0 <uart_printf>
    for(int i=0; i<sizeof(cmds)/sizeof(cmds[0]); ++i)
   81d44:	b9402fe0 	ldr	w0, [sp, #44]
   81d48:	11000400 	add	w0, w0, #0x1
   81d4c:	b9002fe0 	str	w0, [sp, #44]
   81d50:	b9402fe0 	ldr	w0, [sp, #44]
   81d54:	7100301f 	cmp	w0, #0xc
   81d58:	54fffc89 	b.ls	81ce8 <help+0x18>  // b.plast
    return 0;
   81d5c:	52800000 	mov	w0, #0x0                   	// #0
}
   81d60:	a8c37bfd 	ldp	x29, x30, [sp], #48
   81d64:	d65f03c0 	ret

0000000000081d68 <shell_loop>:


int shell_loop(){
   81d68:	d108c3ff 	sub	sp, sp, #0x230
   81d6c:	a9007bfd 	stp	x29, x30, [sp]
   81d70:	910003fd 	mov	x29, sp
    while (1) {	
		char buf[256];
        unsigned int len = 0;
   81d74:	b9022fff 	str	wzr, [sp, #556]
		uart_printf("$ ");
   81d78:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81d7c:	9129a000 	add	x0, x0, #0xa68
   81d80:	9400041c 	bl	82df0 <uart_printf>
		while(len < 256){
   81d84:	1400002d 	b	81e38 <shell_loop+0xd0>
			buf[len] = uart_recv();
   81d88:	94000353 	bl	82ad4 <uart_recv>
   81d8c:	12001c02 	and	w2, w0, #0xff
   81d90:	b9422fe0 	ldr	w0, [sp, #556]
   81d94:	910043e1 	add	x1, sp, #0x10
   81d98:	38206822 	strb	w2, [x1, x0]
            if(buf[len] == 127){
   81d9c:	b9422fe0 	ldr	w0, [sp, #556]
   81da0:	910043e1 	add	x1, sp, #0x10
   81da4:	38606820 	ldrb	w0, [x1, x0]
   81da8:	7101fc1f 	cmp	w0, #0x7f
   81dac:	54000181 	b.ne	81ddc <shell_loop+0x74>  // b.any
                if(len == 0) continue;
   81db0:	b9422fe0 	ldr	w0, [sp, #556]
   81db4:	7100001f 	cmp	w0, #0x0
   81db8:	54000041 	b.ne	81dc0 <shell_loop+0x58>  // b.any
   81dbc:	1400001f 	b	81e38 <shell_loop+0xd0>
                uart_printf("\b \b");
   81dc0:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81dc4:	9129c000 	add	x0, x0, #0xa70
   81dc8:	9400040a 	bl	82df0 <uart_printf>
                len--;
   81dcc:	b9422fe0 	ldr	w0, [sp, #556]
   81dd0:	51000400 	sub	w0, w0, #0x1
   81dd4:	b9022fe0 	str	w0, [sp, #556]
   81dd8:	14000018 	b	81e38 <shell_loop+0xd0>
            }
            else{
			    uart_printf("%c", buf[len]);
   81ddc:	b9422fe0 	ldr	w0, [sp, #556]
   81de0:	910043e1 	add	x1, sp, #0x10
   81de4:	38606820 	ldrb	w0, [x1, x0]
   81de8:	2a0003e1 	mov	w1, w0
   81dec:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81df0:	91190000 	add	x0, x0, #0x640
   81df4:	940003ff 	bl	82df0 <uart_printf>
                len++;
   81df8:	b9422fe0 	ldr	w0, [sp, #556]
   81dfc:	11000400 	add	w0, w0, #0x1
   81e00:	b9022fe0 	str	w0, [sp, #556]
                if(buf[len-1] == '\n'){
   81e04:	b9422fe0 	ldr	w0, [sp, #556]
   81e08:	51000400 	sub	w0, w0, #0x1
   81e0c:	2a0003e0 	mov	w0, w0
   81e10:	910043e1 	add	x1, sp, #0x10
   81e14:	38606820 	ldrb	w0, [x1, x0]
   81e18:	7100281f 	cmp	w0, #0xa
   81e1c:	540000e1 	b.ne	81e38 <shell_loop+0xd0>  // b.any
                    buf[len-1] = '\0';
   81e20:	b9422fe0 	ldr	w0, [sp, #556]
   81e24:	51000400 	sub	w0, w0, #0x1
   81e28:	2a0003e0 	mov	w0, w0
   81e2c:	910043e1 	add	x1, sp, #0x10
   81e30:	3820683f 	strb	wzr, [x1, x0]
				    break;
   81e34:	14000004 	b	81e44 <shell_loop+0xdc>
		while(len < 256){
   81e38:	b9422fe0 	ldr	w0, [sp, #556]
   81e3c:	7103fc1f 	cmp	w0, #0xff
   81e40:	54fffa49 	b.ls	81d88 <shell_loop+0x20>  // b.plast
			    }
            }
		}
        
        unsigned int argc = 0;
   81e44:	b9022bff 	str	wzr, [sp, #552]
        char *argv[32];
        char *next = buf;
   81e48:	910043e0 	add	x0, sp, #0x10
   81e4c:	f9010be0 	str	x0, [sp, #528]
        char *token = m_strtok(buf, ' ', &next);
   81e50:	910843e1 	add	x1, sp, #0x210
   81e54:	910043e0 	add	x0, sp, #0x10
   81e58:	aa0103e2 	mov	x2, x1
   81e5c:	52800401 	mov	w1, #0x20                  	// #32
   81e60:	9400004a 	bl	81f88 <m_strtok>
   81e64:	f90113e0 	str	x0, [sp, #544]
        while(*token != 0){
   81e68:	1400000f 	b	81ea4 <shell_loop+0x13c>
            argv[argc++] = token;
   81e6c:	b9422be0 	ldr	w0, [sp, #552]
   81e70:	11000401 	add	w1, w0, #0x1
   81e74:	b9022be1 	str	w1, [sp, #552]
   81e78:	2a0003e0 	mov	w0, w0
   81e7c:	d37df000 	lsl	x0, x0, #3
   81e80:	910443e1 	add	x1, sp, #0x110
   81e84:	f94113e2 	ldr	x2, [sp, #544]
   81e88:	f8206822 	str	x2, [x1, x0]
            token = m_strtok(next, ' ', &next);
   81e8c:	f9410be0 	ldr	x0, [sp, #528]
   81e90:	910843e1 	add	x1, sp, #0x210
   81e94:	aa0103e2 	mov	x2, x1
   81e98:	52800401 	mov	w1, #0x20                  	// #32
   81e9c:	9400003b 	bl	81f88 <m_strtok>
   81ea0:	f90113e0 	str	x0, [sp, #544]
        while(*token != 0){
   81ea4:	f94113e0 	ldr	x0, [sp, #544]
   81ea8:	39400000 	ldrb	w0, [x0]
   81eac:	7100001f 	cmp	w0, #0x0
   81eb0:	54fffde1 	b.ne	81e6c <shell_loop+0x104>  // b.any
        }

        if(argc == 0)
   81eb4:	b9422be0 	ldr	w0, [sp, #552]
   81eb8:	7100001f 	cmp	w0, #0x0
   81ebc:	54000620 	b.eq	81f80 <shell_loop+0x218>  // b.none
            continue;
        int valid = 0;
   81ec0:	b9021fff 	str	wzr, [sp, #540]
        for(int i=0; i<sizeof(cmds)/sizeof(cmds[0]); ++i){
   81ec4:	b9021bff 	str	wzr, [sp, #536]
   81ec8:	14000022 	b	81f50 <shell_loop+0x1e8>
            if(0 == m_strcmp(argv[0], cmds[i].name)){
   81ecc:	f9408be3 	ldr	x3, [sp, #272]
   81ed0:	b0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   81ed4:	91246002 	add	x2, x0, #0x918
   81ed8:	b9821be1 	ldrsw	x1, [sp, #536]
   81edc:	aa0103e0 	mov	x0, x1
   81ee0:	d37ff800 	lsl	x0, x0, #1
   81ee4:	8b010000 	add	x0, x0, x1
   81ee8:	d37df000 	lsl	x0, x0, #3
   81eec:	8b000040 	add	x0, x2, x0
   81ef0:	f9400000 	ldr	x0, [x0]
   81ef4:	aa0003e1 	mov	x1, x0
   81ef8:	aa0303e0 	mov	x0, x3
   81efc:	94000066 	bl	82094 <m_strcmp>
   81f00:	7100001f 	cmp	w0, #0x0
   81f04:	54000201 	b.ne	81f44 <shell_loop+0x1dc>  // b.any
                cmds[i].funct(argc, argv);
   81f08:	b0000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   81f0c:	91246002 	add	x2, x0, #0x918
   81f10:	b9821be1 	ldrsw	x1, [sp, #536]
   81f14:	aa0103e0 	mov	x0, x1
   81f18:	d37ff800 	lsl	x0, x0, #1
   81f1c:	8b010000 	add	x0, x0, x1
   81f20:	d37df000 	lsl	x0, x0, #3
   81f24:	8b000040 	add	x0, x2, x0
   81f28:	f9400802 	ldr	x2, [x0, #16]
   81f2c:	b9422be0 	ldr	w0, [sp, #552]
   81f30:	910443e1 	add	x1, sp, #0x110
   81f34:	d63f0040 	blr	x2
                valid = 1;
   81f38:	52800020 	mov	w0, #0x1                   	// #1
   81f3c:	b9021fe0 	str	w0, [sp, #540]
                break;
   81f40:	14000007 	b	81f5c <shell_loop+0x1f4>
        for(int i=0; i<sizeof(cmds)/sizeof(cmds[0]); ++i){
   81f44:	b9421be0 	ldr	w0, [sp, #536]
   81f48:	11000400 	add	w0, w0, #0x1
   81f4c:	b9021be0 	str	w0, [sp, #536]
   81f50:	b9421be0 	ldr	w0, [sp, #536]
   81f54:	7100301f 	cmp	w0, #0xc
   81f58:	54fffba9 	b.ls	81ecc <shell_loop+0x164>  // b.plast
            }
        }
        if(!valid)
   81f5c:	b9421fe0 	ldr	w0, [sp, #540]
   81f60:	7100001f 	cmp	w0, #0x0
   81f64:	54fff081 	b.ne	81d74 <shell_loop+0xc>  // b.any
            uart_printf("Unknown command: %s\n", argv[0]);
   81f68:	f9408be0 	ldr	x0, [sp, #272]
   81f6c:	aa0003e1 	mov	x1, x0
   81f70:	f0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   81f74:	9129e000 	add	x0, x0, #0xa78
   81f78:	9400039e 	bl	82df0 <uart_printf>
   81f7c:	17ffff7e 	b	81d74 <shell_loop+0xc>
            continue;
   81f80:	d503201f 	nop
    while (1) {	
   81f84:	17ffff7c 	b	81d74 <shell_loop+0xc>

0000000000081f88 <m_strtok>:
#include "m_string.h"

char* m_strtok(char *str, char delim, char **next){
   81f88:	d100c3ff 	sub	sp, sp, #0x30
   81f8c:	f9000fe0 	str	x0, [sp, #24]
   81f90:	39005fe1 	strb	w1, [sp, #23]
   81f94:	f90007e2 	str	x2, [sp, #8]
    if(*str == '\0')
   81f98:	f9400fe0 	ldr	x0, [sp, #24]
   81f9c:	39400000 	ldrb	w0, [x0]
   81fa0:	7100001f 	cmp	w0, #0x0
   81fa4:	540000c1 	b.ne	81fbc <m_strtok+0x34>  // b.any
        return str;
   81fa8:	f9400fe0 	ldr	x0, [sp, #24]
   81fac:	14000027 	b	82048 <m_strtok+0xc0>

    // find first non delim
    while(*str == delim) str++;
   81fb0:	f9400fe0 	ldr	x0, [sp, #24]
   81fb4:	91000400 	add	x0, x0, #0x1
   81fb8:	f9000fe0 	str	x0, [sp, #24]
   81fbc:	f9400fe0 	ldr	x0, [sp, #24]
   81fc0:	39400000 	ldrb	w0, [x0]
   81fc4:	39405fe1 	ldrb	w1, [sp, #23]
   81fc8:	6b00003f 	cmp	w1, w0
   81fcc:	54ffff20 	b.eq	81fb0 <m_strtok+0x28>  // b.none
    char *ret = str;
   81fd0:	f9400fe0 	ldr	x0, [sp, #24]
   81fd4:	f90017e0 	str	x0, [sp, #40]
    
    // find delim or '\0'
    while(*str != '\0' && *str != delim)
   81fd8:	14000004 	b	81fe8 <m_strtok+0x60>
        str++;
   81fdc:	f9400fe0 	ldr	x0, [sp, #24]
   81fe0:	91000400 	add	x0, x0, #0x1
   81fe4:	f9000fe0 	str	x0, [sp, #24]
    while(*str != '\0' && *str != delim)
   81fe8:	f9400fe0 	ldr	x0, [sp, #24]
   81fec:	39400000 	ldrb	w0, [x0]
   81ff0:	7100001f 	cmp	w0, #0x0
   81ff4:	540000c0 	b.eq	8200c <m_strtok+0x84>  // b.none
   81ff8:	f9400fe0 	ldr	x0, [sp, #24]
   81ffc:	39400000 	ldrb	w0, [x0]
   82000:	39405fe1 	ldrb	w1, [sp, #23]
   82004:	6b00003f 	cmp	w1, w0
   82008:	54fffea1 	b.ne	81fdc <m_strtok+0x54>  // b.any

    if(*str != '\0'){
   8200c:	f9400fe0 	ldr	x0, [sp, #24]
   82010:	39400000 	ldrb	w0, [x0]
   82014:	7100001f 	cmp	w0, #0x0
   82018:	54000100 	b.eq	82038 <m_strtok+0xb0>  // b.none
        *str = '\0';
   8201c:	f9400fe0 	ldr	x0, [sp, #24]
   82020:	3900001f 	strb	wzr, [x0]
        *next = str+1;
   82024:	f9400fe0 	ldr	x0, [sp, #24]
   82028:	91000401 	add	x1, x0, #0x1
   8202c:	f94007e0 	ldr	x0, [sp, #8]
   82030:	f9000001 	str	x1, [x0]
   82034:	14000004 	b	82044 <m_strtok+0xbc>
    }
    else {
        *next = str;
   82038:	f94007e0 	ldr	x0, [sp, #8]
   8203c:	f9400fe1 	ldr	x1, [sp, #24]
   82040:	f9000001 	str	x1, [x0]
    }
    
    return ret;
   82044:	f94017e0 	ldr	x0, [sp, #40]
}
   82048:	9100c3ff 	add	sp, sp, #0x30
   8204c:	d65f03c0 	ret

0000000000082050 <m_strlen>:

int m_strlen(const char *s){
   82050:	d10083ff 	sub	sp, sp, #0x20
   82054:	f90007e0 	str	x0, [sp, #8]
    const char *p = s;
   82058:	f94007e0 	ldr	x0, [sp, #8]
   8205c:	f9000fe0 	str	x0, [sp, #24]
    while(*p) ++p;
   82060:	14000004 	b	82070 <m_strlen+0x20>
   82064:	f9400fe0 	ldr	x0, [sp, #24]
   82068:	91000400 	add	x0, x0, #0x1
   8206c:	f9000fe0 	str	x0, [sp, #24]
   82070:	f9400fe0 	ldr	x0, [sp, #24]
   82074:	39400000 	ldrb	w0, [x0]
   82078:	7100001f 	cmp	w0, #0x0
   8207c:	54ffff41 	b.ne	82064 <m_strlen+0x14>  // b.any
    return p - s;
   82080:	f9400fe1 	ldr	x1, [sp, #24]
   82084:	f94007e0 	ldr	x0, [sp, #8]
   82088:	cb000020 	sub	x0, x1, x0
}
   8208c:	910083ff 	add	sp, sp, #0x20
   82090:	d65f03c0 	ret

0000000000082094 <m_strcmp>:


int m_strcmp(const char * cs, const char * ct) {
   82094:	f81e0ff3 	str	x19, [sp, #-32]!
   82098:	f9000fe0 	str	x0, [sp, #24]
   8209c:	f9000be1 	str	x1, [sp, #16]
	register signed char __res;
	while(1) {
		__res = *cs - *ct++;
   820a0:	f9400fe0 	ldr	x0, [sp, #24]
   820a4:	39400001 	ldrb	w1, [x0]
   820a8:	f9400be0 	ldr	x0, [sp, #16]
   820ac:	91000402 	add	x2, x0, #0x1
   820b0:	f9000be2 	str	x2, [sp, #16]
   820b4:	39400000 	ldrb	w0, [x0]
   820b8:	4b000020 	sub	w0, w1, w0
   820bc:	12001c00 	and	w0, w0, #0xff
   820c0:	13001c13 	sxtb	w19, w0
		if(__res != 0 || !*cs++)
   820c4:	7100027f 	cmp	w19, #0x0
   820c8:	54000101 	b.ne	820e8 <m_strcmp+0x54>  // b.any
   820cc:	f9400fe0 	ldr	x0, [sp, #24]
   820d0:	91000401 	add	x1, x0, #0x1
   820d4:	f9000fe1 	str	x1, [sp, #24]
   820d8:	39400000 	ldrb	w0, [x0]
   820dc:	7100001f 	cmp	w0, #0x0
   820e0:	54000040 	b.eq	820e8 <m_strcmp+0x54>  // b.none
		__res = *cs - *ct++;
   820e4:	17ffffef 	b	820a0 <m_strcmp+0xc>
			break;
	}
	return __res;
   820e8:	2a1303e0 	mov	w0, w19
}
   820ec:	f84207f3 	ldr	x19, [sp], #32
   820f0:	d65f03c0 	ret

00000000000820f4 <m_atoi>:

int m_atoi(const char *s){
   820f4:	d100c3ff 	sub	sp, sp, #0x30
   820f8:	f90007e0 	str	x0, [sp, #8]
    const char *p = s;
   820fc:	f94007e0 	ldr	x0, [sp, #8]
   82100:	f90017e0 	str	x0, [sp, #40]
    int num = 0;
   82104:	b90027ff 	str	wzr, [sp, #36]
    int sign = 0;
   82108:	b90023ff 	str	wzr, [sp, #32]
    while(*p != '\0'){
   8210c:	1400002c 	b	821bc <m_atoi+0xc8>
        if(*p == '+'){
   82110:	f94017e0 	ldr	x0, [sp, #40]
   82114:	39400000 	ldrb	w0, [x0]
   82118:	7100ac1f 	cmp	w0, #0x2b
   8211c:	540000e1 	b.ne	82138 <m_atoi+0x44>  // b.any
            if(sign != 0)
   82120:	b94023e0 	ldr	w0, [sp, #32]
   82124:	7100001f 	cmp	w0, #0x0
   82128:	54000541 	b.ne	821d0 <m_atoi+0xdc>  // b.any
                break;
            sign = -1;
   8212c:	12800000 	mov	w0, #0xffffffff            	// #-1
   82130:	b90023e0 	str	w0, [sp, #32]
   82134:	1400001f 	b	821b0 <m_atoi+0xbc>
        }
        else if(*p == '-'){
   82138:	f94017e0 	ldr	x0, [sp, #40]
   8213c:	39400000 	ldrb	w0, [x0]
   82140:	7100b41f 	cmp	w0, #0x2d
   82144:	540000e1 	b.ne	82160 <m_atoi+0x6c>  // b.any
            if(sign != 0)
   82148:	b94023e0 	ldr	w0, [sp, #32]
   8214c:	7100001f 	cmp	w0, #0x0
   82150:	54000441 	b.ne	821d8 <m_atoi+0xe4>  // b.any
                break;
            sign = 1;
   82154:	52800020 	mov	w0, #0x1                   	// #1
   82158:	b90023e0 	str	w0, [sp, #32]
   8215c:	14000015 	b	821b0 <m_atoi+0xbc>
        }
        else {
            int digit = *p - '0';
   82160:	f94017e0 	ldr	x0, [sp, #40]
   82164:	39400000 	ldrb	w0, [x0]
   82168:	5100c000 	sub	w0, w0, #0x30
   8216c:	b9001fe0 	str	w0, [sp, #28]
            if(!(digit >= 0 && digit <= 9))
   82170:	b9401fe0 	ldr	w0, [sp, #28]
   82174:	7100001f 	cmp	w0, #0x0
   82178:	5400032b 	b.lt	821dc <m_atoi+0xe8>  // b.tstop
   8217c:	b9401fe0 	ldr	w0, [sp, #28]
   82180:	7100241f 	cmp	w0, #0x9
   82184:	540002cc 	b.gt	821dc <m_atoi+0xe8>
                break;
            num *= 10;
   82188:	b94027e1 	ldr	w1, [sp, #36]
   8218c:	2a0103e0 	mov	w0, w1
   82190:	531e7400 	lsl	w0, w0, #2
   82194:	0b010000 	add	w0, w0, w1
   82198:	531f7800 	lsl	w0, w0, #1
   8219c:	b90027e0 	str	w0, [sp, #36]
            num += digit;
   821a0:	b94027e1 	ldr	w1, [sp, #36]
   821a4:	b9401fe0 	ldr	w0, [sp, #28]
   821a8:	0b000020 	add	w0, w1, w0
   821ac:	b90027e0 	str	w0, [sp, #36]
        }
        p++;
   821b0:	f94017e0 	ldr	x0, [sp, #40]
   821b4:	91000400 	add	x0, x0, #0x1
   821b8:	f90017e0 	str	x0, [sp, #40]
    while(*p != '\0'){
   821bc:	f94017e0 	ldr	x0, [sp, #40]
   821c0:	39400000 	ldrb	w0, [x0]
   821c4:	7100001f 	cmp	w0, #0x0
   821c8:	54fffa41 	b.ne	82110 <m_atoi+0x1c>  // b.any
   821cc:	14000004 	b	821dc <m_atoi+0xe8>
                break;
   821d0:	d503201f 	nop
   821d4:	14000002 	b	821dc <m_atoi+0xe8>
                break;
   821d8:	d503201f 	nop
    }
    return (sign == 0)? num: num * sign;
   821dc:	b94023e0 	ldr	w0, [sp, #32]
   821e0:	7100001f 	cmp	w0, #0x0
   821e4:	540000a0 	b.eq	821f8 <m_atoi+0x104>  // b.none
   821e8:	b94027e1 	ldr	w1, [sp, #36]
   821ec:	b94023e0 	ldr	w0, [sp, #32]
   821f0:	1b007c20 	mul	w0, w1, w0
   821f4:	14000002 	b	821fc <m_atoi+0x108>
   821f8:	b94027e0 	ldr	w0, [sp, #36]
}
   821fc:	9100c3ff 	add	sp, sp, #0x30
   82200:	d65f03c0 	ret

0000000000082204 <m_htoi>:

int m_htoi(const char *s){
   82204:	d10083ff 	sub	sp, sp, #0x20
   82208:	f90007e0 	str	x0, [sp, #8]
    int num = 0;
   8220c:	b9001fff 	str	wzr, [sp, #28]
    for(int i=0; s[i] != '\0'; ++i){
   82210:	b9001bff 	str	wzr, [sp, #24]
   82214:	14000045 	b	82328 <m_htoi+0x124>
        if('0' <= s[i] && s[i] <= '9')
   82218:	b9801be0 	ldrsw	x0, [sp, #24]
   8221c:	f94007e1 	ldr	x1, [sp, #8]
   82220:	8b000020 	add	x0, x1, x0
   82224:	39400000 	ldrb	w0, [x0]
   82228:	7100bc1f 	cmp	w0, #0x2f
   8222c:	54000229 	b.ls	82270 <m_htoi+0x6c>  // b.plast
   82230:	b9801be0 	ldrsw	x0, [sp, #24]
   82234:	f94007e1 	ldr	x1, [sp, #8]
   82238:	8b000020 	add	x0, x1, x0
   8223c:	39400000 	ldrb	w0, [x0]
   82240:	7100e41f 	cmp	w0, #0x39
   82244:	54000168 	b.hi	82270 <m_htoi+0x6c>  // b.pmore
            num = num << 4 | (s[i] - '0');
   82248:	b9401fe0 	ldr	w0, [sp, #28]
   8224c:	531c6c01 	lsl	w1, w0, #4
   82250:	b9801be0 	ldrsw	x0, [sp, #24]
   82254:	f94007e2 	ldr	x2, [sp, #8]
   82258:	8b000040 	add	x0, x2, x0
   8225c:	39400000 	ldrb	w0, [x0]
   82260:	5100c000 	sub	w0, w0, #0x30
   82264:	2a000020 	orr	w0, w1, w0
   82268:	b9001fe0 	str	w0, [sp, #28]
   8226c:	1400002c 	b	8231c <m_htoi+0x118>
        else if('a' <= s[i] && s[i] <= 'f')
   82270:	b9801be0 	ldrsw	x0, [sp, #24]
   82274:	f94007e1 	ldr	x1, [sp, #8]
   82278:	8b000020 	add	x0, x1, x0
   8227c:	39400000 	ldrb	w0, [x0]
   82280:	7101801f 	cmp	w0, #0x60
   82284:	54000229 	b.ls	822c8 <m_htoi+0xc4>  // b.plast
   82288:	b9801be0 	ldrsw	x0, [sp, #24]
   8228c:	f94007e1 	ldr	x1, [sp, #8]
   82290:	8b000020 	add	x0, x1, x0
   82294:	39400000 	ldrb	w0, [x0]
   82298:	7101981f 	cmp	w0, #0x66
   8229c:	54000168 	b.hi	822c8 <m_htoi+0xc4>  // b.pmore
            num = num << 4 | (s[i] - 'a' + 10);
   822a0:	b9401fe0 	ldr	w0, [sp, #28]
   822a4:	531c6c01 	lsl	w1, w0, #4
   822a8:	b9801be0 	ldrsw	x0, [sp, #24]
   822ac:	f94007e2 	ldr	x2, [sp, #8]
   822b0:	8b000040 	add	x0, x2, x0
   822b4:	39400000 	ldrb	w0, [x0]
   822b8:	51015c00 	sub	w0, w0, #0x57
   822bc:	2a000020 	orr	w0, w1, w0
   822c0:	b9001fe0 	str	w0, [sp, #28]
   822c4:	14000016 	b	8231c <m_htoi+0x118>
        else if('A' <= s[i] && s[i] <= 'F')
   822c8:	b9801be0 	ldrsw	x0, [sp, #24]
   822cc:	f94007e1 	ldr	x1, [sp, #8]
   822d0:	8b000020 	add	x0, x1, x0
   822d4:	39400000 	ldrb	w0, [x0]
   822d8:	7101001f 	cmp	w0, #0x40
   822dc:	54000209 	b.ls	8231c <m_htoi+0x118>  // b.plast
   822e0:	b9801be0 	ldrsw	x0, [sp, #24]
   822e4:	f94007e1 	ldr	x1, [sp, #8]
   822e8:	8b000020 	add	x0, x1, x0
   822ec:	39400000 	ldrb	w0, [x0]
   822f0:	7101181f 	cmp	w0, #0x46
   822f4:	54000148 	b.hi	8231c <m_htoi+0x118>  // b.pmore
            num = num << 4 | (s[i] - 'A' + 10);
   822f8:	b9401fe0 	ldr	w0, [sp, #28]
   822fc:	531c6c01 	lsl	w1, w0, #4
   82300:	b9801be0 	ldrsw	x0, [sp, #24]
   82304:	f94007e2 	ldr	x2, [sp, #8]
   82308:	8b000040 	add	x0, x2, x0
   8230c:	39400000 	ldrb	w0, [x0]
   82310:	5100dc00 	sub	w0, w0, #0x37
   82314:	2a000020 	orr	w0, w1, w0
   82318:	b9001fe0 	str	w0, [sp, #28]
    for(int i=0; s[i] != '\0'; ++i){
   8231c:	b9401be0 	ldr	w0, [sp, #24]
   82320:	11000400 	add	w0, w0, #0x1
   82324:	b9001be0 	str	w0, [sp, #24]
   82328:	b9801be0 	ldrsw	x0, [sp, #24]
   8232c:	f94007e1 	ldr	x1, [sp, #8]
   82330:	8b000020 	add	x0, x1, x0
   82334:	39400000 	ldrb	w0, [x0]
   82338:	7100001f 	cmp	w0, #0x0
   8233c:	54fff6e1 	b.ne	82218 <m_htoi+0x14>  // b.any
    }
    return num;
   82340:	b9401fe0 	ldr	w0, [sp, #28]
}
   82344:	910083ff 	add	sp, sp, #0x20
   82348:	d65f03c0 	ret

000000000008234c <m_itoa>:
char* m_itoa(int value, char *s){
   8234c:	d100c3ff 	sub	sp, sp, #0x30
   82350:	b9000fe0 	str	w0, [sp, #12]
   82354:	f90003e1 	str	x1, [sp]
    int idx = 0;
   82358:	b9002fff 	str	wzr, [sp, #44]
    if(value < 0) {
   8235c:	b9400fe0 	ldr	w0, [sp, #12]
   82360:	7100001f 	cmp	w0, #0x0
   82364:	5400018a 	b.ge	82394 <m_itoa+0x48>  // b.tcont
        value *= -1;
   82368:	b9400fe0 	ldr	w0, [sp, #12]
   8236c:	4b0003e0 	neg	w0, w0
   82370:	b9000fe0 	str	w0, [sp, #12]
        s[idx++] = '-';
   82374:	b9402fe0 	ldr	w0, [sp, #44]
   82378:	11000401 	add	w1, w0, #0x1
   8237c:	b9002fe1 	str	w1, [sp, #44]
   82380:	93407c00 	sxtw	x0, w0
   82384:	f94003e1 	ldr	x1, [sp]
   82388:	8b000020 	add	x0, x1, x0
   8238c:	528005a1 	mov	w1, #0x2d                  	// #45
   82390:	39000001 	strb	w1, [x0]
    }

    char tmp[10];
    int tidx = 0;
   82394:	b9002bff 	str	wzr, [sp, #40]
    // read from least significant digit
    do {
        tmp[tidx++] = '0' + value % 10;
   82398:	b9400fe1 	ldr	w1, [sp, #12]
   8239c:	528ccce0 	mov	w0, #0x6667                	// #26215
   823a0:	72acccc0 	movk	w0, #0x6666, lsl #16
   823a4:	9b207c20 	smull	x0, w1, w0
   823a8:	d360fc00 	lsr	x0, x0, #32
   823ac:	13027c02 	asr	w2, w0, #2
   823b0:	131f7c20 	asr	w0, w1, #31
   823b4:	4b000042 	sub	w2, w2, w0
   823b8:	2a0203e0 	mov	w0, w2
   823bc:	531e7400 	lsl	w0, w0, #2
   823c0:	0b020000 	add	w0, w0, w2
   823c4:	531f7800 	lsl	w0, w0, #1
   823c8:	4b000022 	sub	w2, w1, w0
   823cc:	12001c41 	and	w1, w2, #0xff
   823d0:	b9402be0 	ldr	w0, [sp, #40]
   823d4:	11000402 	add	w2, w0, #0x1
   823d8:	b9002be2 	str	w2, [sp, #40]
   823dc:	1100c021 	add	w1, w1, #0x30
   823e0:	12001c22 	and	w2, w1, #0xff
   823e4:	93407c00 	sxtw	x0, w0
   823e8:	910063e1 	add	x1, sp, #0x18
   823ec:	38206822 	strb	w2, [x1, x0]
        value /= 10;
   823f0:	b9400fe0 	ldr	w0, [sp, #12]
   823f4:	528ccce1 	mov	w1, #0x6667                	// #26215
   823f8:	72acccc1 	movk	w1, #0x6666, lsl #16
   823fc:	9b217c01 	smull	x1, w0, w1
   82400:	d360fc21 	lsr	x1, x1, #32
   82404:	13027c21 	asr	w1, w1, #2
   82408:	131f7c00 	asr	w0, w0, #31
   8240c:	4b000020 	sub	w0, w1, w0
   82410:	b9000fe0 	str	w0, [sp, #12]
    } while(value != 0 && tidx < 11);
   82414:	b9400fe0 	ldr	w0, [sp, #12]
   82418:	7100001f 	cmp	w0, #0x0
   8241c:	54000080 	b.eq	8242c <m_itoa+0xe0>  // b.none
   82420:	b9402be0 	ldr	w0, [sp, #40]
   82424:	7100281f 	cmp	w0, #0xa
   82428:	54fffb8d 	b.le	82398 <m_itoa+0x4c>

    // reverse 
    for(int i = tidx-1; i>=0; i--)
   8242c:	b9402be0 	ldr	w0, [sp, #40]
   82430:	51000400 	sub	w0, w0, #0x1
   82434:	b90027e0 	str	w0, [sp, #36]
   82438:	1400000e 	b	82470 <m_itoa+0x124>
        s[idx++] = tmp[i];
   8243c:	b9402fe0 	ldr	w0, [sp, #44]
   82440:	11000401 	add	w1, w0, #0x1
   82444:	b9002fe1 	str	w1, [sp, #44]
   82448:	93407c00 	sxtw	x0, w0
   8244c:	f94003e1 	ldr	x1, [sp]
   82450:	8b000020 	add	x0, x1, x0
   82454:	b98027e1 	ldrsw	x1, [sp, #36]
   82458:	910063e2 	add	x2, sp, #0x18
   8245c:	38616841 	ldrb	w1, [x2, x1]
   82460:	39000001 	strb	w1, [x0]
    for(int i = tidx-1; i>=0; i--)
   82464:	b94027e0 	ldr	w0, [sp, #36]
   82468:	51000400 	sub	w0, w0, #0x1
   8246c:	b90027e0 	str	w0, [sp, #36]
   82470:	b94027e0 	ldr	w0, [sp, #36]
   82474:	7100001f 	cmp	w0, #0x0
   82478:	54fffe2a 	b.ge	8243c <m_itoa+0xf0>  // b.tcont

    s[idx] = '\0';
   8247c:	b9802fe0 	ldrsw	x0, [sp, #44]
   82480:	f94003e1 	ldr	x1, [sp]
   82484:	8b000020 	add	x0, x1, x0
   82488:	3900001f 	strb	wzr, [x0]
    return s;
   8248c:	f94003e0 	ldr	x0, [sp]
}
   82490:	9100c3ff 	add	sp, sp, #0x30
   82494:	d65f03c0 	ret

0000000000082498 <m_vsprintf>:


unsigned int m_vsprintf(char *dst, char *fmt, __builtin_va_list args) {
   82498:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
   8249c:	910003fd 	mov	x29, sp
   824a0:	f9000bf3 	str	x19, [sp, #16]
   824a4:	f90017e0 	str	x0, [sp, #40]
   824a8:	f90013e1 	str	x1, [sp, #32]
   824ac:	aa0203f3 	mov	x19, x2
    char *dst_orig = dst;
   824b0:	f94017e0 	ldr	x0, [sp, #40]
   824b4:	f90037e0 	str	x0, [sp, #104]

    while (*fmt) {
   824b8:	14000139 	b	8299c <m_vsprintf+0x504>
        if (*fmt == '%') {
   824bc:	f94013e0 	ldr	x0, [sp, #32]
   824c0:	39400000 	ldrb	w0, [x0]
   824c4:	7100941f 	cmp	w0, #0x25
   824c8:	54002521 	b.ne	8296c <m_vsprintf+0x4d4>  // b.any
            fmt++;
   824cc:	f94013e0 	ldr	x0, [sp, #32]
   824d0:	91000400 	add	x0, x0, #0x1
   824d4:	f90013e0 	str	x0, [sp, #32]
            // escape %
            if (*fmt == '%') {
   824d8:	f94013e0 	ldr	x0, [sp, #32]
   824dc:	39400000 	ldrb	w0, [x0]
   824e0:	7100941f 	cmp	w0, #0x25
   824e4:	54002480 	b.eq	82974 <m_vsprintf+0x4dc>  // b.none
                goto put;
            }
            // string
            else if (*fmt == 's') {
   824e8:	f94013e0 	ldr	x0, [sp, #32]
   824ec:	39400000 	ldrb	w0, [x0]
   824f0:	7101cc1f 	cmp	w0, #0x73
   824f4:	540004a1 	b.ne	82588 <m_vsprintf+0xf0>  // b.any
                char *p = __builtin_va_arg(args, char *);
   824f8:	b9401a61 	ldr	w1, [x19, #24]
   824fc:	f9400260 	ldr	x0, [x19]
   82500:	7100003f 	cmp	w1, #0x0
   82504:	540000ab 	b.lt	82518 <m_vsprintf+0x80>  // b.tstop
   82508:	91003c01 	add	x1, x0, #0xf
   8250c:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82510:	f9000261 	str	x1, [x19]
   82514:	1400000d 	b	82548 <m_vsprintf+0xb0>
   82518:	11002022 	add	w2, w1, #0x8
   8251c:	b9001a62 	str	w2, [x19, #24]
   82520:	b9401a62 	ldr	w2, [x19, #24]
   82524:	7100005f 	cmp	w2, #0x0
   82528:	540000ad 	b.le	8253c <m_vsprintf+0xa4>
   8252c:	91003c01 	add	x1, x0, #0xf
   82530:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82534:	f9000261 	str	x1, [x19]
   82538:	14000004 	b	82548 <m_vsprintf+0xb0>
   8253c:	f9400662 	ldr	x2, [x19, #8]
   82540:	93407c20 	sxtw	x0, w1
   82544:	8b000040 	add	x0, x2, x0
   82548:	f9400000 	ldr	x0, [x0]
   8254c:	f90047e0 	str	x0, [sp, #136]
                while (*p) {
   82550:	14000009 	b	82574 <m_vsprintf+0xdc>
                    *dst++ = *p++;
   82554:	f94047e1 	ldr	x1, [sp, #136]
   82558:	91000420 	add	x0, x1, #0x1
   8255c:	f90047e0 	str	x0, [sp, #136]
   82560:	f94017e0 	ldr	x0, [sp, #40]
   82564:	91000402 	add	x2, x0, #0x1
   82568:	f90017e2 	str	x2, [sp, #40]
   8256c:	39400021 	ldrb	w1, [x1]
   82570:	39000001 	strb	w1, [x0]
                while (*p) {
   82574:	f94047e0 	ldr	x0, [sp, #136]
   82578:	39400000 	ldrb	w0, [x0]
   8257c:	7100001f 	cmp	w0, #0x0
   82580:	54fffea1 	b.ne	82554 <m_vsprintf+0xbc>  // b.any
   82584:	14000103 	b	82990 <m_vsprintf+0x4f8>
                }
            }
            // number
            else if (*fmt == 'd') {
   82588:	f94013e0 	ldr	x0, [sp, #32]
   8258c:	39400000 	ldrb	w0, [x0]
   82590:	7101901f 	cmp	w0, #0x64
   82594:	54000541 	b.ne	8263c <m_vsprintf+0x1a4>  // b.any
                int arg = __builtin_va_arg(args, int);
   82598:	b9401a61 	ldr	w1, [x19, #24]
   8259c:	f9400260 	ldr	x0, [x19]
   825a0:	7100003f 	cmp	w1, #0x0
   825a4:	540000ab 	b.lt	825b8 <m_vsprintf+0x120>  // b.tstop
   825a8:	91002c01 	add	x1, x0, #0xb
   825ac:	927df021 	and	x1, x1, #0xfffffffffffffff8
   825b0:	f9000261 	str	x1, [x19]
   825b4:	1400000d 	b	825e8 <m_vsprintf+0x150>
   825b8:	11002022 	add	w2, w1, #0x8
   825bc:	b9001a62 	str	w2, [x19, #24]
   825c0:	b9401a62 	ldr	w2, [x19, #24]
   825c4:	7100005f 	cmp	w2, #0x0
   825c8:	540000ad 	b.le	825dc <m_vsprintf+0x144>
   825cc:	91002c01 	add	x1, x0, #0xb
   825d0:	927df021 	and	x1, x1, #0xfffffffffffffff8
   825d4:	f9000261 	str	x1, [x19]
   825d8:	14000004 	b	825e8 <m_vsprintf+0x150>
   825dc:	f9400662 	ldr	x2, [x19, #8]
   825e0:	93407c20 	sxtw	x0, w1
   825e4:	8b000040 	add	x0, x2, x0
   825e8:	b9400000 	ldr	w0, [x0]
   825ec:	b90043e0 	str	w0, [sp, #64]
                char buf[11];
                char *p = m_itoa(arg, buf);
   825f0:	9100c3e0 	add	x0, sp, #0x30
   825f4:	aa0003e1 	mov	x1, x0
   825f8:	b94043e0 	ldr	w0, [sp, #64]
   825fc:	97ffff54 	bl	8234c <m_itoa>
   82600:	f90043e0 	str	x0, [sp, #128]
                while (*p) {
   82604:	14000009 	b	82628 <m_vsprintf+0x190>
                    *dst++ = *p++;
   82608:	f94043e1 	ldr	x1, [sp, #128]
   8260c:	91000420 	add	x0, x1, #0x1
   82610:	f90043e0 	str	x0, [sp, #128]
   82614:	f94017e0 	ldr	x0, [sp, #40]
   82618:	91000402 	add	x2, x0, #0x1
   8261c:	f90017e2 	str	x2, [sp, #40]
   82620:	39400021 	ldrb	w1, [x1]
   82624:	39000001 	strb	w1, [x0]
                while (*p) {
   82628:	f94043e0 	ldr	x0, [sp, #128]
   8262c:	39400000 	ldrb	w0, [x0]
   82630:	7100001f 	cmp	w0, #0x0
   82634:	54fffea1 	b.ne	82608 <m_vsprintf+0x170>  // b.any
   82638:	140000d6 	b	82990 <m_vsprintf+0x4f8>
                }
            }
            else if (*fmt == 'l'){
   8263c:	f94013e0 	ldr	x0, [sp, #32]
   82640:	39400000 	ldrb	w0, [x0]
   82644:	7101b01f 	cmp	w0, #0x6c
   82648:	540006c1 	b.ne	82720 <m_vsprintf+0x288>  // b.any
                unsigned long long arg = __builtin_va_arg(args, unsigned long long);
   8264c:	b9401a61 	ldr	w1, [x19, #24]
   82650:	f9400260 	ldr	x0, [x19]
   82654:	7100003f 	cmp	w1, #0x0
   82658:	540000ab 	b.lt	8266c <m_vsprintf+0x1d4>  // b.tstop
   8265c:	91003c01 	add	x1, x0, #0xf
   82660:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82664:	f9000261 	str	x1, [x19]
   82668:	1400000d 	b	8269c <m_vsprintf+0x204>
   8266c:	11002022 	add	w2, w1, #0x8
   82670:	b9001a62 	str	w2, [x19, #24]
   82674:	b9401a62 	ldr	w2, [x19, #24]
   82678:	7100005f 	cmp	w2, #0x0
   8267c:	540000ad 	b.le	82690 <m_vsprintf+0x1f8>
   82680:	91003c01 	add	x1, x0, #0xf
   82684:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82688:	f9000261 	str	x1, [x19]
   8268c:	14000004 	b	8269c <m_vsprintf+0x204>
   82690:	f9400662 	ldr	x2, [x19, #8]
   82694:	93407c20 	sxtw	x0, w1
   82698:	8b000040 	add	x0, x2, x0
   8269c:	f9400000 	ldr	x0, [x0]
   826a0:	f90027e0 	str	x0, [sp, #72]
                for(int i=60; i>=0; i-=4){
   826a4:	52800780 	mov	w0, #0x3c                  	// #60
   826a8:	b9007fe0 	str	w0, [sp, #124]
   826ac:	14000019 	b	82710 <m_vsprintf+0x278>
                    int hex = (arg >> i) & 0xF;
   826b0:	b9407fe0 	ldr	w0, [sp, #124]
   826b4:	f94027e1 	ldr	x1, [sp, #72]
   826b8:	9ac02420 	lsr	x0, x1, x0
   826bc:	12000c00 	and	w0, w0, #0xf
   826c0:	b90047e0 	str	w0, [sp, #68]
                    *dst++ = (hex > 9)? 'A' - 10 + hex: '0' + hex;
   826c4:	b94047e0 	ldr	w0, [sp, #68]
   826c8:	7100241f 	cmp	w0, #0x9
   826cc:	540000cd 	b.le	826e4 <m_vsprintf+0x24c>
   826d0:	b94047e0 	ldr	w0, [sp, #68]
   826d4:	12001c00 	and	w0, w0, #0xff
   826d8:	1100dc00 	add	w0, w0, #0x37
   826dc:	12001c01 	and	w1, w0, #0xff
   826e0:	14000005 	b	826f4 <m_vsprintf+0x25c>
   826e4:	b94047e0 	ldr	w0, [sp, #68]
   826e8:	12001c00 	and	w0, w0, #0xff
   826ec:	1100c000 	add	w0, w0, #0x30
   826f0:	12001c01 	and	w1, w0, #0xff
   826f4:	f94017e0 	ldr	x0, [sp, #40]
   826f8:	91000402 	add	x2, x0, #0x1
   826fc:	f90017e2 	str	x2, [sp, #40]
   82700:	39000001 	strb	w1, [x0]
                for(int i=60; i>=0; i-=4){
   82704:	b9407fe0 	ldr	w0, [sp, #124]
   82708:	51001000 	sub	w0, w0, #0x4
   8270c:	b9007fe0 	str	w0, [sp, #124]
   82710:	b9407fe0 	ldr	w0, [sp, #124]
   82714:	7100001f 	cmp	w0, #0x0
   82718:	54fffcca 	b.ge	826b0 <m_vsprintf+0x218>  // b.tcont
   8271c:	1400009d 	b	82990 <m_vsprintf+0x4f8>
                }
            }
            else if (*fmt == 'x'){
   82720:	f94013e0 	ldr	x0, [sp, #32]
   82724:	39400000 	ldrb	w0, [x0]
   82728:	7101e01f 	cmp	w0, #0x78
   8272c:	540006c1 	b.ne	82804 <m_vsprintf+0x36c>  // b.any
                unsigned int arg = __builtin_va_arg(args, unsigned int);
   82730:	b9401a61 	ldr	w1, [x19, #24]
   82734:	f9400260 	ldr	x0, [x19]
   82738:	7100003f 	cmp	w1, #0x0
   8273c:	540000ab 	b.lt	82750 <m_vsprintf+0x2b8>  // b.tstop
   82740:	91002c01 	add	x1, x0, #0xb
   82744:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82748:	f9000261 	str	x1, [x19]
   8274c:	1400000d 	b	82780 <m_vsprintf+0x2e8>
   82750:	11002022 	add	w2, w1, #0x8
   82754:	b9001a62 	str	w2, [x19, #24]
   82758:	b9401a62 	ldr	w2, [x19, #24]
   8275c:	7100005f 	cmp	w2, #0x0
   82760:	540000ad 	b.le	82774 <m_vsprintf+0x2dc>
   82764:	91002c01 	add	x1, x0, #0xb
   82768:	927df021 	and	x1, x1, #0xfffffffffffffff8
   8276c:	f9000261 	str	x1, [x19]
   82770:	14000004 	b	82780 <m_vsprintf+0x2e8>
   82774:	f9400662 	ldr	x2, [x19, #8]
   82778:	93407c20 	sxtw	x0, w1
   8277c:	8b000040 	add	x0, x2, x0
   82780:	b9400000 	ldr	w0, [x0]
   82784:	b9005be0 	str	w0, [sp, #88]
                for(int i=28; i>=0; i-=4){
   82788:	52800380 	mov	w0, #0x1c                  	// #28
   8278c:	b9007be0 	str	w0, [sp, #120]
   82790:	14000019 	b	827f4 <m_vsprintf+0x35c>
                    int hex = (arg >> i) & 0xF;
   82794:	b9407be0 	ldr	w0, [sp, #120]
   82798:	b9405be1 	ldr	w1, [sp, #88]
   8279c:	1ac02420 	lsr	w0, w1, w0
   827a0:	12000c00 	and	w0, w0, #0xf
   827a4:	b90057e0 	str	w0, [sp, #84]
                    *dst++ = (hex > 9)? 'A' - 10 + hex: '0' + hex;
   827a8:	b94057e0 	ldr	w0, [sp, #84]
   827ac:	7100241f 	cmp	w0, #0x9
   827b0:	540000cd 	b.le	827c8 <m_vsprintf+0x330>
   827b4:	b94057e0 	ldr	w0, [sp, #84]
   827b8:	12001c00 	and	w0, w0, #0xff
   827bc:	1100dc00 	add	w0, w0, #0x37
   827c0:	12001c01 	and	w1, w0, #0xff
   827c4:	14000005 	b	827d8 <m_vsprintf+0x340>
   827c8:	b94057e0 	ldr	w0, [sp, #84]
   827cc:	12001c00 	and	w0, w0, #0xff
   827d0:	1100c000 	add	w0, w0, #0x30
   827d4:	12001c01 	and	w1, w0, #0xff
   827d8:	f94017e0 	ldr	x0, [sp, #40]
   827dc:	91000402 	add	x2, x0, #0x1
   827e0:	f90017e2 	str	x2, [sp, #40]
   827e4:	39000001 	strb	w1, [x0]
                for(int i=28; i>=0; i-=4){
   827e8:	b9407be0 	ldr	w0, [sp, #120]
   827ec:	51001000 	sub	w0, w0, #0x4
   827f0:	b9007be0 	str	w0, [sp, #120]
   827f4:	b9407be0 	ldr	w0, [sp, #120]
   827f8:	7100001f 	cmp	w0, #0x0
   827fc:	54fffcca 	b.ge	82794 <m_vsprintf+0x2fc>  // b.tcont
   82800:	14000064 	b	82990 <m_vsprintf+0x4f8>
                }
            }
            else if (*fmt == 'c'){
   82804:	f94013e0 	ldr	x0, [sp, #32]
   82808:	39400000 	ldrb	w0, [x0]
   8280c:	71018c1f 	cmp	w0, #0x63
   82810:	540003c1 	b.ne	82888 <m_vsprintf+0x3f0>  // b.any
                int arg = __builtin_va_arg(args, int);
   82814:	b9401a61 	ldr	w1, [x19, #24]
   82818:	f9400260 	ldr	x0, [x19]
   8281c:	7100003f 	cmp	w1, #0x0
   82820:	540000ab 	b.lt	82834 <m_vsprintf+0x39c>  // b.tstop
   82824:	91002c01 	add	x1, x0, #0xb
   82828:	927df021 	and	x1, x1, #0xfffffffffffffff8
   8282c:	f9000261 	str	x1, [x19]
   82830:	1400000d 	b	82864 <m_vsprintf+0x3cc>
   82834:	11002022 	add	w2, w1, #0x8
   82838:	b9001a62 	str	w2, [x19, #24]
   8283c:	b9401a62 	ldr	w2, [x19, #24]
   82840:	7100005f 	cmp	w2, #0x0
   82844:	540000ad 	b.le	82858 <m_vsprintf+0x3c0>
   82848:	91002c01 	add	x1, x0, #0xb
   8284c:	927df021 	and	x1, x1, #0xfffffffffffffff8
   82850:	f9000261 	str	x1, [x19]
   82854:	14000004 	b	82864 <m_vsprintf+0x3cc>
   82858:	f9400662 	ldr	x2, [x19, #8]
   8285c:	93407c20 	sxtw	x0, w1
   82860:	8b000040 	add	x0, x2, x0
   82864:	b9400000 	ldr	w0, [x0]
   82868:	b9005fe0 	str	w0, [sp, #92]
                *dst++ = (char)arg;
   8286c:	f94017e0 	ldr	x0, [sp, #40]
   82870:	91000401 	add	x1, x0, #0x1
   82874:	f90017e1 	str	x1, [sp, #40]
   82878:	b9405fe1 	ldr	w1, [sp, #92]
   8287c:	12001c21 	and	w1, w1, #0xff
   82880:	39000001 	strb	w1, [x0]
   82884:	14000043 	b	82990 <m_vsprintf+0x4f8>
            }
            else if (*fmt == 'b'){
   82888:	f94013e0 	ldr	x0, [sp, #32]
   8288c:	39400000 	ldrb	w0, [x0]
   82890:	7101881f 	cmp	w0, #0x62
   82894:	540007e1 	b.ne	82990 <m_vsprintf+0x4f8>  // b.any
                unsigned char arg = __builtin_va_arg(args, int);
   82898:	b9401a61 	ldr	w1, [x19, #24]
   8289c:	f9400260 	ldr	x0, [x19]
   828a0:	7100003f 	cmp	w1, #0x0
   828a4:	540000ab 	b.lt	828b8 <m_vsprintf+0x420>  // b.tstop
   828a8:	91002c01 	add	x1, x0, #0xb
   828ac:	927df021 	and	x1, x1, #0xfffffffffffffff8
   828b0:	f9000261 	str	x1, [x19]
   828b4:	1400000d 	b	828e8 <m_vsprintf+0x450>
   828b8:	11002022 	add	w2, w1, #0x8
   828bc:	b9001a62 	str	w2, [x19, #24]
   828c0:	b9401a62 	ldr	w2, [x19, #24]
   828c4:	7100005f 	cmp	w2, #0x0
   828c8:	540000ad 	b.le	828dc <m_vsprintf+0x444>
   828cc:	91002c01 	add	x1, x0, #0xb
   828d0:	927df021 	and	x1, x1, #0xfffffffffffffff8
   828d4:	f9000261 	str	x1, [x19]
   828d8:	14000004 	b	828e8 <m_vsprintf+0x450>
   828dc:	f9400662 	ldr	x2, [x19, #8]
   828e0:	93407c20 	sxtw	x0, w1
   828e4:	8b000040 	add	x0, x2, x0
   828e8:	b9400000 	ldr	w0, [x0]
   828ec:	39019fe0 	strb	w0, [sp, #103]
                for(int i=4; i>=0; i-=4){
   828f0:	52800080 	mov	w0, #0x4                   	// #4
   828f4:	b90077e0 	str	w0, [sp, #116]
   828f8:	14000019 	b	8295c <m_vsprintf+0x4c4>
                    int hex = (arg >> i) & 0xf;
   828fc:	39419fe1 	ldrb	w1, [sp, #103]
   82900:	b94077e0 	ldr	w0, [sp, #116]
   82904:	1ac02820 	asr	w0, w1, w0
   82908:	12000c00 	and	w0, w0, #0xf
   8290c:	b90063e0 	str	w0, [sp, #96]
                    *dst++ = (hex > 9)? 'A' - 10 + hex: '0' + hex;
   82910:	b94063e0 	ldr	w0, [sp, #96]
   82914:	7100241f 	cmp	w0, #0x9
   82918:	540000cd 	b.le	82930 <m_vsprintf+0x498>
   8291c:	b94063e0 	ldr	w0, [sp, #96]
   82920:	12001c00 	and	w0, w0, #0xff
   82924:	1100dc00 	add	w0, w0, #0x37
   82928:	12001c01 	and	w1, w0, #0xff
   8292c:	14000005 	b	82940 <m_vsprintf+0x4a8>
   82930:	b94063e0 	ldr	w0, [sp, #96]
   82934:	12001c00 	and	w0, w0, #0xff
   82938:	1100c000 	add	w0, w0, #0x30
   8293c:	12001c01 	and	w1, w0, #0xff
   82940:	f94017e0 	ldr	x0, [sp, #40]
   82944:	91000402 	add	x2, x0, #0x1
   82948:	f90017e2 	str	x2, [sp, #40]
   8294c:	39000001 	strb	w1, [x0]
                for(int i=4; i>=0; i-=4){
   82950:	b94077e0 	ldr	w0, [sp, #116]
   82954:	51001000 	sub	w0, w0, #0x4
   82958:	b90077e0 	str	w0, [sp, #116]
   8295c:	b94077e0 	ldr	w0, [sp, #116]
   82960:	7100001f 	cmp	w0, #0x0
   82964:	54fffcca 	b.ge	828fc <m_vsprintf+0x464>  // b.tcont
   82968:	1400000a 	b	82990 <m_vsprintf+0x4f8>
                }
            }
        } else {
        put:
   8296c:	d503201f 	nop
   82970:	14000002 	b	82978 <m_vsprintf+0x4e0>
                goto put;
   82974:	d503201f 	nop
            *dst++ = *fmt;
   82978:	f94017e0 	ldr	x0, [sp, #40]
   8297c:	91000401 	add	x1, x0, #0x1
   82980:	f90017e1 	str	x1, [sp, #40]
   82984:	f94013e1 	ldr	x1, [sp, #32]
   82988:	39400021 	ldrb	w1, [x1]
   8298c:	39000001 	strb	w1, [x0]
        }
        fmt++;
   82990:	f94013e0 	ldr	x0, [sp, #32]
   82994:	91000400 	add	x0, x0, #0x1
   82998:	f90013e0 	str	x0, [sp, #32]
    while (*fmt) {
   8299c:	f94013e0 	ldr	x0, [sp, #32]
   829a0:	39400000 	ldrb	w0, [x0]
   829a4:	7100001f 	cmp	w0, #0x0
   829a8:	54ffd8a1 	b.ne	824bc <m_vsprintf+0x24>  // b.any
    }
    *dst = '\0';
   829ac:	f94017e0 	ldr	x0, [sp, #40]
   829b0:	3900001f 	strb	wzr, [x0]
    
    return dst - dst_orig;  // return written bytes
   829b4:	f94017e1 	ldr	x1, [sp, #40]
   829b8:	f94037e0 	ldr	x0, [sp, #104]
   829bc:	cb000020 	sub	x0, x1, x0
}
   829c0:	f9400bf3 	ldr	x19, [sp, #16]
   829c4:	a8c97bfd 	ldp	x29, x30, [sp], #144
   829c8:	d65f03c0 	ret

00000000000829cc <m_sprintf>:

unsigned int m_sprintf(char *dst, char *fmt, ...) {
   829cc:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
   829d0:	910003fd 	mov	x29, sp
   829d4:	f9001fe0 	str	x0, [sp, #56]
   829d8:	f9001be1 	str	x1, [sp, #48]
   829dc:	f90073e2 	str	x2, [sp, #224]
   829e0:	f90077e3 	str	x3, [sp, #232]
   829e4:	f9007be4 	str	x4, [sp, #240]
   829e8:	f9007fe5 	str	x5, [sp, #248]
   829ec:	f90083e6 	str	x6, [sp, #256]
   829f0:	f90087e7 	str	x7, [sp, #264]
   829f4:	3d801be0 	str	q0, [sp, #96]
   829f8:	3d801fe1 	str	q1, [sp, #112]
   829fc:	3d8023e2 	str	q2, [sp, #128]
   82a00:	3d8027e3 	str	q3, [sp, #144]
   82a04:	3d802be4 	str	q4, [sp, #160]
   82a08:	3d802fe5 	str	q5, [sp, #176]
   82a0c:	3d8033e6 	str	q6, [sp, #192]
   82a10:	3d8037e7 	str	q7, [sp, #208]
    __builtin_va_list args;
    __builtin_va_start(args, fmt);
   82a14:	910443e0 	add	x0, sp, #0x110
   82a18:	f90023e0 	str	x0, [sp, #64]
   82a1c:	910443e0 	add	x0, sp, #0x110
   82a20:	f90027e0 	str	x0, [sp, #72]
   82a24:	910383e0 	add	x0, sp, #0xe0
   82a28:	f9002be0 	str	x0, [sp, #80]
   82a2c:	128005e0 	mov	w0, #0xffffffd0            	// #-48
   82a30:	b9005be0 	str	w0, [sp, #88]
   82a34:	12800fe0 	mov	w0, #0xffffff80            	// #-128
   82a38:	b9005fe0 	str	w0, [sp, #92]
    return m_vsprintf(dst, fmt, args);
   82a3c:	910043e2 	add	x2, sp, #0x10
   82a40:	910103e3 	add	x3, sp, #0x40
   82a44:	a9400460 	ldp	x0, x1, [x3]
   82a48:	a9000440 	stp	x0, x1, [x2]
   82a4c:	a9410460 	ldp	x0, x1, [x3, #16]
   82a50:	a9010440 	stp	x0, x1, [x2, #16]
   82a54:	910043e0 	add	x0, sp, #0x10
   82a58:	aa0003e2 	mov	x2, x0
   82a5c:	f9401be1 	ldr	x1, [sp, #48]
   82a60:	f9401fe0 	ldr	x0, [sp, #56]
   82a64:	97fffe8d 	bl	82498 <m_vsprintf>
}
   82a68:	a8d17bfd 	ldp	x29, x30, [sp], #272
   82a6c:	d65f03c0 	ret

0000000000082a70 <uart_send>:
#include "m_string.h"
#include "mini_uart.h"
#include "timer.h"


void uart_send(char c) {
   82a70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   82a74:	910003fd 	mov	x29, sp
   82a78:	39007fe0 	strb	w0, [sp, #31]
    
    while (1) {
        asm volatile("nop");
   82a7c:	d503201f 	nop
        if (get32(AUX_MU_LSR_REG) & 0x20)
   82a80:	d28a0a80 	mov	x0, #0x5054                	// #20564
   82a84:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82a88:	94000dce 	bl	861c0 <get32>
   82a8c:	121b0000 	and	w0, w0, #0x20
   82a90:	7100001f 	cmp	w0, #0x0
   82a94:	54000041 	b.ne	82a9c <uart_send+0x2c>  // b.any
        asm volatile("nop");
   82a98:	17fffff9 	b	82a7c <uart_send+0xc>
            break;
   82a9c:	d503201f 	nop
    }
    put32(AUX_MU_IO_REG, c);
   82aa0:	39407fe0 	ldrb	w0, [sp, #31]
   82aa4:	2a0003e1 	mov	w1, w0
   82aa8:	d28a0800 	mov	x0, #0x5040                	// #20544
   82aac:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82ab0:	94000dc2 	bl	861b8 <put32>
    if(c == '\n')
   82ab4:	39407fe0 	ldrb	w0, [sp, #31]
   82ab8:	7100281f 	cmp	w0, #0xa
   82abc:	54000061 	b.ne	82ac8 <uart_send+0x58>  // b.any
        uart_send('\r');
   82ac0:	528001a0 	mov	w0, #0xd                   	// #13
   82ac4:	97ffffeb 	bl	82a70 <uart_send>
}
   82ac8:	d503201f 	nop
   82acc:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82ad0:	d65f03c0 	ret

0000000000082ad4 <uart_recv>:

char uart_recv(void) {
   82ad4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   82ad8:	910003fd 	mov	x29, sp
    while (1) {
        asm volatile("nop");
   82adc:	d503201f 	nop
        if (get32(AUX_MU_LSR_REG) & 0x01)
   82ae0:	d28a0a80 	mov	x0, #0x5054                	// #20564
   82ae4:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82ae8:	94000db6 	bl	861c0 <get32>
   82aec:	12000000 	and	w0, w0, #0x1
   82af0:	7100001f 	cmp	w0, #0x0
   82af4:	54000041 	b.ne	82afc <uart_recv+0x28>  // b.any
        asm volatile("nop");
   82af8:	17fffff9 	b	82adc <uart_recv+0x8>
            break;
   82afc:	d503201f 	nop
    }
    char ret = get32(AUX_MU_IO_REG) & 0xFF;
   82b00:	d28a0800 	mov	x0, #0x5040                	// #20544
   82b04:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82b08:	94000dae 	bl	861c0 <get32>
   82b0c:	39007fe0 	strb	w0, [sp, #31]
    return (ret=='\r')?'\n':ret;
   82b10:	39407fe0 	ldrb	w0, [sp, #31]
   82b14:	7100341f 	cmp	w0, #0xd
   82b18:	54000060 	b.eq	82b24 <uart_recv+0x50>  // b.none
   82b1c:	39407fe0 	ldrb	w0, [sp, #31]
   82b20:	14000002 	b	82b28 <uart_recv+0x54>
   82b24:	52800140 	mov	w0, #0xa                   	// #10
}
   82b28:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82b2c:	d65f03c0 	ret

0000000000082b30 <uart_send_string>:

void uart_send_string(char* str) {
   82b30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82b34:	910003fd 	mov	x29, sp
   82b38:	f9000fe0 	str	x0, [sp, #24]
    for (int i = 0; str[i] != '\0'; i++) {
   82b3c:	b9002fff 	str	wzr, [sp, #44]
   82b40:	14000009 	b	82b64 <uart_send_string+0x34>
        uart_send((char)str[i]);
   82b44:	b9802fe0 	ldrsw	x0, [sp, #44]
   82b48:	f9400fe1 	ldr	x1, [sp, #24]
   82b4c:	8b000020 	add	x0, x1, x0
   82b50:	39400000 	ldrb	w0, [x0]
   82b54:	97ffffc7 	bl	82a70 <uart_send>
    for (int i = 0; str[i] != '\0'; i++) {
   82b58:	b9402fe0 	ldr	w0, [sp, #44]
   82b5c:	11000400 	add	w0, w0, #0x1
   82b60:	b9002fe0 	str	w0, [sp, #44]
   82b64:	b9802fe0 	ldrsw	x0, [sp, #44]
   82b68:	f9400fe1 	ldr	x1, [sp, #24]
   82b6c:	8b000020 	add	x0, x1, x0
   82b70:	39400000 	ldrb	w0, [x0]
   82b74:	7100001f 	cmp	w0, #0x0
   82b78:	54fffe61 	b.ne	82b44 <uart_send_string+0x14>  // b.any
    }
}
   82b7c:	d503201f 	nop
   82b80:	d503201f 	nop
   82b84:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82b88:	d65f03c0 	ret

0000000000082b8c <uart_send_hex>:

void uart_send_hex(unsigned int *n){
   82b8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82b90:	910003fd 	mov	x29, sp
   82b94:	f9000fe0 	str	x0, [sp, #24]
    char c;
    int hex;
    uart_send_string("0x");
   82b98:	d0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   82b9c:	912b4000 	add	x0, x0, #0xad0
   82ba0:	97ffffe4 	bl	82b30 <uart_send_string>
    for(int i=28; i>=0; i-=4){
   82ba4:	52800380 	mov	w0, #0x1c                  	// #28
   82ba8:	b9002fe0 	str	w0, [sp, #44]
   82bac:	14000019 	b	82c10 <uart_send_hex+0x84>
        hex = (*n >> i) & 0xF;
   82bb0:	f9400fe0 	ldr	x0, [sp, #24]
   82bb4:	b9400001 	ldr	w1, [x0]
   82bb8:	b9402fe0 	ldr	w0, [sp, #44]
   82bbc:	1ac02420 	lsr	w0, w1, w0
   82bc0:	12000c00 	and	w0, w0, #0xf
   82bc4:	b9002be0 	str	w0, [sp, #40]
        c = (hex > 9)? 'A' - 10 + hex: '0' + hex;
   82bc8:	b9402be0 	ldr	w0, [sp, #40]
   82bcc:	7100241f 	cmp	w0, #0x9
   82bd0:	540000cd 	b.le	82be8 <uart_send_hex+0x5c>
   82bd4:	b9402be0 	ldr	w0, [sp, #40]
   82bd8:	12001c00 	and	w0, w0, #0xff
   82bdc:	1100dc00 	add	w0, w0, #0x37
   82be0:	12001c00 	and	w0, w0, #0xff
   82be4:	14000005 	b	82bf8 <uart_send_hex+0x6c>
   82be8:	b9402be0 	ldr	w0, [sp, #40]
   82bec:	12001c00 	and	w0, w0, #0xff
   82bf0:	1100c000 	add	w0, w0, #0x30
   82bf4:	12001c00 	and	w0, w0, #0xff
   82bf8:	39009fe0 	strb	w0, [sp, #39]
        uart_send(c);
   82bfc:	39409fe0 	ldrb	w0, [sp, #39]
   82c00:	97ffff9c 	bl	82a70 <uart_send>
    for(int i=28; i>=0; i-=4){
   82c04:	b9402fe0 	ldr	w0, [sp, #44]
   82c08:	51001000 	sub	w0, w0, #0x4
   82c0c:	b9002fe0 	str	w0, [sp, #44]
   82c10:	b9402fe0 	ldr	w0, [sp, #44]
   82c14:	7100001f 	cmp	w0, #0x0
   82c18:	54fffcca 	b.ge	82bb0 <uart_send_hex+0x24>  // b.tcont
    }
}
   82c1c:	d503201f 	nop
   82c20:	d503201f 	nop
   82c24:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82c28:	d65f03c0 	ret

0000000000082c2c <uart_send_hex64>:

void uart_send_hex64(unsigned long long *n){
   82c2c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   82c30:	910003fd 	mov	x29, sp
   82c34:	f9000fe0 	str	x0, [sp, #24]
    char c;
    int hex;
    uart_send_string("0x");
   82c38:	d0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   82c3c:	912b4000 	add	x0, x0, #0xad0
   82c40:	97ffffbc 	bl	82b30 <uart_send_string>
    for(int i=60; i>=0; i-=4){
   82c44:	52800780 	mov	w0, #0x3c                  	// #60
   82c48:	b9002fe0 	str	w0, [sp, #44]
   82c4c:	14000019 	b	82cb0 <uart_send_hex64+0x84>
        hex = (*n >> i) & 0xF;
   82c50:	f9400fe0 	ldr	x0, [sp, #24]
   82c54:	f9400001 	ldr	x1, [x0]
   82c58:	b9402fe0 	ldr	w0, [sp, #44]
   82c5c:	9ac02420 	lsr	x0, x1, x0
   82c60:	12000c00 	and	w0, w0, #0xf
   82c64:	b9002be0 	str	w0, [sp, #40]
        c = (hex > 9)? 'A' - 10 + hex: '0' + hex;
   82c68:	b9402be0 	ldr	w0, [sp, #40]
   82c6c:	7100241f 	cmp	w0, #0x9
   82c70:	540000cd 	b.le	82c88 <uart_send_hex64+0x5c>
   82c74:	b9402be0 	ldr	w0, [sp, #40]
   82c78:	12001c00 	and	w0, w0, #0xff
   82c7c:	1100dc00 	add	w0, w0, #0x37
   82c80:	12001c00 	and	w0, w0, #0xff
   82c84:	14000005 	b	82c98 <uart_send_hex64+0x6c>
   82c88:	b9402be0 	ldr	w0, [sp, #40]
   82c8c:	12001c00 	and	w0, w0, #0xff
   82c90:	1100c000 	add	w0, w0, #0x30
   82c94:	12001c00 	and	w0, w0, #0xff
   82c98:	39009fe0 	strb	w0, [sp, #39]
        uart_send(c);
   82c9c:	39409fe0 	ldrb	w0, [sp, #39]
   82ca0:	97ffff74 	bl	82a70 <uart_send>
    for(int i=60; i>=0; i-=4){
   82ca4:	b9402fe0 	ldr	w0, [sp, #44]
   82ca8:	51001000 	sub	w0, w0, #0x4
   82cac:	b9002fe0 	str	w0, [sp, #44]
   82cb0:	b9402fe0 	ldr	w0, [sp, #44]
   82cb4:	7100001f 	cmp	w0, #0x0
   82cb8:	54fffcca 	b.ge	82c50 <uart_send_hex64+0x24>  // b.tcont
    }
}
   82cbc:	d503201f 	nop
   82cc0:	d503201f 	nop
   82cc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
   82cc8:	d65f03c0 	ret

0000000000082ccc <uart_init>:

void uart_init(void) {
   82ccc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   82cd0:	910003fd 	mov	x29, sp

    unsigned int selector;
    selector = get32(GPFSEL1);  // GPFSEL1 reg control alternative funct
   82cd4:	d2800080 	mov	x0, #0x4                   	// #4
   82cd8:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   82cdc:	94000d39 	bl	861c0 <get32>
   82ce0:	b9001fe0 	str	w0, [sp, #28]
    selector &= ~(7 << 12);     // clean gpio14 
   82ce4:	b9401fe0 	ldr	w0, [sp, #28]
   82ce8:	12117000 	and	w0, w0, #0xffff8fff
   82cec:	b9001fe0 	str	w0, [sp, #28]
    selector |= 2 << 12;        // set alt5 for gpio14
   82cf0:	b9401fe0 	ldr	w0, [sp, #28]
   82cf4:	32130000 	orr	w0, w0, #0x2000
   82cf8:	b9001fe0 	str	w0, [sp, #28]
    selector &= ~(7 << 15);     // clean gpio15
   82cfc:	b9401fe0 	ldr	w0, [sp, #28]
   82d00:	120e7000 	and	w0, w0, #0xfffc7fff
   82d04:	b9001fe0 	str	w0, [sp, #28]
    selector |= 2 << 15;        // set alt5 for gpio 15
   82d08:	b9401fe0 	ldr	w0, [sp, #28]
   82d0c:	32100000 	orr	w0, w0, #0x10000
   82d10:	b9001fe0 	str	w0, [sp, #28]
    put32(GPFSEL1, selector);
   82d14:	b9401fe1 	ldr	w1, [sp, #28]
   82d18:	d2800080 	mov	x0, #0x4                   	// #4
   82d1c:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   82d20:	94000d26 	bl	861b8 <put32>

    // remove both the pull-up/down state
    put32(GPPUD, 0);
   82d24:	52800001 	mov	w1, #0x0                   	// #0
   82d28:	d2801280 	mov	x0, #0x94                  	// #148
   82d2c:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   82d30:	94000d22 	bl	861b8 <put32>
    delay(150);
   82d34:	d28012c0 	mov	x0, #0x96                  	// #150
   82d38:	94000d24 	bl	861c8 <delay>
    put32(GPPUDCLK0, (1 << 14) | (1 << 15));
   82d3c:	52980001 	mov	w1, #0xc000                	// #49152
   82d40:	d2801300 	mov	x0, #0x98                  	// #152
   82d44:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   82d48:	94000d1c 	bl	861b8 <put32>
    delay(150);
   82d4c:	d28012c0 	mov	x0, #0x96                  	// #150
   82d50:	94000d1e 	bl	861c8 <delay>
    put32(GPPUDCLK0, 0);
   82d54:	52800001 	mov	w1, #0x0                   	// #0
   82d58:	d2801300 	mov	x0, #0x98                  	// #152
   82d5c:	f2a7e400 	movk	x0, #0x3f20, lsl #16
   82d60:	94000d16 	bl	861b8 <put32>

    // Enable mini uart (this also enables access to its registers)
    put32(AUX_ENABLES, 1); //If this bit is set the interrupt line is asserted whenever
   82d64:	52800021 	mov	w1, #0x1                   	// #1
   82d68:	d28a0080 	mov	x0, #0x5004                	// #20484
   82d6c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82d70:	94000d12 	bl	861b8 <put32>

    // Disable auto flow control and disable receiver and transmitter (for now)
    put32(AUX_MU_CNTL_REG, 0);
   82d74:	52800001 	mov	w1, #0x0                   	// #0
   82d78:	d28a0c00 	mov	x0, #0x5060                	// #20576
   82d7c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82d80:	94000d0e 	bl	861b8 <put32>

    // Disable receive and transmit interrupts
    put32(AUX_MU_IER_REG, 0);
   82d84:	52800001 	mov	w1, #0x0                   	// #0
   82d88:	d28a0880 	mov	x0, #0x5044                	// #20548
   82d8c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82d90:	94000d0a 	bl	861b8 <put32>
    
    // Enable 8 bit mode
    put32(AUX_MU_LCR_REG, 3);
   82d94:	52800061 	mov	w1, #0x3                   	// #3
   82d98:	d28a0980 	mov	x0, #0x504c                	// #20556
   82d9c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82da0:	94000d06 	bl	861b8 <put32>
    
    // Set RTS line to be always high
    put32(AUX_MU_MCR_REG, 0);
   82da4:	52800001 	mov	w1, #0x0                   	// #0
   82da8:	d28a0a00 	mov	x0, #0x5050                	// #20560
   82dac:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82db0:	94000d02 	bl	861b8 <put32>

    // Set baud rate to 115200
    put32(AUX_MU_BAUD_REG, 270);
   82db4:	528021c1 	mov	w1, #0x10e                 	// #270
   82db8:	d28a0d00 	mov	x0, #0x5068                	// #20584
   82dbc:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82dc0:	94000cfe 	bl	861b8 <put32>


    put32(AUX_MU_IIR_REG, 6);
   82dc4:	528000c1 	mov	w1, #0x6                   	// #6
   82dc8:	d28a0900 	mov	x0, #0x5048                	// #20552
   82dcc:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82dd0:	94000cfa 	bl	861b8 <put32>

    // Finally, enable transmitter and receiver
    put32(AUX_MU_CNTL_REG, 3);
   82dd4:	52800061 	mov	w1, #0x3                   	// #3
   82dd8:	d28a0c00 	mov	x0, #0x5060                	// #20576
   82ddc:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   82de0:	94000cf6 	bl	861b8 <put32>

}
   82de4:	d503201f 	nop
   82de8:	a8c27bfd 	ldp	x29, x30, [sp], #32
   82dec:	d65f03c0 	ret

0000000000082df0 <uart_printf>:

void uart_printf(char* fmt, ...){
   82df0:	d124c3ff 	sub	sp, sp, #0x930
   82df4:	a9007bfd 	stp	x29, x30, [sp]
   82df8:	910003fd 	mov	x29, sp
   82dfc:	f9001fe0 	str	x0, [sp, #56]
   82e00:	f9047fe1 	str	x1, [sp, #2296]
   82e04:	f90483e2 	str	x2, [sp, #2304]
   82e08:	f90487e3 	str	x3, [sp, #2312]
   82e0c:	f9048be4 	str	x4, [sp, #2320]
   82e10:	f9048fe5 	str	x5, [sp, #2328]
   82e14:	f90493e6 	str	x6, [sp, #2336]
   82e18:	f90497e7 	str	x7, [sp, #2344]
   82e1c:	912003e0 	add	x0, sp, #0x800
   82e20:	3d801c00 	str	q0, [x0, #112]
   82e24:	912003e0 	add	x0, sp, #0x800
   82e28:	3d802001 	str	q1, [x0, #128]
   82e2c:	912003e0 	add	x0, sp, #0x800
   82e30:	3d802402 	str	q2, [x0, #144]
   82e34:	912003e0 	add	x0, sp, #0x800
   82e38:	3d802803 	str	q3, [x0, #160]
   82e3c:	912003e0 	add	x0, sp, #0x800
   82e40:	3d802c04 	str	q4, [x0, #176]
   82e44:	912003e0 	add	x0, sp, #0x800
   82e48:	3d803005 	str	q5, [x0, #192]
   82e4c:	912003e0 	add	x0, sp, #0x800
   82e50:	3d803406 	str	q6, [x0, #208]
   82e54:	912003e0 	add	x0, sp, #0x800
   82e58:	3d803807 	str	q7, [x0, #224]
    __builtin_va_list args;
    __builtin_va_start(args, fmt);
   82e5c:	9124c3e0 	add	x0, sp, #0x930
   82e60:	f90427e0 	str	x0, [sp, #2120]
   82e64:	9124c3e0 	add	x0, sp, #0x930
   82e68:	f9042be0 	str	x0, [sp, #2128]
   82e6c:	9123c3e0 	add	x0, sp, #0x8f0
   82e70:	f9042fe0 	str	x0, [sp, #2136]
   82e74:	128006e0 	mov	w0, #0xffffffc8            	// #-56
   82e78:	b90863e0 	str	w0, [sp, #2144]
   82e7c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
   82e80:	b90867e0 	str	w0, [sp, #2148]

    char str[2048];
    m_vsprintf(str, fmt, args);
   82e84:	910043e2 	add	x2, sp, #0x10
   82e88:	912123e3 	add	x3, sp, #0x848
   82e8c:	a9400460 	ldp	x0, x1, [x3]
   82e90:	a9000440 	stp	x0, x1, [x2]
   82e94:	a9410460 	ldp	x0, x1, [x3, #16]
   82e98:	a9010440 	stp	x0, x1, [x2, #16]
   82e9c:	910043e1 	add	x1, sp, #0x10
   82ea0:	910123e0 	add	x0, sp, #0x48
   82ea4:	aa0103e2 	mov	x2, x1
   82ea8:	f9401fe1 	ldr	x1, [sp, #56]
   82eac:	97fffd7b 	bl	82498 <m_vsprintf>
    char *s = str;
   82eb0:	910123e0 	add	x0, sp, #0x48
   82eb4:	f90437e0 	str	x0, [sp, #2152]
    while (*s) uart_send(*s++);
   82eb8:	14000006 	b	82ed0 <uart_printf+0xe0>
   82ebc:	f94437e0 	ldr	x0, [sp, #2152]
   82ec0:	91000401 	add	x1, x0, #0x1
   82ec4:	f90437e1 	str	x1, [sp, #2152]
   82ec8:	39400000 	ldrb	w0, [x0]
   82ecc:	97fffee9 	bl	82a70 <uart_send>
   82ed0:	f94437e0 	ldr	x0, [sp, #2152]
   82ed4:	39400000 	ldrb	w0, [x0]
   82ed8:	7100001f 	cmp	w0, #0x0
   82edc:	54ffff01 	b.ne	82ebc <uart_printf+0xcc>  // b.any
}
   82ee0:	d503201f 	nop
   82ee4:	d503201f 	nop
   82ee8:	a9407bfd 	ldp	x29, x30, [sp]
   82eec:	9124c3ff 	add	sp, sp, #0x930
   82ef0:	d65f03c0 	ret

0000000000082ef4 <uart_async_readline>:
int read_st = 0;
int read_ed = 0;
int write_st = 0;
int write_ed = 0;

int uart_async_readline(char* target, int len){
   82ef4:	d10083ff 	sub	sp, sp, #0x20
   82ef8:	f90007e0 	str	x0, [sp, #8]
   82efc:	b90007e1 	str	w1, [sp, #4]
    int i;
    len -= 1;
   82f00:	b94007e0 	ldr	w0, [sp, #4]
   82f04:	51000400 	sub	w0, w0, #0x1
   82f08:	b90007e0 	str	w0, [sp, #4]
    target[len] = '\0';
   82f0c:	b98007e0 	ldrsw	x0, [sp, #4]
   82f10:	f94007e1 	ldr	x1, [sp, #8]
   82f14:	8b000020 	add	x0, x1, x0
   82f18:	3900001f 	strb	wzr, [x0]
    for (i = 0; i < len; i++){
   82f1c:	b9001fff 	str	wzr, [sp, #28]
   82f20:	14000030 	b	82fe0 <uart_async_readline+0xec>
        while (read_st == read_ed)
            asm volatile("nop");
   82f24:	d503201f 	nop
        while (read_st == read_ed)
   82f28:	90000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   82f2c:	91298000 	add	x0, x0, #0xa60
   82f30:	b9400001 	ldr	w1, [x0]
   82f34:	90000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   82f38:	91299000 	add	x0, x0, #0xa64
   82f3c:	b9400000 	ldr	w0, [x0]
   82f40:	6b00003f 	cmp	w1, w0
   82f44:	54ffff00 	b.eq	82f24 <uart_async_readline+0x30>  // b.none
   
        char c = read_buffer[read_st++];
   82f48:	90000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   82f4c:	91298000 	add	x0, x0, #0xa60
   82f50:	b9400000 	ldr	w0, [x0]
   82f54:	11000402 	add	w2, w0, #0x1
   82f58:	90000041 	adrp	x1, 8a000 <__func__.3228+0x710>
   82f5c:	91298021 	add	x1, x1, #0xa60
   82f60:	b9000022 	str	w2, [x1]
   82f64:	90000041 	adrp	x1, 8a000 <__func__.3228+0x710>
   82f68:	f9447021 	ldr	x1, [x1, #2272]
   82f6c:	93407c00 	sxtw	x0, w0
   82f70:	38606820 	ldrb	w0, [x1, x0]
   82f74:	39006fe0 	strb	w0, [sp, #27]
        read_st %= BUFFER_SIZE;
   82f78:	90000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   82f7c:	91298000 	add	x0, x0, #0xa60
   82f80:	b9400000 	ldr	w0, [x0]
   82f84:	6b0003e1 	negs	w1, w0
   82f88:	12001000 	and	w0, w0, #0x1f
   82f8c:	12001021 	and	w1, w1, #0x1f
   82f90:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   82f94:	90000040 	adrp	x0, 8a000 <__func__.3228+0x710>
   82f98:	91298000 	add	x0, x0, #0xa60
   82f9c:	b9000001 	str	w1, [x0]
        if (c == '\n'){
   82fa0:	39406fe0 	ldrb	w0, [sp, #27]
   82fa4:	7100281f 	cmp	w0, #0xa
   82fa8:	540000c1 	b.ne	82fc0 <uart_async_readline+0xcc>  // b.any
            target[i] = '\0';
   82fac:	b9801fe0 	ldrsw	x0, [sp, #28]
   82fb0:	f94007e1 	ldr	x1, [sp, #8]
   82fb4:	8b000020 	add	x0, x1, x0
   82fb8:	3900001f 	strb	wzr, [x0]
            break;
   82fbc:	1400000d 	b	82ff0 <uart_async_readline+0xfc>
        } else{
            target[i] = c;
   82fc0:	b9801fe0 	ldrsw	x0, [sp, #28]
   82fc4:	f94007e1 	ldr	x1, [sp, #8]
   82fc8:	8b000020 	add	x0, x1, x0
   82fcc:	39406fe1 	ldrb	w1, [sp, #27]
   82fd0:	39000001 	strb	w1, [x0]
    for (i = 0; i < len; i++){
   82fd4:	b9401fe0 	ldr	w0, [sp, #28]
   82fd8:	11000400 	add	w0, w0, #0x1
   82fdc:	b9001fe0 	str	w0, [sp, #28]
   82fe0:	b9401fe1 	ldr	w1, [sp, #28]
   82fe4:	b94007e0 	ldr	w0, [sp, #4]
   82fe8:	6b00003f 	cmp	w1, w0
   82fec:	54fff9eb 	b.lt	82f28 <uart_async_readline+0x34>  // b.tstop
        }
    }
    target[i] = '\0';
   82ff0:	b9801fe0 	ldrsw	x0, [sp, #28]
   82ff4:	f94007e1 	ldr	x1, [sp, #8]
   82ff8:	8b000020 	add	x0, x1, x0
   82ffc:	3900001f 	strb	wzr, [x0]
    return i;
   83000:	b9401fe0 	ldr	w0, [sp, #28]
}
   83004:	910083ff 	add	sp, sp, #0x20
   83008:	d65f03c0 	ret

000000000008300c <uart_async_send_string>:

int uart_async_send_string(char* str) {
   8300c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83010:	910003fd 	mov	x29, sp
   83014:	f9000fe0 	str	x0, [sp, #24]
	if(m_strlen(str) >= BUFFER_SIZE-1)
   83018:	f9400fe0 	ldr	x0, [sp, #24]
   8301c:	97fffc0d 	bl	82050 <m_strlen>
   83020:	7100781f 	cmp	w0, #0x1e
   83024:	5400006d 	b.le	83030 <uart_async_send_string+0x24>
        return 0;
   83028:	52800000 	mov	w0, #0x0                   	// #0
   8302c:	1400005b 	b	83198 <uart_async_send_string+0x18c>
	for(int i = 0; str[i] != '\0'; i++){
   83030:	b9002fff 	str	wzr, [sp, #44]
   83034:	14000050 	b	83174 <uart_async_send_string+0x168>
		if (str[i] == '\n') {
   83038:	b9802fe0 	ldrsw	x0, [sp, #44]
   8303c:	f9400fe1 	ldr	x1, [sp, #24]
   83040:	8b000020 	add	x0, x1, x0
   83044:	39400000 	ldrb	w0, [x0]
   83048:	7100281f 	cmp	w0, #0xa
   8304c:	540005c1 	b.ne	83104 <uart_async_send_string+0xf8>  // b.any
			write_buffer[write_ed++] = '\r';
   83050:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83054:	9129b000 	add	x0, x0, #0xa6c
   83058:	b9400000 	ldr	w0, [x0]
   8305c:	11000402 	add	w2, w0, #0x1
   83060:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   83064:	9129b021 	add	x1, x1, #0xa6c
   83068:	b9000022 	str	w2, [x1]
   8306c:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   83070:	f9447821 	ldr	x1, [x1, #2288]
   83074:	93407c00 	sxtw	x0, w0
   83078:	528001a2 	mov	w2, #0xd                   	// #13
   8307c:	38206822 	strb	w2, [x1, x0]
			write_ed %= BUFFER_SIZE;
   83080:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83084:	9129b000 	add	x0, x0, #0xa6c
   83088:	b9400000 	ldr	w0, [x0]
   8308c:	6b0003e1 	negs	w1, w0
   83090:	12001000 	and	w0, w0, #0x1f
   83094:	12001021 	and	w1, w1, #0x1f
   83098:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   8309c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   830a0:	9129b000 	add	x0, x0, #0xa6c
   830a4:	b9000001 	str	w1, [x0]
			write_buffer[write_ed++] = '\n';
   830a8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   830ac:	9129b000 	add	x0, x0, #0xa6c
   830b0:	b9400000 	ldr	w0, [x0]
   830b4:	11000402 	add	w2, w0, #0x1
   830b8:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   830bc:	9129b021 	add	x1, x1, #0xa6c
   830c0:	b9000022 	str	w2, [x1]
   830c4:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   830c8:	f9447821 	ldr	x1, [x1, #2288]
   830cc:	93407c00 	sxtw	x0, w0
   830d0:	52800142 	mov	w2, #0xa                   	// #10
   830d4:	38206822 	strb	w2, [x1, x0]
			write_ed %= BUFFER_SIZE;
   830d8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   830dc:	9129b000 	add	x0, x0, #0xa6c
   830e0:	b9400000 	ldr	w0, [x0]
   830e4:	6b0003e1 	negs	w1, w0
   830e8:	12001000 	and	w0, w0, #0x1f
   830ec:	12001021 	and	w1, w1, #0x1f
   830f0:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   830f4:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   830f8:	9129b000 	add	x0, x0, #0xa6c
   830fc:	b9000001 	str	w1, [x0]
   83100:	1400001a 	b	83168 <uart_async_send_string+0x15c>
		} else {
			write_buffer[write_ed++] = str[i];
   83104:	b9802fe0 	ldrsw	x0, [sp, #44]
   83108:	f9400fe1 	ldr	x1, [sp, #24]
   8310c:	8b000021 	add	x1, x1, x0
   83110:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83114:	9129b000 	add	x0, x0, #0xa6c
   83118:	b9400000 	ldr	w0, [x0]
   8311c:	11000403 	add	w3, w0, #0x1
   83120:	f0000022 	adrp	x2, 8a000 <__func__.3228+0x710>
   83124:	9129b042 	add	x2, x2, #0xa6c
   83128:	b9000043 	str	w3, [x2]
   8312c:	39400022 	ldrb	w2, [x1]
   83130:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   83134:	f9447821 	ldr	x1, [x1, #2288]
   83138:	93407c00 	sxtw	x0, w0
   8313c:	38206822 	strb	w2, [x1, x0]
			write_ed %= BUFFER_SIZE;
   83140:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83144:	9129b000 	add	x0, x0, #0xa6c
   83148:	b9400000 	ldr	w0, [x0]
   8314c:	6b0003e1 	negs	w1, w0
   83150:	12001000 	and	w0, w0, #0x1f
   83154:	12001021 	and	w1, w1, #0x1f
   83158:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   8315c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83160:	9129b000 	add	x0, x0, #0xa6c
   83164:	b9000001 	str	w1, [x0]
	for(int i = 0; str[i] != '\0'; i++){
   83168:	b9402fe0 	ldr	w0, [sp, #44]
   8316c:	11000400 	add	w0, w0, #0x1
   83170:	b9002fe0 	str	w0, [sp, #44]
   83174:	b9802fe0 	ldrsw	x0, [sp, #44]
   83178:	f9400fe1 	ldr	x1, [sp, #24]
   8317c:	8b000020 	add	x0, x1, x0
   83180:	39400000 	ldrb	w0, [x0]
   83184:	7100001f 	cmp	w0, #0x0
   83188:	54fff581 	b.ne	83038 <uart_async_send_string+0x2c>  // b.any
		}
	}
	uart_set_transmit_interrupt(1);
   8318c:	52800020 	mov	w0, #0x1                   	// #1
   83190:	94000004 	bl	831a0 <uart_set_transmit_interrupt>
	return 1;
   83194:	52800020 	mov	w0, #0x1                   	// #1
}
   83198:	a8c37bfd 	ldp	x29, x30, [sp], #48
   8319c:	d65f03c0 	ret

00000000000831a0 <uart_set_transmit_interrupt>:

void uart_set_transmit_interrupt(int enable){
   831a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   831a4:	910003fd 	mov	x29, sp
   831a8:	b9001fe0 	str	w0, [sp, #28]
    unsigned reg = get32(AUX_MU_IER_REG);
   831ac:	d28a0880 	mov	x0, #0x5044                	// #20548
   831b0:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   831b4:	94000c03 	bl	861c0 <get32>
   831b8:	b9002fe0 	str	w0, [sp, #44]
    // bcm2837 p12, enable transmit INTERRUPT 
    reg &= ~(AUX_MU_IER_REG_TRANSMIT_INTERRUPT);
   831bc:	b9402fe0 	ldr	w0, [sp, #44]
   831c0:	121e7800 	and	w0, w0, #0xfffffffd
   831c4:	b9002fe0 	str	w0, [sp, #44]
    if(enable) reg |= AUX_MU_IER_REG_TRANSMIT_INTERRUPT;
   831c8:	b9401fe0 	ldr	w0, [sp, #28]
   831cc:	7100001f 	cmp	w0, #0x0
   831d0:	54000080 	b.eq	831e0 <uart_set_transmit_interrupt+0x40>  // b.none
   831d4:	b9402fe0 	ldr	w0, [sp, #44]
   831d8:	321f0000 	orr	w0, w0, #0x2
   831dc:	b9002fe0 	str	w0, [sp, #44]
    put32(AUX_MU_IER_REG, reg);
   831e0:	b9402fe1 	ldr	w1, [sp, #44]
   831e4:	d28a0880 	mov	x0, #0x5044                	// #20548
   831e8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   831ec:	94000bf3 	bl	861b8 <put32>
}
   831f0:	d503201f 	nop
   831f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
   831f8:	d65f03c0 	ret

00000000000831fc <uart_set_receive_interrupt>:

void uart_set_receive_interrupt(int enable){
   831fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83200:	910003fd 	mov	x29, sp
   83204:	b9001fe0 	str	w0, [sp, #28]
    unsigned reg = get32(AUX_MU_IER_REG);
   83208:	d28a0880 	mov	x0, #0x5044                	// #20548
   8320c:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   83210:	94000bec 	bl	861c0 <get32>
   83214:	b9002fe0 	str	w0, [sp, #44]
    // bcm2837 p12, enable receive INTERRUPT 
    reg &= ~(AUX_MU_IER_REG_RECEIVE_INTERRUPT); 
   83218:	b9402fe0 	ldr	w0, [sp, #44]
   8321c:	121f7800 	and	w0, w0, #0xfffffffe
   83220:	b9002fe0 	str	w0, [sp, #44]
    if(enable) reg |= AUX_MU_IER_REG_RECEIVE_INTERRUPT;
   83224:	b9401fe0 	ldr	w0, [sp, #28]
   83228:	7100001f 	cmp	w0, #0x0
   8322c:	54000080 	b.eq	8323c <uart_set_receive_interrupt+0x40>  // b.none
   83230:	b9402fe0 	ldr	w0, [sp, #44]
   83234:	32000000 	orr	w0, w0, #0x1
   83238:	b9002fe0 	str	w0, [sp, #44]
    put32(AUX_MU_IER_REG, reg);
   8323c:	b9402fe1 	ldr	w1, [sp, #44]
   83240:	d28a0880 	mov	x0, #0x5044                	// #20548
   83244:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   83248:	94000bdc 	bl	861b8 <put32>
}
   8324c:	d503201f 	nop
   83250:	a8c37bfd 	ldp	x29, x30, [sp], #48
   83254:	d65f03c0 	ret

0000000000083258 <uart_set_aux_interrupt>:

void uart_set_aux_interrupt(int enable){
   83258:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   8325c:	910003fd 	mov	x29, sp
   83260:	b9001fe0 	str	w0, [sp, #28]
    // bcm2837 p116, enable aux interrupt
    unsigned int reg = get32(ENABLE_IRQS_1);
   83264:	d2964200 	mov	x0, #0xb210                	// #45584
   83268:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   8326c:	94000bd5 	bl	861c0 <get32>
   83270:	b9002fe0 	str	w0, [sp, #44]
    reg &= ~(AUX_INT);
   83274:	b9402fe0 	ldr	w0, [sp, #44]
   83278:	12027800 	and	w0, w0, #0xdfffffff
   8327c:	b9002fe0 	str	w0, [sp, #44]
    if(enable) reg |= AUX_INT;
   83280:	b9401fe0 	ldr	w0, [sp, #28]
   83284:	7100001f 	cmp	w0, #0x0
   83288:	54000080 	b.eq	83298 <uart_set_aux_interrupt+0x40>  // b.none
   8328c:	b9402fe0 	ldr	w0, [sp, #44]
   83290:	32030000 	orr	w0, w0, #0x20000000
   83294:	b9002fe0 	str	w0, [sp, #44]
    put32(ENABLE_IRQS_1, reg);
   83298:	b9402fe1 	ldr	w1, [sp, #44]
   8329c:	d2964200 	mov	x0, #0xb210                	// #45584
   832a0:	f2a7e000 	movk	x0, #0x3f00, lsl #16
   832a4:	94000bc5 	bl	861b8 <put32>
}
   832a8:	d503201f 	nop
   832ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
   832b0:	d65f03c0 	ret

00000000000832b4 <demo_uart_async>:


void demo_uart_async(void){
   832b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   832b8:	910003fd 	mov	x29, sp
    uart_set_receive_interrupt(1);
   832bc:	52800020 	mov	w0, #0x1                   	// #1
   832c0:	97ffffcf 	bl	831fc <uart_set_receive_interrupt>
    uart_set_aux_interrupt(1);
   832c4:	52800020 	mov	w0, #0x1                   	// #1
   832c8:	97ffffe4 	bl	83258 <uart_set_aux_interrupt>
    char buffer[BUFFER_SIZE];
    while(1){
        uart_async_send_string("Async > ");
   832cc:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   832d0:	912b6000 	add	x0, x0, #0xad8
   832d4:	97ffff4e 	bl	8300c <uart_async_send_string>
		uart_async_readline(buffer, BUFFER_SIZE);
   832d8:	910043e0 	add	x0, sp, #0x10
   832dc:	52800401 	mov	w1, #0x20                  	// #32
   832e0:	97ffff05 	bl	82ef4 <uart_async_readline>
		uart_async_send_string("[Async recv] ");
   832e4:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   832e8:	912ba000 	add	x0, x0, #0xae8
   832ec:	97ffff48 	bl	8300c <uart_async_send_string>
		uart_async_send_string(buffer);
   832f0:	910043e0 	add	x0, sp, #0x10
   832f4:	97ffff46 	bl	8300c <uart_async_send_string>
		uart_async_send_string("\r\n");
   832f8:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   832fc:	912be000 	add	x0, x0, #0xaf8
   83300:	97ffff43 	bl	8300c <uart_async_send_string>
        uart_async_send_string("Async > ");
   83304:	17fffff2 	b	832cc <demo_uart_async+0x18>

0000000000083308 <uart_irq_write>:
    uart_set_receive_interrupt(0);
    return ;
}


void uart_irq_write(){
   83308:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   8330c:	910003fd 	mov	x29, sp
    uart_set_transmit_interrupt(0);
   83310:	52800000 	mov	w0, #0x0                   	// #0
   83314:	97ffffa3 	bl	831a0 <uart_set_transmit_interrupt>
    while (write_st != write_ed) {
   83318:	14000017 	b	83374 <uart_irq_write+0x6c>
        uart_send(write_buffer[write_st++]);
   8331c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83320:	9129a000 	add	x0, x0, #0xa68
   83324:	b9400000 	ldr	w0, [x0]
   83328:	11000402 	add	w2, w0, #0x1
   8332c:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   83330:	9129a021 	add	x1, x1, #0xa68
   83334:	b9000022 	str	w2, [x1]
   83338:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   8333c:	f9447821 	ldr	x1, [x1, #2288]
   83340:	93407c00 	sxtw	x0, w0
   83344:	38606820 	ldrb	w0, [x1, x0]
   83348:	97fffdca 	bl	82a70 <uart_send>
        write_st %= BUFFER_SIZE;
   8334c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83350:	9129a000 	add	x0, x0, #0xa68
   83354:	b9400000 	ldr	w0, [x0]
   83358:	6b0003e1 	negs	w1, w0
   8335c:	12001000 	and	w0, w0, #0x1f
   83360:	12001021 	and	w1, w1, #0x1f
   83364:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   83368:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8336c:	9129a000 	add	x0, x0, #0xa68
   83370:	b9000001 	str	w1, [x0]
    while (write_st != write_ed) {
   83374:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83378:	9129a000 	add	x0, x0, #0xa68
   8337c:	b9400001 	ldr	w1, [x0]
   83380:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83384:	9129b000 	add	x0, x0, #0xa6c
   83388:	b9400000 	ldr	w0, [x0]
   8338c:	6b00003f 	cmp	w1, w0
   83390:	54fffc61 	b.ne	8331c <uart_irq_write+0x14>  // b.any
    }
}
   83394:	d503201f 	nop
   83398:	d503201f 	nop
   8339c:	a8c17bfd 	ldp	x29, x30, [sp], #16
   833a0:	d65f03c0 	ret

00000000000833a4 <uart_irq_read>:

void uart_irq_read(){
   833a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   833a8:	910003fd 	mov	x29, sp
    char c = uart_recv();
   833ac:	97fffdca 	bl	82ad4 <uart_recv>
   833b0:	39007fe0 	strb	w0, [sp, #31]
    read_buffer[read_ed++] = c;
   833b4:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   833b8:	91299000 	add	x0, x0, #0xa64
   833bc:	b9400000 	ldr	w0, [x0]
   833c0:	11000402 	add	w2, w0, #0x1
   833c4:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   833c8:	91299021 	add	x1, x1, #0xa64
   833cc:	b9000022 	str	w2, [x1]
   833d0:	f0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   833d4:	f9447021 	ldr	x1, [x1, #2272]
   833d8:	93407c00 	sxtw	x0, w0
   833dc:	39407fe2 	ldrb	w2, [sp, #31]
   833e0:	38206822 	strb	w2, [x1, x0]
    read_ed %= BUFFER_SIZE;
   833e4:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   833e8:	91299000 	add	x0, x0, #0xa64
   833ec:	b9400000 	ldr	w0, [x0]
   833f0:	6b0003e1 	negs	w1, w0
   833f4:	12001000 	and	w0, w0, #0x1f
   833f8:	12001021 	and	w1, w1, #0x1f
   833fc:	5a814401 	csneg	w1, w0, w1, mi  // mi = first
   83400:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83404:	91299000 	add	x0, x0, #0xa64
   83408:	b9000001 	str	w1, [x0]
    uart_send(c);
   8340c:	39407fe0 	ldrb	w0, [sp, #31]
   83410:	97fffd98 	bl	82a70 <uart_send>
    *(unsigned int *)AUX_MU_IER_REG |= (AUX_MU_IER_REG_RECEIVE_INTERRUPT);
   83414:	d28a0880 	mov	x0, #0x5044                	// #20548
   83418:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   8341c:	b9400001 	ldr	w1, [x0]
   83420:	d28a0880 	mov	x0, #0x5044                	// #20548
   83424:	f2a7e420 	movk	x0, #0x3f21, lsl #16
   83428:	32000021 	orr	w1, w1, #0x1
   8342c:	b9000001 	str	w1, [x0]
}
   83430:	d503201f 	nop
   83434:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83438:	d65f03c0 	ret

000000000008343c <set_devicetree_addr>:
#include "m_string.h"
#include "mini_uart.h"

fdt_header* devicetree_ptr = 0;

int set_devicetree_addr(fdt_header *addr){
   8343c:	d10043ff 	sub	sp, sp, #0x10
   83440:	f90007e0 	str	x0, [sp, #8]
    devicetree_ptr = addr;
   83444:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83448:	9129c000 	add	x0, x0, #0xa70
   8344c:	f94007e1 	ldr	x1, [sp, #8]
   83450:	f9000001 	str	x1, [x0]
    return 0;
   83454:	52800000 	mov	w0, #0x0                   	// #0
}
   83458:	910043ff 	add	sp, sp, #0x10
   8345c:	d65f03c0 	ret

0000000000083460 <fdt_align>:

char* fdt_align(char *p, int len){
   83460:	d10083ff 	sub	sp, sp, #0x20
   83464:	f90007e0 	str	x0, [sp, #8]
   83468:	b90007e1 	str	w1, [sp, #4]
    int tail = len % 4;
   8346c:	b94007e0 	ldr	w0, [sp, #4]
   83470:	6b0003e1 	negs	w1, w0
   83474:	12000400 	and	w0, w0, #0x3
   83478:	12000421 	and	w1, w1, #0x3
   8347c:	5a814400 	csneg	w0, w0, w1, mi  // mi = first
   83480:	b9001fe0 	str	w0, [sp, #28]
    int pad = (4-tail)%4;
   83484:	52800081 	mov	w1, #0x4                   	// #4
   83488:	b9401fe0 	ldr	w0, [sp, #28]
   8348c:	4b000020 	sub	w0, w1, w0
   83490:	6b0003e1 	negs	w1, w0
   83494:	12000400 	and	w0, w0, #0x3
   83498:	12000421 	and	w1, w1, #0x3
   8349c:	5a814400 	csneg	w0, w0, w1, mi  // mi = first
   834a0:	b9001be0 	str	w0, [sp, #24]
    return p + len + pad;
   834a4:	b98007e1 	ldrsw	x1, [sp, #4]
   834a8:	b9801be0 	ldrsw	x0, [sp, #24]
   834ac:	8b000020 	add	x0, x1, x0
   834b0:	f94007e1 	ldr	x1, [sp, #8]
   834b4:	8b000020 	add	x0, x1, x0
}
   834b8:	910083ff 	add	sp, sp, #0x20
   834bc:	d65f03c0 	ret

00000000000834c0 <read_bigendian>:

unsigned int read_bigendian(unsigned int *ptr){
   834c0:	d10083ff 	sub	sp, sp, #0x20
   834c4:	f90007e0 	str	x0, [sp, #8]
    unsigned int ret = 0;
   834c8:	b9001fff 	str	wzr, [sp, #28]
    unsigned int num = *ptr;
   834cc:	f94007e0 	ldr	x0, [sp, #8]
   834d0:	b9400000 	ldr	w0, [x0]
   834d4:	b9001be0 	str	w0, [sp, #24]
    for(int i=0; i<4; ++i){
   834d8:	b90017ff 	str	wzr, [sp, #20]
   834dc:	1400000f 	b	83518 <read_bigendian+0x58>
        ret <<= 8;
   834e0:	b9401fe0 	ldr	w0, [sp, #28]
   834e4:	53185c00 	lsl	w0, w0, #8
   834e8:	b9001fe0 	str	w0, [sp, #28]
        ret += num & 0x000000FF;
   834ec:	b9401be0 	ldr	w0, [sp, #24]
   834f0:	12001c00 	and	w0, w0, #0xff
   834f4:	b9401fe1 	ldr	w1, [sp, #28]
   834f8:	0b000020 	add	w0, w1, w0
   834fc:	b9001fe0 	str	w0, [sp, #28]
        num >>= 8;
   83500:	b9401be0 	ldr	w0, [sp, #24]
   83504:	53087c00 	lsr	w0, w0, #8
   83508:	b9001be0 	str	w0, [sp, #24]
    for(int i=0; i<4; ++i){
   8350c:	b94017e0 	ldr	w0, [sp, #20]
   83510:	11000400 	add	w0, w0, #0x1
   83514:	b90017e0 	str	w0, [sp, #20]
   83518:	b94017e0 	ldr	w0, [sp, #20]
   8351c:	71000c1f 	cmp	w0, #0x3
   83520:	54fffe0d 	b.le	834e0 <read_bigendian+0x20>
    }
    return ret;
   83524:	b9401fe0 	ldr	w0, [sp, #28]
}
   83528:	910083ff 	add	sp, sp, #0x20
   8352c:	d65f03c0 	ret

0000000000083530 <read_bigendian64>:

unsigned long long read_bigendian64(unsigned long long *ptr){
   83530:	d100c3ff 	sub	sp, sp, #0x30
   83534:	f90007e0 	str	x0, [sp, #8]
    unsigned long long ret = 0;
   83538:	f90017ff 	str	xzr, [sp, #40]
    unsigned long long num = *ptr;
   8353c:	f94007e0 	ldr	x0, [sp, #8]
   83540:	f9400000 	ldr	x0, [x0]
   83544:	f90013e0 	str	x0, [sp, #32]
    for(int i=0; i<8; ++i){
   83548:	b9001fff 	str	wzr, [sp, #28]
   8354c:	1400000f 	b	83588 <read_bigendian64+0x58>
        ret <<= 8;
   83550:	f94017e0 	ldr	x0, [sp, #40]
   83554:	d378dc00 	lsl	x0, x0, #8
   83558:	f90017e0 	str	x0, [sp, #40]
        ret += num & 0x000000FF;
   8355c:	f94013e0 	ldr	x0, [sp, #32]
   83560:	92401c00 	and	x0, x0, #0xff
   83564:	f94017e1 	ldr	x1, [sp, #40]
   83568:	8b000020 	add	x0, x1, x0
   8356c:	f90017e0 	str	x0, [sp, #40]
        num >>= 8;
   83570:	f94013e0 	ldr	x0, [sp, #32]
   83574:	d348fc00 	lsr	x0, x0, #8
   83578:	f90013e0 	str	x0, [sp, #32]
    for(int i=0; i<8; ++i){
   8357c:	b9401fe0 	ldr	w0, [sp, #28]
   83580:	11000400 	add	w0, w0, #0x1
   83584:	b9001fe0 	str	w0, [sp, #28]
   83588:	b9401fe0 	ldr	w0, [sp, #28]
   8358c:	71001c1f 	cmp	w0, #0x7
   83590:	54fffe0d 	b.le	83550 <read_bigendian64+0x20>
    }
    return ret;
   83594:	f94017e0 	ldr	x0, [sp, #40]
}
   83598:	9100c3ff 	add	sp, sp, #0x30
   8359c:	d65f03c0 	ret

00000000000835a0 <fdt_get_begin_end>:

int fdt_get_begin_end(char** begin, char **end){
   835a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   835a4:	910003fd 	mov	x29, sp
   835a8:	f9000bf3 	str	x19, [sp, #16]
   835ac:	f90017e0 	str	x0, [sp, #40]
   835b0:	f90013e1 	str	x1, [sp, #32]
    if(devicetree_ptr == 0){
   835b4:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   835b8:	9129c000 	add	x0, x0, #0xa70
   835bc:	f9400000 	ldr	x0, [x0]
   835c0:	f100001f 	cmp	x0, #0x0
   835c4:	540000e1 	b.ne	835e0 <fdt_get_begin_end+0x40>  // b.any
        *begin = 0;
   835c8:	f94017e0 	ldr	x0, [sp, #40]
   835cc:	f900001f 	str	xzr, [x0]
        *end = 0;
   835d0:	f94013e0 	ldr	x0, [sp, #32]
   835d4:	f900001f 	str	xzr, [x0]
        return -1;
   835d8:	12800000 	mov	w0, #0xffffffff            	// #-1
   835dc:	14000012 	b	83624 <fdt_get_begin_end+0x84>
    }
    *begin = (char*) devicetree_ptr;
   835e0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   835e4:	9129c000 	add	x0, x0, #0xa70
   835e8:	f9400001 	ldr	x1, [x0]
   835ec:	f94017e0 	ldr	x0, [sp, #40]
   835f0:	f9000001 	str	x1, [x0]
    *end = *begin + read_bigendian(&devicetree_ptr->totalsize);
   835f4:	f94017e0 	ldr	x0, [sp, #40]
   835f8:	f9400013 	ldr	x19, [x0]
   835fc:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83600:	9129c000 	add	x0, x0, #0xa70
   83604:	f9400000 	ldr	x0, [x0]
   83608:	91001000 	add	x0, x0, #0x4
   8360c:	97ffffad 	bl	834c0 <read_bigendian>
   83610:	2a0003e0 	mov	w0, w0
   83614:	8b000261 	add	x1, x19, x0
   83618:	f94013e0 	ldr	x0, [sp, #32]
   8361c:	f9000001 	str	x1, [x0]
    return 0;
   83620:	52800000 	mov	w0, #0x0                   	// #0
}
   83624:	f9400bf3 	ldr	x19, [sp, #16]
   83628:	a8c37bfd 	ldp	x29, x30, [sp], #48
   8362c:	d65f03c0 	ret

0000000000083630 <fdt_traverse_mem_reserve>:

int fdt_traverse_mem_reserve(int (*callback)(unsigned long long, unsigned long long)){
   83630:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   83634:	910003fd 	mov	x29, sp
   83638:	f9000fe0 	str	x0, [sp, #24]
    char* dt_addr = (char*) devicetree_ptr;
   8363c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83640:	9129c000 	add	x0, x0, #0xa70
   83644:	f9400000 	ldr	x0, [x0]
   83648:	f90023e0 	str	x0, [sp, #64]
    char* dt_mem_reserve_addr = dt_addr + read_bigendian(&(devicetree_ptr->off_mem_rsvmap));
   8364c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83650:	9129c000 	add	x0, x0, #0xa70
   83654:	f9400000 	ldr	x0, [x0]
   83658:	91004000 	add	x0, x0, #0x10
   8365c:	97ffff99 	bl	834c0 <read_bigendian>
   83660:	2a0003e0 	mov	w0, w0
   83664:	f94023e1 	ldr	x1, [sp, #64]
   83668:	8b000020 	add	x0, x1, x0
   8366c:	f9001fe0 	str	x0, [sp, #56]
    struct fdt_reserve_entry *ptr = (struct fdt_reserve_entry*) dt_mem_reserve_addr;
   83670:	f9401fe0 	ldr	x0, [sp, #56]
   83674:	f90027e0 	str	x0, [sp, #72]
    while(1){
        unsigned long long addr = read_bigendian64(&(ptr->address));
   83678:	f94027e0 	ldr	x0, [sp, #72]
   8367c:	97ffffad 	bl	83530 <read_bigendian64>
   83680:	f9001be0 	str	x0, [sp, #48]
        unsigned long long size = read_bigendian64(&(ptr->size));
   83684:	f94027e0 	ldr	x0, [sp, #72]
   83688:	91002000 	add	x0, x0, #0x8
   8368c:	97ffffa9 	bl	83530 <read_bigendian64>
   83690:	f90017e0 	str	x0, [sp, #40]
        if(addr == 0 && size == 0)
   83694:	f9401be0 	ldr	x0, [sp, #48]
   83698:	f100001f 	cmp	x0, #0x0
   8369c:	54000081 	b.ne	836ac <fdt_traverse_mem_reserve+0x7c>  // b.any
   836a0:	f94017e0 	ldr	x0, [sp, #40]
   836a4:	f100001f 	cmp	x0, #0x0
   836a8:	54000120 	b.eq	836cc <fdt_traverse_mem_reserve+0x9c>  // b.none
            break;
        callback(addr, size);
   836ac:	f9400fe2 	ldr	x2, [sp, #24]
   836b0:	f94017e1 	ldr	x1, [sp, #40]
   836b4:	f9401be0 	ldr	x0, [sp, #48]
   836b8:	d63f0040 	blr	x2
        ptr++;
   836bc:	f94027e0 	ldr	x0, [sp, #72]
   836c0:	91004000 	add	x0, x0, #0x10
   836c4:	f90027e0 	str	x0, [sp, #72]
    while(1){
   836c8:	17ffffec 	b	83678 <fdt_traverse_mem_reserve+0x48>
            break;
   836cc:	d503201f 	nop
    }
    return 0;
   836d0:	52800000 	mov	w0, #0x0                   	// #0
}
   836d4:	a8c57bfd 	ldp	x29, x30, [sp], #80
   836d8:	d65f03c0 	ret

00000000000836dc <fdt_traverse>:

int fdt_traverse(int (*fdt_callback)(char *, char *, char *, unsigned int)){
   836dc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   836e0:	910003fd 	mov	x29, sp
   836e4:	f9000fe0 	str	x0, [sp, #24]
    char* dt_addr = (char *)devicetree_ptr;
   836e8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   836ec:	9129c000 	add	x0, x0, #0xa70
   836f0:	f9400000 	ldr	x0, [x0]
   836f4:	f90027e0 	str	x0, [sp, #72]
    char* dt_struct_addr =
        dt_addr + read_bigendian(&(devicetree_ptr->off_dt_struct));
   836f8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   836fc:	9129c000 	add	x0, x0, #0xa70
   83700:	f9400000 	ldr	x0, [x0]
   83704:	91002000 	add	x0, x0, #0x8
   83708:	97ffff6e 	bl	834c0 <read_bigendian>
   8370c:	2a0003e0 	mov	w0, w0
    char* dt_struct_addr =
   83710:	f94027e1 	ldr	x1, [sp, #72]
   83714:	8b000020 	add	x0, x1, x0
   83718:	f90023e0 	str	x0, [sp, #64]
    char* dt_strings_addr =
        dt_addr + read_bigendian(&(devicetree_ptr->off_dt_strings));
   8371c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83720:	9129c000 	add	x0, x0, #0xa70
   83724:	f9400000 	ldr	x0, [x0]
   83728:	91003000 	add	x0, x0, #0xc
   8372c:	97ffff65 	bl	834c0 <read_bigendian>
   83730:	2a0003e0 	mov	w0, w0
    char* dt_strings_addr =
   83734:	f94027e1 	ldr	x1, [sp, #72]
   83738:	8b000020 	add	x0, x1, x0
   8373c:	f9001fe0 	str	x0, [sp, #56]
    
    char* ptr = dt_struct_addr;
   83740:	f94023e0 	ldr	x0, [sp, #64]
   83744:	f9002fe0 	str	x0, [sp, #88]
    char* nodename;
    while(1){

        unsigned int token = read_bigendian((unsigned int*) ptr);
   83748:	f9402fe0 	ldr	x0, [sp, #88]
   8374c:	97ffff5d 	bl	834c0 <read_bigendian>
   83750:	b90037e0 	str	w0, [sp, #52]
        ptr += 4;
   83754:	f9402fe0 	ldr	x0, [sp, #88]
   83758:	91001000 	add	x0, x0, #0x4
   8375c:	f9002fe0 	str	x0, [sp, #88]
        
        if(token == FDT_BEGIN_NODE){
   83760:	b94037e0 	ldr	w0, [sp, #52]
   83764:	7100041f 	cmp	w0, #0x1
   83768:	54000161 	b.ne	83794 <fdt_traverse+0xb8>  // b.any
            nodename = ptr;
   8376c:	f9402fe0 	ldr	x0, [sp, #88]
   83770:	f9002be0 	str	x0, [sp, #80]
            ptr = fdt_align(ptr, m_strlen(nodename) + 1);
   83774:	f9402be0 	ldr	x0, [sp, #80]
   83778:	97fffa36 	bl	82050 <m_strlen>
   8377c:	11000400 	add	w0, w0, #0x1
   83780:	2a0003e1 	mov	w1, w0
   83784:	f9402fe0 	ldr	x0, [sp, #88]
   83788:	97ffff36 	bl	83460 <fdt_align>
   8378c:	f9002fe0 	str	x0, [sp, #88]
   83790:	17ffffee 	b	83748 <fdt_traverse+0x6c>
        }
        else if(token == FDT_PROP){
   83794:	b94037e0 	ldr	w0, [sp, #52]
   83798:	71000c1f 	cmp	w0, #0x3
   8379c:	54000401 	b.ne	8381c <fdt_traverse+0x140>  // b.any
            unsigned int proplen = read_bigendian((unsigned int*) ptr);
   837a0:	f9402fe0 	ldr	x0, [sp, #88]
   837a4:	97ffff47 	bl	834c0 <read_bigendian>
   837a8:	b90033e0 	str	w0, [sp, #48]
            ptr += 4;
   837ac:	f9402fe0 	ldr	x0, [sp, #88]
   837b0:	91001000 	add	x0, x0, #0x4
   837b4:	f9002fe0 	str	x0, [sp, #88]
            char *propname = dt_strings_addr + read_bigendian((unsigned int*) ptr);
   837b8:	f9402fe0 	ldr	x0, [sp, #88]
   837bc:	97ffff41 	bl	834c0 <read_bigendian>
   837c0:	2a0003e0 	mov	w0, w0
   837c4:	f9401fe1 	ldr	x1, [sp, #56]
   837c8:	8b000020 	add	x0, x1, x0
   837cc:	f90017e0 	str	x0, [sp, #40]
            ptr += 4;
   837d0:	f9402fe0 	ldr	x0, [sp, #88]
   837d4:	91001000 	add	x0, x0, #0x4
   837d8:	f9002fe0 	str	x0, [sp, #88]
            char *propvalue = ptr;
   837dc:	f9402fe0 	ldr	x0, [sp, #88]
   837e0:	f90013e0 	str	x0, [sp, #32]
            ptr = fdt_align(ptr, proplen);
   837e4:	b94033e0 	ldr	w0, [sp, #48]
   837e8:	2a0003e1 	mov	w1, w0
   837ec:	f9402fe0 	ldr	x0, [sp, #88]
   837f0:	97ffff1c 	bl	83460 <fdt_align>
   837f4:	f9002fe0 	str	x0, [sp, #88]
            if(0 == fdt_callback(nodename, propname, propvalue, proplen)) break;
   837f8:	f9400fe4 	ldr	x4, [sp, #24]
   837fc:	b94033e3 	ldr	w3, [sp, #48]
   83800:	f94013e2 	ldr	x2, [sp, #32]
   83804:	f94017e1 	ldr	x1, [sp, #40]
   83808:	f9402be0 	ldr	x0, [sp, #80]
   8380c:	d63f0080 	blr	x4
   83810:	7100001f 	cmp	w0, #0x0
   83814:	54fff9a1 	b.ne	83748 <fdt_traverse+0x6c>  // b.any
   83818:	14000016 	b	83870 <fdt_traverse+0x194>
        }
        else if(token == FDT_END_NODE)
   8381c:	b94037e0 	ldr	w0, [sp, #52]
   83820:	7100081f 	cmp	w0, #0x2
   83824:	540001c0 	b.eq	8385c <fdt_traverse+0x180>  // b.none
            continue;
        else if(token == FDT_NOP)
   83828:	b94037e0 	ldr	w0, [sp, #52]
   8382c:	7100101f 	cmp	w0, #0x4
   83830:	540001a0 	b.eq	83864 <fdt_traverse+0x188>  // b.none
            continue;
        else if(token == FDT_END)
   83834:	b94037e0 	ldr	w0, [sp, #52]
   83838:	7100241f 	cmp	w0, #0x9
   8383c:	54000180 	b.eq	8386c <fdt_traverse+0x190>  // b.none
            break;
        else {
            uart_printf("%s:%d Device Tree: Unknown tag.\n", __FILE__, __LINE__);
   83840:	52800c82 	mov	w2, #0x64                  	// #100
   83844:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83848:	912c0001 	add	x1, x0, #0xb00
   8384c:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83850:	912c6000 	add	x0, x0, #0xb18
   83854:	97fffd67 	bl	82df0 <uart_printf>
            break;
   83858:	14000006 	b	83870 <fdt_traverse+0x194>
            continue;
   8385c:	d503201f 	nop
   83860:	17ffffba 	b	83748 <fdt_traverse+0x6c>
            continue;
   83864:	d503201f 	nop
    while(1){
   83868:	17ffffb8 	b	83748 <fdt_traverse+0x6c>
            break;
   8386c:	d503201f 	nop
        }
    }
    return 0;
   83870:	52800000 	mov	w0, #0x0                   	// #0
}
   83874:	a8c67bfd 	ldp	x29, x30, [sp], #96
   83878:	d65f03c0 	ret

000000000008387c <get_cpu_time>:

/**
 * get_cpu_time() - Return cpu time in second
*/
uint64_t get_cpu_time(){
    return timer_period_cnt/TIMER_FREQUENCY;
   8387c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83880:	9129e000 	add	x0, x0, #0xa78
   83884:	f9400001 	ldr	x1, [x0]
   83888:	b201e3e0 	mov	x0, #0x8888888888888888    	// #-8608480567731124088
   8388c:	f2911120 	movk	x0, #0x8889
   83890:	9bc07c20 	umulh	x0, x1, x0
   83894:	d345fc00 	lsr	x0, x0, #5
}
   83898:	d65f03c0 	ret

000000000008389c <print_cpu_time>:

void print_cpu_time(){
   8389c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   838a0:	910003fd 	mov	x29, sp
    uart_printf("CPU Time: %d sec\n", get_cpu_time());
   838a4:	97fffff6 	bl	8387c <get_cpu_time>
   838a8:	aa0003e1 	mov	x1, x0
   838ac:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   838b0:	912d0000 	add	x0, x0, #0xb40
   838b4:	97fffd4f 	bl	82df0 <uart_printf>
}
   838b8:	d503201f 	nop
   838bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
   838c0:	d65f03c0 	ret

00000000000838c4 <timer_init>:

void timer_init(){
   838c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   838c8:	910003fd 	mov	x29, sp
    timer_period_cnt = 0;
   838cc:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   838d0:	9129e000 	add	x0, x0, #0xa78
   838d4:	f900001f 	str	xzr, [x0]
    timer_period = get_cpu_frequency()/TIMER_FREQUENCY;
   838d8:	94000a22 	bl	86160 <get_cpu_frequency>
   838dc:	aa0003e1 	mov	x1, x0
   838e0:	b201e3e0 	mov	x0, #0x8888888888888888    	// #-8608480567731124088
   838e4:	f2911120 	movk	x0, #0x8889
   838e8:	9bc07c20 	umulh	x0, x1, x0
   838ec:	d345fc01 	lsr	x1, x0, #5
   838f0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   838f4:	912a0000 	add	x0, x0, #0xa80
   838f8:	f9000001 	str	x1, [x0]
    set_core_timer(1);
   838fc:	52800020 	mov	w0, #0x1                   	// #1
   83900:	94000a1e 	bl	86178 <set_core_timer>
    set_timer_expired(timer_period);
   83904:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83908:	912a0000 	add	x0, x0, #0xa80
   8390c:	f9400000 	ldr	x0, [x0]
   83910:	94000a16 	bl	86168 <set_timer_expired>
}
   83914:	d503201f 	nop
   83918:	a8c17bfd 	ldp	x29, x30, [sp], #16
   8391c:	d65f03c0 	ret

0000000000083920 <timer_handler>:

void timer_handler(){
   83920:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   83924:	910003fd 	mov	x29, sp
    timer_period_cnt++;
   83928:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8392c:	9129e000 	add	x0, x0, #0xa78
   83930:	f9400000 	ldr	x0, [x0]
   83934:	91000401 	add	x1, x0, #0x1
   83938:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8393c:	9129e000 	add	x0, x0, #0xa78
   83940:	f9000001 	str	x1, [x0]
    while(timer_st && timer_st->callback && timer_period_cnt >= timer_st->periods){
   83944:	1400001e 	b	839bc <timer_handler+0x9c>
        timer_st->callback(timer_st->arg);
   83948:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8394c:	912a2000 	add	x0, x0, #0xa88
   83950:	f9400000 	ldr	x0, [x0]
   83954:	f9400401 	ldr	x1, [x0, #8]
   83958:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8395c:	912a2000 	add	x0, x0, #0xa88
   83960:	f9400000 	ldr	x0, [x0]
   83964:	f9400c00 	ldr	x0, [x0, #24]
   83968:	d63f0020 	blr	x1
        timer_st->periods = -1;
   8396c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83970:	912a2000 	add	x0, x0, #0xa88
   83974:	f9400000 	ldr	x0, [x0]
   83978:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
   8397c:	f9000001 	str	x1, [x0]
        timer_st->callback = 0;
   83980:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83984:	912a2000 	add	x0, x0, #0xa88
   83988:	f9400000 	ldr	x0, [x0]
   8398c:	f900041f 	str	xzr, [x0, #8]
        timer_st->arg = 0;
   83990:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83994:	912a2000 	add	x0, x0, #0xa88
   83998:	f9400000 	ldr	x0, [x0]
   8399c:	f9000c1f 	str	xzr, [x0, #24]
        timer_st = timer_st->next;
   839a0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839a4:	912a2000 	add	x0, x0, #0xa88
   839a8:	f9400000 	ldr	x0, [x0]
   839ac:	f9400801 	ldr	x1, [x0, #16]
   839b0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839b4:	912a2000 	add	x0, x0, #0xa88
   839b8:	f9000001 	str	x1, [x0]
    while(timer_st && timer_st->callback && timer_period_cnt >= timer_st->periods){
   839bc:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839c0:	912a2000 	add	x0, x0, #0xa88
   839c4:	f9400000 	ldr	x0, [x0]
   839c8:	f100001f 	cmp	x0, #0x0
   839cc:	54000200 	b.eq	83a0c <timer_handler+0xec>  // b.none
   839d0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839d4:	912a2000 	add	x0, x0, #0xa88
   839d8:	f9400000 	ldr	x0, [x0]
   839dc:	f9400400 	ldr	x0, [x0, #8]
   839e0:	f100001f 	cmp	x0, #0x0
   839e4:	54000140 	b.eq	83a0c <timer_handler+0xec>  // b.none
   839e8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839ec:	912a2000 	add	x0, x0, #0xa88
   839f0:	f9400000 	ldr	x0, [x0]
   839f4:	f9400001 	ldr	x1, [x0]
   839f8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   839fc:	9129e000 	add	x0, x0, #0xa78
   83a00:	f9400000 	ldr	x0, [x0]
   83a04:	eb00003f 	cmp	x1, x0
   83a08:	54fffa09 	b.ls	83948 <timer_handler+0x28>  // b.plast
    }
    set_timer_expired(timer_period);
   83a0c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83a10:	912a0000 	add	x0, x0, #0xa80
   83a14:	f9400000 	ldr	x0, [x0]
   83a18:	940009d4 	bl	86168 <set_timer_expired>
    return;
   83a1c:	d503201f 	nop
}
   83a20:	a8c17bfd 	ldp	x29, x30, [sp], #16
   83a24:	d65f03c0 	ret

0000000000083a28 <timer_add>:

int timer_add(unsigned long sec, void (* callback)(void *), void* arg){
   83a28:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   83a2c:	910003fd 	mov	x29, sp
   83a30:	f90017e0 	str	x0, [sp, #40]
   83a34:	f90013e1 	str	x1, [sp, #32]
   83a38:	f9000fe2 	str	x2, [sp, #24]
    timer *t = 0;
   83a3c:	f9002fff 	str	xzr, [sp, #88]
    for(int i=0; i<TIMER_POOL_SIZE; ++i){
   83a40:	b90057ff 	str	wzr, [sp, #84]
   83a44:	14000027 	b	83ae0 <timer_add+0xb8>
        if(timer_pool[i].callback == 0){
   83a48:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83a4c:	f9445c01 	ldr	x1, [x0, #2232]
   83a50:	b98057e0 	ldrsw	x0, [sp, #84]
   83a54:	d37be800 	lsl	x0, x0, #5
   83a58:	8b000020 	add	x0, x1, x0
   83a5c:	f9400400 	ldr	x0, [x0, #8]
   83a60:	f100001f 	cmp	x0, #0x0
   83a64:	54000381 	b.ne	83ad4 <timer_add+0xac>  // b.any
            t = &timer_pool[i];
   83a68:	b98057e0 	ldrsw	x0, [sp, #84]
   83a6c:	d37be801 	lsl	x1, x0, #5
   83a70:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83a74:	f9445c00 	ldr	x0, [x0, #2232]
   83a78:	8b000020 	add	x0, x1, x0
   83a7c:	f9002fe0 	str	x0, [sp, #88]
            t->callback = callback;
   83a80:	f9402fe0 	ldr	x0, [sp, #88]
   83a84:	f94013e1 	ldr	x1, [sp, #32]
   83a88:	f9000401 	str	x1, [x0, #8]
            t->periods = timer_period_cnt + sec * TIMER_FREQUENCY;
   83a8c:	f94017e1 	ldr	x1, [sp, #40]
   83a90:	aa0103e0 	mov	x0, x1
   83a94:	d37cec00 	lsl	x0, x0, #4
   83a98:	cb010000 	sub	x0, x0, x1
   83a9c:	d37ef400 	lsl	x0, x0, #2
   83aa0:	aa0003e1 	mov	x1, x0
   83aa4:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83aa8:	9129e000 	add	x0, x0, #0xa78
   83aac:	f9400000 	ldr	x0, [x0]
   83ab0:	8b000021 	add	x1, x1, x0
   83ab4:	f9402fe0 	ldr	x0, [sp, #88]
   83ab8:	f9000001 	str	x1, [x0]
            t->arg = arg;
   83abc:	f9402fe0 	ldr	x0, [sp, #88]
   83ac0:	f9400fe1 	ldr	x1, [sp, #24]
   83ac4:	f9000c01 	str	x1, [x0, #24]
            t->next = 0;
   83ac8:	f9402fe0 	ldr	x0, [sp, #88]
   83acc:	f900081f 	str	xzr, [x0, #16]
            break;
   83ad0:	14000007 	b	83aec <timer_add+0xc4>
    for(int i=0; i<TIMER_POOL_SIZE; ++i){
   83ad4:	b94057e0 	ldr	w0, [sp, #84]
   83ad8:	11000400 	add	w0, w0, #0x1
   83adc:	b90057e0 	str	w0, [sp, #84]
   83ae0:	b94057e0 	ldr	w0, [sp, #84]
   83ae4:	71001c1f 	cmp	w0, #0x7
   83ae8:	54fffb0d 	b.le	83a48 <timer_add+0x20>
        }
    }
    if(t == 0){
   83aec:	f9402fe0 	ldr	x0, [sp, #88]
   83af0:	f100001f 	cmp	x0, #0x0
   83af4:	54000161 	b.ne	83b20 <timer_add+0xf8>  // b.any
        debug("timer_pool is full"); // timer_pool is full
   83af8:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83afc:	912f8003 	add	x3, x0, #0xbe0
   83b00:	52800802 	mov	w2, #0x40                  	// #64
   83b04:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83b08:	912d6001 	add	x1, x0, #0xb58
   83b0c:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83b10:	912da000 	add	x0, x0, #0xb68
   83b14:	97fffcb7 	bl	82df0 <uart_printf>
        return -1;
   83b18:	12800000 	mov	w0, #0xffffffff            	// #-1
   83b1c:	14000065 	b	83cb0 <timer_add+0x288>
    }

    // if there is no timer, replace timer_st
    if(!timer_st || !timer_st->callback){
   83b20:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83b24:	912a2000 	add	x0, x0, #0xa88
   83b28:	f9400000 	ldr	x0, [x0]
   83b2c:	f100001f 	cmp	x0, #0x0
   83b30:	540000e0 	b.eq	83b4c <timer_add+0x124>  // b.none
   83b34:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83b38:	912a2000 	add	x0, x0, #0xa88
   83b3c:	f9400000 	ldr	x0, [x0]
   83b40:	f9400400 	ldr	x0, [x0, #8]
   83b44:	f100001f 	cmp	x0, #0x0
   83b48:	540000e1 	b.ne	83b64 <timer_add+0x13c>  // b.any
        timer_st = t;
   83b4c:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83b50:	912a2000 	add	x0, x0, #0xa88
   83b54:	f9402fe1 	ldr	x1, [sp, #88]
   83b58:	f9000001 	str	x1, [x0]
        return 0;
   83b5c:	52800000 	mov	w0, #0x0                   	// #0
   83b60:	14000054 	b	83cb0 <timer_add+0x288>
    }

    // insert new timer 
    timer *head = timer_st;
   83b64:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83b68:	912a2000 	add	x0, x0, #0xa88
   83b6c:	f9400000 	ldr	x0, [x0]
   83b70:	f90027e0 	str	x0, [sp, #72]
    while(head && head->callback){
   83b74:	1400003f 	b	83c70 <timer_add+0x248>
        if(head->periods > t->periods){
   83b78:	f94027e0 	ldr	x0, [sp, #72]
   83b7c:	f9400001 	ldr	x1, [x0]
   83b80:	f9402fe0 	ldr	x0, [sp, #88]
   83b84:	f9400000 	ldr	x0, [x0]
   83b88:	eb00003f 	cmp	x1, x0
   83b8c:	54000509 	b.ls	83c2c <timer_add+0x204>  // b.plast
            // swap and insert between head and head->next
            unsigned long tmp_period = t->periods;
   83b90:	f9402fe0 	ldr	x0, [sp, #88]
   83b94:	f9400000 	ldr	x0, [x0]
   83b98:	f90023e0 	str	x0, [sp, #64]
            void (* tmp_callback) = t->callback;
   83b9c:	f9402fe0 	ldr	x0, [sp, #88]
   83ba0:	f9400400 	ldr	x0, [x0, #8]
   83ba4:	f9001fe0 	str	x0, [sp, #56]
            void *tmp_arg = t->arg;
   83ba8:	f9402fe0 	ldr	x0, [sp, #88]
   83bac:	f9400c00 	ldr	x0, [x0, #24]
   83bb0:	f9001be0 	str	x0, [sp, #48]
            t->periods = head->periods;
   83bb4:	f94027e0 	ldr	x0, [sp, #72]
   83bb8:	f9400001 	ldr	x1, [x0]
   83bbc:	f9402fe0 	ldr	x0, [sp, #88]
   83bc0:	f9000001 	str	x1, [x0]
            t->callback = head->callback;
   83bc4:	f94027e0 	ldr	x0, [sp, #72]
   83bc8:	f9400401 	ldr	x1, [x0, #8]
   83bcc:	f9402fe0 	ldr	x0, [sp, #88]
   83bd0:	f9000401 	str	x1, [x0, #8]
            t->next = head->next;
   83bd4:	f94027e0 	ldr	x0, [sp, #72]
   83bd8:	f9400801 	ldr	x1, [x0, #16]
   83bdc:	f9402fe0 	ldr	x0, [sp, #88]
   83be0:	f9000801 	str	x1, [x0, #16]
            t->arg = head->arg;
   83be4:	f94027e0 	ldr	x0, [sp, #72]
   83be8:	f9400c01 	ldr	x1, [x0, #24]
   83bec:	f9402fe0 	ldr	x0, [sp, #88]
   83bf0:	f9000c01 	str	x1, [x0, #24]
            head->periods = tmp_period;
   83bf4:	f94027e0 	ldr	x0, [sp, #72]
   83bf8:	f94023e1 	ldr	x1, [sp, #64]
   83bfc:	f9000001 	str	x1, [x0]
            head->callback = tmp_callback;
   83c00:	f9401fe1 	ldr	x1, [sp, #56]
   83c04:	f94027e0 	ldr	x0, [sp, #72]
   83c08:	f9000401 	str	x1, [x0, #8]
            head->next = t;
   83c0c:	f94027e0 	ldr	x0, [sp, #72]
   83c10:	f9402fe1 	ldr	x1, [sp, #88]
   83c14:	f9000801 	str	x1, [x0, #16]
            head->arg = tmp_arg;
   83c18:	f94027e0 	ldr	x0, [sp, #72]
   83c1c:	f9401be1 	ldr	x1, [sp, #48]
   83c20:	f9000c01 	str	x1, [x0, #24]
            return 0;
   83c24:	52800000 	mov	w0, #0x0                   	// #0
   83c28:	14000022 	b	83cb0 <timer_add+0x288>
        }

        // inset at last element
        if(!head->next || !head->next->callback){
   83c2c:	f94027e0 	ldr	x0, [sp, #72]
   83c30:	f9400800 	ldr	x0, [x0, #16]
   83c34:	f100001f 	cmp	x0, #0x0
   83c38:	540000c0 	b.eq	83c50 <timer_add+0x228>  // b.none
   83c3c:	f94027e0 	ldr	x0, [sp, #72]
   83c40:	f9400800 	ldr	x0, [x0, #16]
   83c44:	f9400400 	ldr	x0, [x0, #8]
   83c48:	f100001f 	cmp	x0, #0x0
   83c4c:	540000c1 	b.ne	83c64 <timer_add+0x23c>  // b.any
            head->next = t;
   83c50:	f94027e0 	ldr	x0, [sp, #72]
   83c54:	f9402fe1 	ldr	x1, [sp, #88]
   83c58:	f9000801 	str	x1, [x0, #16]
            return 0;
   83c5c:	52800000 	mov	w0, #0x0                   	// #0
   83c60:	14000014 	b	83cb0 <timer_add+0x288>
        }
        head = head->next;
   83c64:	f94027e0 	ldr	x0, [sp, #72]
   83c68:	f9400800 	ldr	x0, [x0, #16]
   83c6c:	f90027e0 	str	x0, [sp, #72]
    while(head && head->callback){
   83c70:	f94027e0 	ldr	x0, [sp, #72]
   83c74:	f100001f 	cmp	x0, #0x0
   83c78:	540000a0 	b.eq	83c8c <timer_add+0x264>  // b.none
   83c7c:	f94027e0 	ldr	x0, [sp, #72]
   83c80:	f9400400 	ldr	x0, [x0, #8]
   83c84:	f100001f 	cmp	x0, #0x0
   83c88:	54fff781 	b.ne	83b78 <timer_add+0x150>  // b.any
    }
    debug("Timer unexpected!"); // never go here
   83c8c:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83c90:	912f8003 	add	x3, x0, #0xbe0
   83c94:	52800c82 	mov	w2, #0x64                  	// #100
   83c98:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83c9c:	912d6001 	add	x1, x0, #0xb58
   83ca0:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83ca4:	912ea000 	add	x0, x0, #0xba8
   83ca8:	97fffc52 	bl	82df0 <uart_printf>
    return -1;
   83cac:	12800000 	mov	w0, #0xffffffff            	// #-1
}
   83cb0:	a8c67bfd 	ldp	x29, x30, [sp], #96
   83cb4:	d65f03c0 	ret

0000000000083cb8 <delay_ms>:

void delay_ms(uint64_t ms){
   83cb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83cbc:	910003fd 	mov	x29, sp
   83cc0:	f9000fe0 	str	x0, [sp, #24]
    uint64_t start_cycle = get_cpu_cycles();
   83cc4:	94000923 	bl	86150 <get_cpu_cycles>
   83cc8:	f90017e0 	str	x0, [sp, #40]
    uint64_t end_cycle = start_cycle + get_cpu_frequency()/1000 * ms;
   83ccc:	94000925 	bl	86160 <get_cpu_frequency>
   83cd0:	d343fc01 	lsr	x1, x0, #3
   83cd4:	d29ef9e0 	mov	x0, #0xf7cf                	// #63439
   83cd8:	f2bc6a60 	movk	x0, #0xe353, lsl #16
   83cdc:	f2d374a0 	movk	x0, #0x9ba5, lsl #32
   83ce0:	f2e41880 	movk	x0, #0x20c4, lsl #48
   83ce4:	9bc07c20 	umulh	x0, x1, x0
   83ce8:	d344fc01 	lsr	x1, x0, #4
   83cec:	f9400fe0 	ldr	x0, [sp, #24]
   83cf0:	9b007c20 	mul	x0, x1, x0
   83cf4:	f94017e1 	ldr	x1, [sp, #40]
   83cf8:	8b000020 	add	x0, x1, x0
   83cfc:	f90013e0 	str	x0, [sp, #32]
    while(get_cpu_cycles() < end_cycle);
   83d00:	d503201f 	nop
   83d04:	94000913 	bl	86150 <get_cpu_cycles>
   83d08:	aa0003e1 	mov	x1, x0
   83d0c:	f94013e0 	ldr	x0, [sp, #32]
   83d10:	eb01001f 	cmp	x0, x1
   83d14:	54ffff88 	b.hi	83d04 <delay_ms+0x4c>  // b.pmore
    return ;
   83d18:	d503201f 	nop
   83d1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   83d20:	d65f03c0 	ret

0000000000083d24 <INIT_LIST_HEAD>:
 * initialized node is well defined and safe. But the result of a
 * list_del(_init) on an uninitialized node is undefined (unrelated memory is
 * modified, crashes, ...).
 */
static inline void INIT_LIST_HEAD(struct list_head *head)
{
   83d24:	d10043ff 	sub	sp, sp, #0x10
   83d28:	f90007e0 	str	x0, [sp, #8]
    head->next = head;
   83d2c:	f94007e0 	ldr	x0, [sp, #8]
   83d30:	f94007e1 	ldr	x1, [sp, #8]
   83d34:	f9000401 	str	x1, [x0, #8]
    head->prev = head;
   83d38:	f94007e0 	ldr	x0, [sp, #8]
   83d3c:	f94007e1 	ldr	x1, [sp, #8]
   83d40:	f9000001 	str	x1, [x0]
}
   83d44:	d503201f 	nop
   83d48:	910043ff 	add	sp, sp, #0x10
   83d4c:	d65f03c0 	ret

0000000000083d50 <list_add>:
 * list_add() - Add a list node to the beginning of the list
 * @node: pointer to the new node
 * @head: pointer to the head of the list
 */
static inline void list_add(struct list_head *node, struct list_head *head)
{
   83d50:	d10083ff 	sub	sp, sp, #0x20
   83d54:	f90007e0 	str	x0, [sp, #8]
   83d58:	f90003e1 	str	x1, [sp]
    struct list_head *next = head->next;
   83d5c:	f94003e0 	ldr	x0, [sp]
   83d60:	f9400400 	ldr	x0, [x0, #8]
   83d64:	f9000fe0 	str	x0, [sp, #24]

    next->prev = node;
   83d68:	f9400fe0 	ldr	x0, [sp, #24]
   83d6c:	f94007e1 	ldr	x1, [sp, #8]
   83d70:	f9000001 	str	x1, [x0]
    node->next = next;
   83d74:	f94007e0 	ldr	x0, [sp, #8]
   83d78:	f9400fe1 	ldr	x1, [sp, #24]
   83d7c:	f9000401 	str	x1, [x0, #8]
    node->prev = head;
   83d80:	f94007e0 	ldr	x0, [sp, #8]
   83d84:	f94003e1 	ldr	x1, [sp]
   83d88:	f9000001 	str	x1, [x0]
    head->next = node;
   83d8c:	f94003e0 	ldr	x0, [sp]
   83d90:	f94007e1 	ldr	x1, [sp, #8]
   83d94:	f9000401 	str	x1, [x0, #8]
}
   83d98:	d503201f 	nop
   83d9c:	910083ff 	add	sp, sp, #0x20
   83da0:	d65f03c0 	ret

0000000000083da4 <list_add_tail>:
 * list_add_tail() - Add a list node to the end of the list
 * @node: pointer to the new node
 * @head: pointer to the head of the list
 */
static inline void list_add_tail(struct list_head *node, struct list_head *head)
{
   83da4:	d10083ff 	sub	sp, sp, #0x20
   83da8:	f90007e0 	str	x0, [sp, #8]
   83dac:	f90003e1 	str	x1, [sp]
    struct list_head *prev = head->prev;
   83db0:	f94003e0 	ldr	x0, [sp]
   83db4:	f9400000 	ldr	x0, [x0]
   83db8:	f9000fe0 	str	x0, [sp, #24]

    prev->next = node;
   83dbc:	f9400fe0 	ldr	x0, [sp, #24]
   83dc0:	f94007e1 	ldr	x1, [sp, #8]
   83dc4:	f9000401 	str	x1, [x0, #8]
    node->next = head;
   83dc8:	f94007e0 	ldr	x0, [sp, #8]
   83dcc:	f94003e1 	ldr	x1, [sp]
   83dd0:	f9000401 	str	x1, [x0, #8]
    node->prev = prev;
   83dd4:	f94007e0 	ldr	x0, [sp, #8]
   83dd8:	f9400fe1 	ldr	x1, [sp, #24]
   83ddc:	f9000001 	str	x1, [x0]
    head->prev = node;
   83de0:	f94003e0 	ldr	x0, [sp]
   83de4:	f94007e1 	ldr	x1, [sp, #8]
   83de8:	f9000001 	str	x1, [x0]
}
   83dec:	d503201f 	nop
   83df0:	910083ff 	add	sp, sp, #0x20
   83df4:	d65f03c0 	ret

0000000000083df8 <list_del>:
 * access when the memory behind the next/prev pointer is used after a list_del.
 * This only works on systems which prohibit access to the predefined memory
 * addresses.
 */
static inline void list_del(struct list_head *node)
{
   83df8:	d10083ff 	sub	sp, sp, #0x20
   83dfc:	f90007e0 	str	x0, [sp, #8]
    struct list_head *next = node->next;
   83e00:	f94007e0 	ldr	x0, [sp, #8]
   83e04:	f9400400 	ldr	x0, [x0, #8]
   83e08:	f9000fe0 	str	x0, [sp, #24]
    struct list_head *prev = node->prev;
   83e0c:	f94007e0 	ldr	x0, [sp, #8]
   83e10:	f9400000 	ldr	x0, [x0]
   83e14:	f9000be0 	str	x0, [sp, #16]

    next->prev = prev;
   83e18:	f9400fe0 	ldr	x0, [sp, #24]
   83e1c:	f9400be1 	ldr	x1, [sp, #16]
   83e20:	f9000001 	str	x1, [x0]
    prev->next = next;
   83e24:	f9400be0 	ldr	x0, [sp, #16]
   83e28:	f9400fe1 	ldr	x1, [sp, #24]
   83e2c:	f9000401 	str	x1, [x0, #8]

#ifdef LIST_POISONING
    node->prev = (struct list_head *) (0x00100100);
    node->next = (struct list_head *) (0x00200200);
#endif
}
   83e30:	d503201f 	nop
   83e34:	910083ff 	add	sp, sp, #0x20
   83e38:	d65f03c0 	ret

0000000000083e3c <list_empty>:
 * @head: pointer to the head of the list
 *
 * Return: 0 - list is not empty !0 - list is empty
 */
static inline int list_empty(const struct list_head *head)
{
   83e3c:	d10043ff 	sub	sp, sp, #0x10
   83e40:	f90007e0 	str	x0, [sp, #8]
    return (head->next == head);
   83e44:	f94007e0 	ldr	x0, [sp, #8]
   83e48:	f9400400 	ldr	x0, [x0, #8]
   83e4c:	f94007e1 	ldr	x1, [sp, #8]
   83e50:	eb00003f 	cmp	x1, x0
   83e54:	1a9f17e0 	cset	w0, eq  // eq = none
   83e58:	12001c00 	and	w0, w0, #0xff
}
   83e5c:	910043ff 	add	sp, sp, #0x10
   83e60:	d65f03c0 	ret

0000000000083e64 <get_next_tid>:
struct list_head block_queue;
struct list_head exit_queue;
thread_info* cur_thread;
thread_info* threads[MAX_THREADS];

int32_t get_next_tid(){
   83e64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   83e68:	910003fd 	mov	x29, sp
    for(int i=0; i<MAX_THREADS; ++i)
   83e6c:	b9001fff 	str	wzr, [sp, #28]
   83e70:	1400000c 	b	83ea0 <get_next_tid+0x3c>
        if(threads[i] == NULL) return i; 
   83e74:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83e78:	f9446800 	ldr	x0, [x0, #2256]
   83e7c:	b9801fe1 	ldrsw	x1, [sp, #28]
   83e80:	f8617800 	ldr	x0, [x0, x1, lsl #3]
   83e84:	f100001f 	cmp	x0, #0x0
   83e88:	54000061 	b.ne	83e94 <get_next_tid+0x30>  // b.any
   83e8c:	b9401fe0 	ldr	w0, [sp, #28]
   83e90:	14000010 	b	83ed0 <get_next_tid+0x6c>
    for(int i=0; i<MAX_THREADS; ++i)
   83e94:	b9401fe0 	ldr	w0, [sp, #28]
   83e98:	11000400 	add	w0, w0, #0x1
   83e9c:	b9001fe0 	str	w0, [sp, #28]
   83ea0:	b9401fe0 	ldr	w0, [sp, #28]
   83ea4:	7100fc1f 	cmp	w0, #0x3f
   83ea8:	54fffe6d 	b.le	83e74 <get_next_tid+0x10>
    kprintf("no availiable threads");
   83eac:	d0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   83eb0:	9100c003 	add	x3, x0, #0x30
   83eb4:	528001c2 	mov	w2, #0xe                   	// #14
   83eb8:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83ebc:	912fc001 	add	x1, x0, #0xbf0
   83ec0:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83ec4:	91300000 	add	x0, x0, #0xc00
   83ec8:	97fffbca 	bl	82df0 <uart_printf>
    return -1;
   83ecc:	12800000 	mov	w0, #0xffffffff            	// #-1
}
   83ed0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   83ed4:	d65f03c0 	ret

0000000000083ed8 <thread_schedule>:

void thread_schedule(){
   83ed8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   83edc:	910003fd 	mov	x29, sp
    if(list_empty(&ready_queue)){
   83ee0:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83ee4:	f9446c00 	ldr	x0, [x0, #2264]
   83ee8:	97ffffd5 	bl	83e3c <list_empty>
   83eec:	7100001f 	cmp	w0, #0x0
   83ef0:	54000140 	b.eq	83f18 <thread_schedule+0x40>  // b.none
        kprintf("ready queue is empty\n");
   83ef4:	d0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   83ef8:	91010003 	add	x3, x0, #0x40
   83efc:	52800282 	mov	w2, #0x14                  	// #20
   83f00:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83f04:	912fc001 	add	x1, x0, #0xbf0
   83f08:	b0000020 	adrp	x0, 88000 <load_all_sp+0x18>
   83f0c:	91310000 	add	x0, x0, #0xc40
   83f10:	97fffbb8 	bl	82df0 <uart_printf>
        return ;
   83f14:	14000052 	b	8405c <thread_schedule+0x184>
    }

    // choose next thread
    thread_info* next_thread = list_entry(ready_queue.next, thread_info, node);
   83f18:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f1c:	f9446c00 	ldr	x0, [x0, #2264]
   83f20:	f9400400 	ldr	x0, [x0, #8]
   83f24:	f90017e0 	str	x0, [sp, #40]
   83f28:	f94017e0 	ldr	x0, [sp, #40]
   83f2c:	d102c000 	sub	x0, x0, #0xb0
   83f30:	f90013e0 	str	x0, [sp, #32]
    list_del(&next_thread->node);
   83f34:	f94013e0 	ldr	x0, [sp, #32]
   83f38:	9102c000 	add	x0, x0, #0xb0
   83f3c:	97ffffaf 	bl	83df8 <list_del>

    // place current thread to exit or ready or block
    if(cur_thread->state == RUN){
   83f40:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f44:	f9447400 	ldr	x0, [x0, #2280]
   83f48:	f9400000 	ldr	x0, [x0]
   83f4c:	b940a800 	ldr	w0, [x0, #168]
   83f50:	7100001f 	cmp	w0, #0x0
   83f54:	540001e1 	b.ne	83f90 <thread_schedule+0xb8>  // b.any
        list_add_tail(&cur_thread->node, &ready_queue);
   83f58:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f5c:	f9447400 	ldr	x0, [x0, #2280]
   83f60:	f9400000 	ldr	x0, [x0]
   83f64:	9102c002 	add	x2, x0, #0xb0
   83f68:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f6c:	f9446c01 	ldr	x1, [x0, #2264]
   83f70:	aa0203e0 	mov	x0, x2
   83f74:	97ffff8c 	bl	83da4 <list_add_tail>
        cur_thread->state = READY;
   83f78:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f7c:	f9447400 	ldr	x0, [x0, #2280]
   83f80:	f9400000 	ldr	x0, [x0]
   83f84:	52800021 	mov	w1, #0x1                   	// #1
   83f88:	b900a801 	str	w1, [x0, #168]
   83f8c:	14000014 	b	83fdc <thread_schedule+0x104>
    }
    else if(cur_thread->state == EXIT){
   83f90:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83f94:	f9447400 	ldr	x0, [x0, #2280]
   83f98:	f9400000 	ldr	x0, [x0]
   83f9c:	b940a800 	ldr	w0, [x0, #168]
   83fa0:	71000c1f 	cmp	w0, #0x3
   83fa4:	540001c1 	b.ne	83fdc <thread_schedule+0x104>  // b.any
        list_add_tail(&cur_thread->node, &exit_queue);
   83fa8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83fac:	f9447400 	ldr	x0, [x0, #2280]
   83fb0:	f9400000 	ldr	x0, [x0]
   83fb4:	9102c002 	add	x2, x0, #0xb0
   83fb8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83fbc:	f9447c01 	ldr	x1, [x0, #2296]
   83fc0:	aa0203e0 	mov	x0, x2
   83fc4:	97ffff78 	bl	83da4 <list_add_tail>
        cur_thread->state = EXIT;
   83fc8:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83fcc:	f9447400 	ldr	x0, [x0, #2280]
   83fd0:	f9400000 	ldr	x0, [x0]
   83fd4:	52800061 	mov	w1, #0x3                   	// #3
   83fd8:	b900a801 	str	w1, [x0, #168]
    }

    thread_info* prev_thread = cur_thread;
   83fdc:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83fe0:	f9447400 	ldr	x0, [x0, #2280]
   83fe4:	f9400000 	ldr	x0, [x0]
   83fe8:	f9000fe0 	str	x0, [sp, #24]
    cur_thread = next_thread;
   83fec:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   83ff0:	f9447400 	ldr	x0, [x0, #2280]
   83ff4:	f94013e1 	ldr	x1, [sp, #32]
   83ff8:	f9000001 	str	x1, [x0]
    cur_thread->state = RUN;
   83ffc:	f0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84000:	f9447400 	ldr	x0, [x0, #2280]
   84004:	f9400000 	ldr	x0, [x0]
   84008:	b900a81f 	str	wzr, [x0, #168]
    
    // switch
    kprintf("schedule %x -> %x\n", prev_thread->id, next_thread->id);
   8400c:	f9400fe0 	ldr	x0, [sp, #24]
   84010:	b940a001 	ldr	w1, [x0, #160]
   84014:	f94013e0 	ldr	x0, [sp, #32]
   84018:	b940a000 	ldr	w0, [x0, #160]
   8401c:	2a0003e5 	mov	w5, w0
   84020:	2a0103e4 	mov	w4, w1
   84024:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84028:	91010003 	add	x3, x0, #0x40
   8402c:	52800562 	mov	w2, #0x2b                  	// #43
   84030:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84034:	912fc001 	add	x1, x0, #0xbf0
   84038:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8403c:	91320000 	add	x0, x0, #0xc80
   84040:	97fffb6c 	bl	82df0 <uart_printf>
    switch_to(prev_thread, next_thread, next_thread->id);
   84044:	f94013e0 	ldr	x0, [sp, #32]
   84048:	b940a000 	ldr	w0, [x0, #160]
   8404c:	2a0003e2 	mov	w2, w0
   84050:	f94013e1 	ldr	x1, [sp, #32]
   84054:	f9400fe0 	ldr	x0, [sp, #24]
   84058:	94000fce 	bl	87f90 <switch_to>
}
   8405c:	a8c37bfd 	ldp	x29, x30, [sp], #48
   84060:	d65f03c0 	ret

0000000000084064 <thread_wrapper>:

void thread_wrapper(){
   84064:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   84068:	910003fd 	mov	x29, sp
    branch_el1_to_el0(cur_thread->context, cur_thread->el0_sp);
   8406c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84070:	f9447400 	ldr	x0, [x0, #2280]
   84074:	f9400000 	ldr	x0, [x0]
   84078:	f9403802 	ldr	x2, [x0, #112]
   8407c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84080:	f9447400 	ldr	x0, [x0, #2280]
   84084:	f9400000 	ldr	x0, [x0]
   84088:	f9403400 	ldr	x0, [x0, #104]
   8408c:	aa0003e1 	mov	x1, x0
   84090:	aa0203e0 	mov	x0, x2
   84094:	940009e5 	bl	86828 <branch_el1_to_el0>
    cur_thread->state = EXIT;
   84098:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8409c:	f9447400 	ldr	x0, [x0, #2280]
   840a0:	f9400000 	ldr	x0, [x0]
   840a4:	52800061 	mov	w1, #0x3                   	// #3
   840a8:	b900a801 	str	w1, [x0, #168]
    asm("mov x8, 8");
   840ac:	d2800108 	mov	x8, #0x8                   	// #8
    asm("svc 0");
   840b0:	d4000001 	svc	#0x0
}
   840b4:	d503201f 	nop
   840b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
   840bc:	d65f03c0 	ret

00000000000840c0 <thread_create>:



int thread_create(void *fptr){
   840c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   840c4:	910003fd 	mov	x29, sp
   840c8:	f9000fe0 	str	x0, [sp, #24]
    kprintf(STYLE("not implement yet", FONT_RED));
   840cc:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   840d0:	91014003 	add	x3, x0, #0x50
   840d4:	52800722 	mov	w2, #0x39                  	// #57
   840d8:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   840dc:	912fc001 	add	x1, x0, #0xbf0
   840e0:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   840e4:	91330000 	add	x0, x0, #0xcc0
   840e8:	97fffb42 	bl	82df0 <uart_printf>
    // // set state
    // new_thread->state = READY;
    // list_add_tail(&(new_thread->node), &ready_queue);

    // return new_thread->id;
    return 0;
   840ec:	52800000 	mov	w0, #0x0                   	// #0
}
   840f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   840f4:	d65f03c0 	ret

00000000000840f8 <thread_exit>:

void thread_exit(){
   840f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   840fc:	910003fd 	mov	x29, sp
    cur_thread->state = EXIT;
   84100:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84104:	f9447400 	ldr	x0, [x0, #2280]
   84108:	f9400000 	ldr	x0, [x0]
   8410c:	52800061 	mov	w1, #0x3                   	// #3
   84110:	b900a801 	str	w1, [x0, #168]
    thread_schedule();
   84114:	97ffff71 	bl	83ed8 <thread_schedule>
}
   84118:	d503201f 	nop
   8411c:	a8c17bfd 	ldp	x29, x30, [sp], #16
   84120:	d65f03c0 	ret

0000000000084124 <thread_kill>:

void thread_kill(uint64_t* sp){
   84124:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   84128:	910003fd 	mov	x29, sp
   8412c:	f9000fe0 	str	x0, [sp, #24]
    uint32_t target = sp[0];
   84130:	f9400fe0 	ldr	x0, [sp, #24]
   84134:	f9400000 	ldr	x0, [x0]
   84138:	b9002fe0 	str	w0, [sp, #44]
    if(target >= 64 || threads[target] == NULL)
   8413c:	b9402fe0 	ldr	w0, [sp, #44]
   84140:	7100fc1f 	cmp	w0, #0x3f
   84144:	540000e8 	b.hi	84160 <thread_kill+0x3c>  // b.pmore
   84148:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8414c:	f9446800 	ldr	x0, [x0, #2256]
   84150:	b9402fe1 	ldr	w1, [sp, #44]
   84154:	f8617800 	ldr	x0, [x0, x1, lsl #3]
   84158:	f100001f 	cmp	x0, #0x0
   8415c:	54000161 	b.ne	84188 <thread_kill+0x64>  // b.any
        throw(, "no such thread id %d", target);
   84160:	b9402fe4 	ldr	w4, [sp, #44]
   84164:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84168:	91018003 	add	x3, x0, #0x60
   8416c:	52800c02 	mov	w2, #0x60                  	// #96
   84170:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84174:	912fc001 	add	x1, x0, #0xbf0
   84178:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8417c:	91342000 	add	x0, x0, #0xd08
   84180:	97fffb1c 	bl	82df0 <uart_printf>
   84184:	14000016 	b	841dc <thread_kill+0xb8>
    threads[target]->state = EXIT;
   84188:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8418c:	f9446800 	ldr	x0, [x0, #2256]
   84190:	b9402fe1 	ldr	w1, [sp, #44]
   84194:	f8617800 	ldr	x0, [x0, x1, lsl #3]
   84198:	52800061 	mov	w1, #0x3                   	// #3
   8419c:	b900a801 	str	w1, [x0, #168]
    list_del(&threads[target]->node);
   841a0:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   841a4:	f9446800 	ldr	x0, [x0, #2256]
   841a8:	b9402fe1 	ldr	w1, [sp, #44]
   841ac:	f8617800 	ldr	x0, [x0, x1, lsl #3]
   841b0:	9102c000 	add	x0, x0, #0xb0
   841b4:	97ffff11 	bl	83df8 <list_del>
    list_add_tail(&threads[target]->node, &exit_queue);
   841b8:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   841bc:	f9446800 	ldr	x0, [x0, #2256]
   841c0:	b9402fe1 	ldr	w1, [sp, #44]
   841c4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
   841c8:	9102c002 	add	x2, x0, #0xb0
   841cc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   841d0:	f9447c01 	ldr	x1, [x0, #2296]
   841d4:	aa0203e0 	mov	x0, x2
   841d8:	97fffef3 	bl	83da4 <list_add_tail>
}
   841dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
   841e0:	d65f03c0 	ret

00000000000841e4 <thread_fork_return>:

int thread_fork_return(){
    return 0;
   841e4:	52800000 	mov	w0, #0x0                   	// #0
}
   841e8:	d65f03c0 	ret

00000000000841ec <thread_fork>:

extern void entry_elh_64_sync();


void thread_fork(uint64_t *sp, void *pc){
   841ec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   841f0:	910003fd 	mov	x29, sp
   841f4:	f9000fe0 	str	x0, [sp, #24]
   841f8:	f9000be1 	str	x1, [sp, #16]
    // prepare require date
    int new_id = get_next_tid();
   841fc:	97ffff1a 	bl	83e64 <get_next_tid>
   84200:	b9004fe0 	str	w0, [sp, #76]
    if(new_id < 0) throw(, "thread full");
   84204:	b9404fe0 	ldr	w0, [sp, #76]
   84208:	7100001f 	cmp	w0, #0x0
   8420c:	5400014a 	b.ge	84234 <thread_fork+0x48>  // b.tcont
   84210:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84214:	9101c003 	add	x3, x0, #0x70
   84218:	52800e02 	mov	w2, #0x70                  	// #112
   8421c:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84220:	912fc001 	add	x1, x0, #0xbf0
   84224:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84228:	91352000 	add	x0, x0, #0xd48
   8422c:	97fffaf1 	bl	82df0 <uart_printf>
   84230:	140000d4 	b	84580 <thread_fork+0x394>
    
    thread_info* new_thread = (thread_info*)malloc(sizeof(thread_info));
   84234:	52801800 	mov	w0, #0xc0                  	// #192
   84238:	94000340 	bl	84f38 <malloc>
   8423c:	f90023e0 	str	x0, [sp, #64]
    if(new_thread == NULL) throw(, "malloc out of memory");
   84240:	f94023e0 	ldr	x0, [sp, #64]
   84244:	f100001f 	cmp	x0, #0x0
   84248:	54000141 	b.ne	84270 <thread_fork+0x84>  // b.any
   8424c:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84250:	9101c003 	add	x3, x0, #0x70
   84254:	52800e62 	mov	w2, #0x73                  	// #115
   84258:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8425c:	912fc001 	add	x1, x0, #0xbf0
   84260:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84264:	91360000 	add	x0, x0, #0xd80
   84268:	97fffae2 	bl	82df0 <uart_printf>
   8426c:	140000c5 	b	84580 <thread_fork+0x394>
    
    void* new_stack = mframe_alloc(cur_thread->stack_size);
   84270:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84274:	f9447400 	ldr	x0, [x0, #2280]
   84278:	f9400000 	ldr	x0, [x0]
   8427c:	f9404c00 	ldr	x0, [x0, #152]
   84280:	940004d4 	bl	855d0 <mframe_alloc>
   84284:	f9001fe0 	str	x0, [sp, #56]
    if(new_stack == NULL) throw(, "page out of memeory");
   84288:	f9401fe0 	ldr	x0, [sp, #56]
   8428c:	f100001f 	cmp	x0, #0x0
   84290:	54000141 	b.ne	842b8 <thread_fork+0xcc>  // b.any
   84294:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84298:	9101c003 	add	x3, x0, #0x70
   8429c:	52800ec2 	mov	w2, #0x76                  	// #118
   842a0:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   842a4:	912fc001 	add	x1, x0, #0xbf0
   842a8:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   842ac:	91370000 	add	x0, x0, #0xdc0
   842b0:	97fffad0 	bl	82df0 <uart_printf>
   842b4:	140000b3 	b	84580 <thread_fork+0x394>
    
    void* new_kernel_stack = mframe_alloc(cur_thread->kernel_stack_size);
   842b8:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   842bc:	f9447400 	ldr	x0, [x0, #2280]
   842c0:	f9400000 	ldr	x0, [x0]
   842c4:	f9404400 	ldr	x0, [x0, #136]
   842c8:	940004c2 	bl	855d0 <mframe_alloc>
   842cc:	f9001be0 	str	x0, [sp, #48]
    if(new_kernel_stack == NULL) throw(, "page out of memory free %x", mframe_free(new_stack));
   842d0:	f9401be0 	ldr	x0, [sp, #48]
   842d4:	f100001f 	cmp	x0, #0x0
   842d8:	540001a1 	b.ne	8430c <thread_fork+0x120>  // b.any
   842dc:	f9401fe0 	ldr	x0, [sp, #56]
   842e0:	9400052a 	bl	85788 <mframe_free>
   842e4:	2a0003e4 	mov	w4, w0
   842e8:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   842ec:	9101c003 	add	x3, x0, #0x70
   842f0:	52800f22 	mov	w2, #0x79                  	// #121
   842f4:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   842f8:	912fc001 	add	x1, x0, #0xbf0
   842fc:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84300:	91380000 	add	x0, x0, #0xe00
   84304:	97fffabb 	bl	82df0 <uart_printf>
   84308:	1400009e 	b	84580 <thread_fork+0x394>


    void *sp_el0;
    asm volatile("mrs %0, sp_el0": "=r"(sp_el0));
   8430c:	d5384100 	mrs	x0, sp_el0
   84310:	f90017e0 	str	x0, [sp, #40]
    new_thread->fp =     new_stack + (sp_el0 - cur_thread->stack);
   84314:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84318:	f9447400 	ldr	x0, [x0, #2280]
   8431c:	f9400000 	ldr	x0, [x0]
   84320:	f9404800 	ldr	x0, [x0, #144]
   84324:	f94017e1 	ldr	x1, [sp, #40]
   84328:	cb000020 	sub	x0, x1, x0
   8432c:	aa0003e1 	mov	x1, x0
   84330:	f9401fe0 	ldr	x0, [sp, #56]
   84334:	8b010001 	add	x1, x0, x1
   84338:	f94023e0 	ldr	x0, [sp, #64]
   8433c:	f9002801 	str	x1, [x0, #80]
    new_thread->el0_sp = new_stack + (sp_el0 - cur_thread->stack);
   84340:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84344:	f9447400 	ldr	x0, [x0, #2280]
   84348:	f9400000 	ldr	x0, [x0]
   8434c:	f9404800 	ldr	x0, [x0, #144]
   84350:	f94017e1 	ldr	x1, [sp, #40]
   84354:	cb000020 	sub	x0, x1, x0
   84358:	aa0003e1 	mov	x1, x0
   8435c:	f9401fe0 	ldr	x0, [sp, #56]
   84360:	8b010001 	add	x1, x0, x1
   84364:	f94023e0 	ldr	x0, [sp, #64]
   84368:	f9003401 	str	x1, [x0, #104]

    new_thread->el1_sp = (void*)((uint64_t)new_kernel_stack + (uint64_t)sp - (uint64_t)cur_thread->kernel_stack);
   8436c:	f9401be1 	ldr	x1, [sp, #48]
   84370:	f9400fe0 	ldr	x0, [sp, #24]
   84374:	8b000020 	add	x0, x1, x0
   84378:	d0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   8437c:	f9447421 	ldr	x1, [x1, #2280]
   84380:	f9400021 	ldr	x1, [x1]
   84384:	f9404021 	ldr	x1, [x1, #128]
   84388:	cb010000 	sub	x0, x0, x1
   8438c:	aa0003e1 	mov	x1, x0
   84390:	f94023e0 	ldr	x0, [sp, #64]
   84394:	f9003001 	str	x1, [x0, #96]
    new_thread->context = cur_thread->context;
   84398:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8439c:	f9447400 	ldr	x0, [x0, #2280]
   843a0:	f9400000 	ldr	x0, [x0]
   843a4:	f9403801 	ldr	x1, [x0, #112]
   843a8:	f94023e0 	ldr	x0, [sp, #64]
   843ac:	f9003801 	str	x1, [x0, #112]
    new_thread->context_size = cur_thread->context_size;
   843b0:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   843b4:	f9447400 	ldr	x0, [x0, #2280]
   843b8:	f9400000 	ldr	x0, [x0]
   843bc:	f9403c01 	ldr	x1, [x0, #120]
   843c0:	f94023e0 	ldr	x0, [sp, #64]
   843c4:	f9003c01 	str	x1, [x0, #120]
    new_thread->kernel_stack = new_kernel_stack;
   843c8:	f94023e0 	ldr	x0, [sp, #64]
   843cc:	f9401be1 	ldr	x1, [sp, #48]
   843d0:	f9004001 	str	x1, [x0, #128]
    new_thread->kernel_stack_size = cur_thread->kernel_stack_size;  
   843d4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   843d8:	f9447400 	ldr	x0, [x0, #2280]
   843dc:	f9400000 	ldr	x0, [x0]
   843e0:	f9404401 	ldr	x1, [x0, #136]
   843e4:	f94023e0 	ldr	x0, [sp, #64]
   843e8:	f9004401 	str	x1, [x0, #136]
    new_thread->stack = new_stack;
   843ec:	f94023e0 	ldr	x0, [sp, #64]
   843f0:	f9401fe1 	ldr	x1, [sp, #56]
   843f4:	f9004801 	str	x1, [x0, #144]
    new_thread->stack_size = cur_thread->stack_size;
   843f8:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   843fc:	f9447400 	ldr	x0, [x0, #2280]
   84400:	f9400000 	ldr	x0, [x0]
   84404:	f9404c01 	ldr	x1, [x0, #152]
   84408:	f94023e0 	ldr	x0, [sp, #64]
   8440c:	f9004c01 	str	x1, [x0, #152]


    new_thread->id = new_id;
   84410:	b9404fe1 	ldr	w1, [sp, #76]
   84414:	f94023e0 	ldr	x0, [sp, #64]
   84418:	b900a001 	str	w1, [x0, #160]
    new_thread->parent = cur_thread->id;
   8441c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84420:	f9447400 	ldr	x0, [x0, #2280]
   84424:	f9400000 	ldr	x0, [x0]
   84428:	b940a001 	ldr	w1, [x0, #160]
   8442c:	f94023e0 	ldr	x0, [sp, #64]
   84430:	b900a401 	str	w1, [x0, #164]
    new_thread->state = READY;
   84434:	f94023e0 	ldr	x0, [sp, #64]
   84438:	52800021 	mov	w1, #0x1                   	// #1
   8443c:	b900a801 	str	w1, [x0, #168]

    // access global data;
    threads[new_thread->id] = new_thread;
   84440:	f94023e0 	ldr	x0, [sp, #64]
   84444:	b940a001 	ldr	w1, [x0, #160]
   84448:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8444c:	f9446800 	ldr	x0, [x0, #2256]
   84450:	2a0103e1 	mov	w1, w1
   84454:	f94023e2 	ldr	x2, [sp, #64]
   84458:	f8217802 	str	x2, [x0, x1, lsl #3]
    list_add(&new_thread->node, &ready_queue);
   8445c:	f94023e0 	ldr	x0, [sp, #64]
   84460:	9102c002 	add	x2, x0, #0xb0
   84464:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84468:	f9446c01 	ldr	x1, [x0, #2264]
   8446c:	aa0203e0 	mov	x0, x2
   84470:	97fffe38 	bl	83d50 <list_add>

    // for mother thread return child id
    sp[0] = new_thread->id;
   84474:	f94023e0 	ldr	x0, [sp, #64]
   84478:	b940a000 	ldr	w0, [x0, #160]
   8447c:	2a0003e1 	mov	w1, w0
   84480:	f9400fe0 	ldr	x0, [sp, #24]
   84484:	f9000001 	str	x1, [x0]
    kprintf("fork return sp: %x, sp[0]: %x\n", sp, sp[0]);
   84488:	f9400fe0 	ldr	x0, [sp, #24]
   8448c:	f9400000 	ldr	x0, [x0]
   84490:	aa0003e5 	mov	x5, x0
   84494:	f9400fe4 	ldr	x4, [sp, #24]
   84498:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   8449c:	9101c003 	add	x3, x0, #0x70
   844a0:	52801282 	mov	w2, #0x94                  	// #148
   844a4:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   844a8:	912fc001 	add	x1, x0, #0xbf0
   844ac:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   844b0:	91392000 	add	x0, x0, #0xe48
   844b4:	97fffa4f 	bl	82df0 <uart_printf>

    memcopy(cur_thread->x19_28, new_thread->x19_28, sizeof(new_thread->x19_28));
   844b8:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   844bc:	f9447400 	ldr	x0, [x0, #2280]
   844c0:	f9400000 	ldr	x0, [x0]
   844c4:	aa0003e3 	mov	x3, x0
   844c8:	f94023e0 	ldr	x0, [sp, #64]
   844cc:	d2800a02 	mov	x2, #0x50                  	// #80
   844d0:	aa0003e1 	mov	x1, x0
   844d4:	aa0303e0 	mov	x0, x3
   844d8:	940002a4 	bl	84f68 <memcopy>
    memcopy(cur_thread->stack, new_thread->stack, cur_thread->stack_size);
   844dc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   844e0:	f9447400 	ldr	x0, [x0, #2280]
   844e4:	f9400000 	ldr	x0, [x0]
   844e8:	f9404803 	ldr	x3, [x0, #144]
   844ec:	f94023e0 	ldr	x0, [sp, #64]
   844f0:	f9404801 	ldr	x1, [x0, #144]
   844f4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   844f8:	f9447400 	ldr	x0, [x0, #2280]
   844fc:	f9400000 	ldr	x0, [x0]
   84500:	f9404c00 	ldr	x0, [x0, #152]
   84504:	aa0003e2 	mov	x2, x0
   84508:	aa0303e0 	mov	x0, x3
   8450c:	94000297 	bl	84f68 <memcopy>
    memcopy(cur_thread->kernel_stack, new_thread->kernel_stack, cur_thread->kernel_stack_size);
   84510:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84514:	f9447400 	ldr	x0, [x0, #2280]
   84518:	f9400000 	ldr	x0, [x0]
   8451c:	f9404003 	ldr	x3, [x0, #128]
   84520:	f94023e0 	ldr	x0, [sp, #64]
   84524:	f9404001 	ldr	x1, [x0, #128]
   84528:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8452c:	f9447400 	ldr	x0, [x0, #2280]
   84530:	f9400000 	ldr	x0, [x0]
   84534:	f9404400 	ldr	x0, [x0, #136]
   84538:	aa0003e2 	mov	x2, x0
   8453c:	aa0303e0 	mov	x0, x3
   84540:	9400028a 	bl	84f68 <memcopy>

    // for child thread return 0
    *(uint64_t *)(new_thread->kernel_stack + ((void*)sp - cur_thread->kernel_stack)) = 0;
   84544:	f94023e0 	ldr	x0, [sp, #64]
   84548:	f9404000 	ldr	x0, [x0, #128]
   8454c:	d0000021 	adrp	x1, 8a000 <__func__.3228+0x710>
   84550:	f9447421 	ldr	x1, [x1, #2280]
   84554:	f9400021 	ldr	x1, [x1]
   84558:	f9404021 	ldr	x1, [x1, #128]
   8455c:	f9400fe2 	ldr	x2, [sp, #24]
   84560:	cb010041 	sub	x1, x2, x1
   84564:	8b010000 	add	x0, x0, x1
   84568:	f900001f 	str	xzr, [x0]
    

    // decide next pc child thread run 
    new_thread->lr = pc+8;
   8456c:	f9400be0 	ldr	x0, [sp, #16]
   84570:	91002001 	add	x1, x0, #0x8
   84574:	f94023e0 	ldr	x0, [sp, #64]
   84578:	f9002c01 	str	x1, [x0, #88]
    thread_schedule();
   8457c:	97fffe57 	bl	83ed8 <thread_schedule>
}
   84580:	a8c57bfd 	ldp	x29, x30, [sp], #80
   84584:	d65f03c0 	ret

0000000000084588 <thread_exec>:

void thread_exec(cpio_path path){
   84588:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8458c:	910003fd 	mov	x29, sp
   84590:	f9000bf3 	str	x19, [sp, #16]
   84594:	aa0003f3 	mov	x19, x0
    if(cur_thread->context_size < path.filesize * 2)
   84598:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8459c:	f9447400 	ldr	x0, [x0, #2280]
   845a0:	f9400000 	ldr	x0, [x0]
   845a4:	f9403c01 	ldr	x1, [x0, #120]
   845a8:	f9400e60 	ldr	x0, [x19, #24]
   845ac:	d37ff800 	lsl	x0, x0, #1
   845b0:	eb00003f 	cmp	x1, x0
   845b4:	54000142 	b.cs	845dc <thread_exec+0x54>  // b.hs, b.nlast
        throw(,"the program is too large to exec");   
   845b8:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   845bc:	91020003 	add	x3, x0, #0x80
   845c0:	528014a2 	mov	w2, #0xa5                  	// #165
   845c4:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   845c8:	912fc001 	add	x1, x0, #0xbf0
   845cc:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   845d0:	913a4000 	add	x0, x0, #0xe90
   845d4:	97fffa07 	bl	82df0 <uart_printf>
   845d8:	14000036 	b	846b0 <thread_exec+0x128>
    cur_thread->fp = cur_thread->stack + cur_thread->stack_size;
   845dc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   845e0:	f9447400 	ldr	x0, [x0, #2280]
   845e4:	f9400000 	ldr	x0, [x0]
   845e8:	f9404802 	ldr	x2, [x0, #144]
   845ec:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   845f0:	f9447400 	ldr	x0, [x0, #2280]
   845f4:	f9400000 	ldr	x0, [x0]
   845f8:	f9404c01 	ldr	x1, [x0, #152]
   845fc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84600:	f9447400 	ldr	x0, [x0, #2280]
   84604:	f9400000 	ldr	x0, [x0]
   84608:	8b010041 	add	x1, x2, x1
   8460c:	f9002801 	str	x1, [x0, #80]
    cur_thread->lr = thread_wrapper;
   84610:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84614:	f9447400 	ldr	x0, [x0, #2280]
   84618:	f9400000 	ldr	x0, [x0]
   8461c:	90000001 	adrp	x1, 84000 <thread_schedule+0x128>
   84620:	91019021 	add	x1, x1, #0x64
   84624:	f9002c01 	str	x1, [x0, #88]
    cur_thread->el1_sp = cur_thread->kernel_stack + cur_thread->kernel_stack_size;
   84628:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8462c:	f9447400 	ldr	x0, [x0, #2280]
   84630:	f9400000 	ldr	x0, [x0]
   84634:	f9404002 	ldr	x2, [x0, #128]
   84638:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8463c:	f9447400 	ldr	x0, [x0, #2280]
   84640:	f9400000 	ldr	x0, [x0]
   84644:	f9404401 	ldr	x1, [x0, #136]
   84648:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8464c:	f9447400 	ldr	x0, [x0, #2280]
   84650:	f9400000 	ldr	x0, [x0]
   84654:	8b010041 	add	x1, x2, x1
   84658:	f9003001 	str	x1, [x0, #96]
    cur_thread->el0_sp = cur_thread->stack + cur_thread->stack_size;
   8465c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84660:	f9447400 	ldr	x0, [x0, #2280]
   84664:	f9400000 	ldr	x0, [x0]
   84668:	f9404802 	ldr	x2, [x0, #144]
   8466c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84670:	f9447400 	ldr	x0, [x0, #2280]
   84674:	f9400000 	ldr	x0, [x0]
   84678:	f9404c01 	ldr	x1, [x0, #152]
   8467c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84680:	f9447400 	ldr	x0, [x0, #2280]
   84684:	f9400000 	ldr	x0, [x0]
   84688:	8b010041 	add	x1, x2, x1
   8468c:	f9003401 	str	x1, [x0, #104]

    kprintf(STYLE("no implement yet", FONT_RED));
   84690:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84694:	91020003 	add	x3, x0, #0x80
   84698:	52801562 	mov	w2, #0xab                  	// #171
   8469c:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   846a0:	912fc001 	add	x1, x0, #0xbf0
   846a4:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   846a8:	913b6000 	add	x0, x0, #0xed8
   846ac:	97fff9d1 	bl	82df0 <uart_printf>
}
   846b0:	f9400bf3 	ldr	x19, [sp, #16]
   846b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   846b8:	d65f03c0 	ret

00000000000846bc <kernel_load>:

int kernel_load(cpio_path path){
   846bc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   846c0:	910003fd 	mov	x29, sp
   846c4:	a90153f3 	stp	x19, x20, [sp, #16]
   846c8:	aa0003f3 	mov	x19, x0
    // allocate memory 
    uint32_t new_tid = get_next_tid();
   846cc:	97fffde6 	bl	83e64 <get_next_tid>
   846d0:	b9005fe0 	str	w0, [sp, #92]
    if(new_tid < 0) throw(-1, "no tid available");

    size_t context_size = path.filesize << 2;
   846d4:	f9400e60 	ldr	x0, [x19, #24]
   846d8:	d37ef400 	lsl	x0, x0, #2
   846dc:	f9002be0 	str	x0, [sp, #80]
    void* context = mframe_alloc(context_size);
   846e0:	f9402be0 	ldr	x0, [sp, #80]
   846e4:	940003bb 	bl	855d0 <mframe_alloc>
   846e8:	f90027e0 	str	x0, [sp, #72]
    if(context == NULL) throw(-1, "page out of memory");
   846ec:	f94027e0 	ldr	x0, [sp, #72]
   846f0:	f100001f 	cmp	x0, #0x0
   846f4:	54000161 	b.ne	84720 <kernel_load+0x64>  // b.any
   846f8:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   846fc:	91024003 	add	x3, x0, #0x90
   84700:	528016a2 	mov	w2, #0xb5                  	// #181
   84704:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84708:	912fc001 	add	x1, x0, #0xbf0
   8470c:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84710:	913c6000 	add	x0, x0, #0xf18
   84714:	97fff9b7 	bl	82df0 <uart_printf>
   84718:	12800000 	mov	w0, #0xffffffff            	// #-1
   8471c:	1400008e 	b	84954 <kernel_load+0x298>

    size_t stack_size = context_size;
   84720:	f9402be0 	ldr	x0, [sp, #80]
   84724:	f90023e0 	str	x0, [sp, #64]
    void* stack = mframe_alloc(stack_size);
   84728:	f94023e0 	ldr	x0, [sp, #64]
   8472c:	940003a9 	bl	855d0 <mframe_alloc>
   84730:	f9001fe0 	str	x0, [sp, #56]
    if(stack == NULL) throw(-1, "page out of memory, free %x", mframe_free(context));
   84734:	f9401fe0 	ldr	x0, [sp, #56]
   84738:	f100001f 	cmp	x0, #0x0
   8473c:	540001c1 	b.ne	84774 <kernel_load+0xb8>  // b.any
   84740:	f94027e0 	ldr	x0, [sp, #72]
   84744:	94000411 	bl	85788 <mframe_free>
   84748:	2a0003e4 	mov	w4, w0
   8474c:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84750:	91024003 	add	x3, x0, #0x90
   84754:	52801722 	mov	w2, #0xb9                  	// #185
   84758:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8475c:	912fc001 	add	x1, x0, #0xbf0
   84760:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84764:	913d6000 	add	x0, x0, #0xf58
   84768:	97fff9a2 	bl	82df0 <uart_printf>
   8476c:	12800000 	mov	w0, #0xffffffff            	// #-1
   84770:	14000079 	b	84954 <kernel_load+0x298>

    size_t kernel_stack_size = PAGE_SIZE;
   84774:	d2820000 	mov	x0, #0x1000                	// #4096
   84778:	f9001be0 	str	x0, [sp, #48]
    void* kernel_stack = mframe_alloc(kernel_stack_size); 
   8477c:	f9401be0 	ldr	x0, [sp, #48]
   84780:	94000394 	bl	855d0 <mframe_alloc>
   84784:	f90017e0 	str	x0, [sp, #40]
    if(kernel_stack == NULL) throw(-1, "page out of memory free %x %x", mframe_free(context), mframe_free(stack));
   84788:	f94017e0 	ldr	x0, [sp, #40]
   8478c:	f100001f 	cmp	x0, #0x0
   84790:	54000241 	b.ne	847d8 <kernel_load+0x11c>  // b.any
   84794:	f94027e0 	ldr	x0, [sp, #72]
   84798:	940003fc 	bl	85788 <mframe_free>
   8479c:	2a0003f3 	mov	w19, w0
   847a0:	f9401fe0 	ldr	x0, [sp, #56]
   847a4:	940003f9 	bl	85788 <mframe_free>
   847a8:	2a0003e5 	mov	w5, w0
   847ac:	2a1303e4 	mov	w4, w19
   847b0:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   847b4:	91024003 	add	x3, x0, #0x90
   847b8:	528017a2 	mov	w2, #0xbd                  	// #189
   847bc:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   847c0:	912fc001 	add	x1, x0, #0xbf0
   847c4:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   847c8:	913e8000 	add	x0, x0, #0xfa0
   847cc:	97fff989 	bl	82df0 <uart_printf>
   847d0:	12800000 	mov	w0, #0xffffffff            	// #-1
   847d4:	14000060 	b	84954 <kernel_load+0x298>

    thread_info* new_thread = (thread_info*)malloc(sizeof(thread_info));
   847d8:	52801800 	mov	w0, #0xc0                  	// #192
   847dc:	940001d7 	bl	84f38 <malloc>
   847e0:	f90013e0 	str	x0, [sp, #32]
    if(new_thread == NULL) throw(-1, "heap out of memory, free %x %x", mframe_free(context), mframe_free(stack), mframe_free(kernel_stack));
   847e4:	f94013e0 	ldr	x0, [sp, #32]
   847e8:	f100001f 	cmp	x0, #0x0
   847ec:	540002c1 	b.ne	84844 <kernel_load+0x188>  // b.any
   847f0:	f94027e0 	ldr	x0, [sp, #72]
   847f4:	940003e5 	bl	85788 <mframe_free>
   847f8:	2a0003f3 	mov	w19, w0
   847fc:	f9401fe0 	ldr	x0, [sp, #56]
   84800:	940003e2 	bl	85788 <mframe_free>
   84804:	2a0003f4 	mov	w20, w0
   84808:	f94017e0 	ldr	x0, [sp, #40]
   8480c:	940003df 	bl	85788 <mframe_free>
   84810:	2a0003e6 	mov	w6, w0
   84814:	2a1403e5 	mov	w5, w20
   84818:	2a1303e4 	mov	w4, w19
   8481c:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84820:	91024003 	add	x3, x0, #0x90
   84824:	52801802 	mov	w2, #0xc0                  	// #192
   84828:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   8482c:	912fc001 	add	x1, x0, #0xbf0
   84830:	90000020 	adrp	x0, 88000 <load_all_sp+0x18>
   84834:	913fa000 	add	x0, x0, #0xfe8
   84838:	97fff96e 	bl	82df0 <uart_printf>
   8483c:	12800000 	mov	w0, #0xffffffff            	// #-1
   84840:	14000045 	b	84954 <kernel_load+0x298>

    // setting up thread
    new_thread->fp = stack + stack_size;
   84844:	f9401fe1 	ldr	x1, [sp, #56]
   84848:	f94023e0 	ldr	x0, [sp, #64]
   8484c:	8b000021 	add	x1, x1, x0
   84850:	f94013e0 	ldr	x0, [sp, #32]
   84854:	f9002801 	str	x1, [x0, #80]
    new_thread->lr = thread_wrapper;
   84858:	f94013e0 	ldr	x0, [sp, #32]
   8485c:	90000001 	adrp	x1, 84000 <thread_schedule+0x128>
   84860:	91019021 	add	x1, x1, #0x64
   84864:	f9002c01 	str	x1, [x0, #88]
    new_thread->el1_sp = kernel_stack + kernel_stack_size;
   84868:	f94017e1 	ldr	x1, [sp, #40]
   8486c:	f9401be0 	ldr	x0, [sp, #48]
   84870:	8b000021 	add	x1, x1, x0
   84874:	f94013e0 	ldr	x0, [sp, #32]
   84878:	f9003001 	str	x1, [x0, #96]
    new_thread->el0_sp = stack + stack_size;
   8487c:	f9401fe1 	ldr	x1, [sp, #56]
   84880:	f94023e0 	ldr	x0, [sp, #64]
   84884:	8b000021 	add	x1, x1, x0
   84888:	f94013e0 	ldr	x0, [sp, #32]
   8488c:	f9003401 	str	x1, [x0, #104]
    new_thread->context = context;
   84890:	f94013e0 	ldr	x0, [sp, #32]
   84894:	f94027e1 	ldr	x1, [sp, #72]
   84898:	f9003801 	str	x1, [x0, #112]
    new_thread->context_size = context_size;
   8489c:	f94013e0 	ldr	x0, [sp, #32]
   848a0:	f9402be1 	ldr	x1, [sp, #80]
   848a4:	f9003c01 	str	x1, [x0, #120]
    new_thread->kernel_stack = kernel_stack;
   848a8:	f94013e0 	ldr	x0, [sp, #32]
   848ac:	f94017e1 	ldr	x1, [sp, #40]
   848b0:	f9004001 	str	x1, [x0, #128]
    new_thread->kernel_stack_size = kernel_stack_size;
   848b4:	f94013e0 	ldr	x0, [sp, #32]
   848b8:	f9401be1 	ldr	x1, [sp, #48]
   848bc:	f9004401 	str	x1, [x0, #136]
    new_thread->stack = stack;
   848c0:	f94013e0 	ldr	x0, [sp, #32]
   848c4:	f9401fe1 	ldr	x1, [sp, #56]
   848c8:	f9004801 	str	x1, [x0, #144]
    new_thread->stack_size = stack_size;
   848cc:	f94013e0 	ldr	x0, [sp, #32]
   848d0:	f94023e1 	ldr	x1, [sp, #64]
   848d4:	f9004c01 	str	x1, [x0, #152]
    new_thread->id = new_tid;
   848d8:	f94013e0 	ldr	x0, [sp, #32]
   848dc:	b9405fe1 	ldr	w1, [sp, #92]
   848e0:	b900a001 	str	w1, [x0, #160]
    new_thread->parent = new_tid;
   848e4:	f94013e0 	ldr	x0, [sp, #32]
   848e8:	b9405fe1 	ldr	w1, [sp, #92]
   848ec:	b900a401 	str	w1, [x0, #164]
    new_thread->state = READY;
   848f0:	f94013e0 	ldr	x0, [sp, #32]
   848f4:	52800021 	mov	w1, #0x1                   	// #1
   848f8:	b900a801 	str	w1, [x0, #168]

    memcopy(path.data, new_thread->context, path.filesize);
   848fc:	f9400663 	ldr	x3, [x19, #8]
   84900:	f94013e0 	ldr	x0, [sp, #32]
   84904:	f9403800 	ldr	x0, [x0, #112]
   84908:	f9400e61 	ldr	x1, [x19, #24]
   8490c:	aa0103e2 	mov	x2, x1
   84910:	aa0003e1 	mov	x1, x0
   84914:	aa0303e0 	mov	x0, x3
   84918:	94000194 	bl	84f68 <memcopy>

    threads[new_thread->id] = new_thread;
   8491c:	f94013e0 	ldr	x0, [sp, #32]
   84920:	b940a001 	ldr	w1, [x0, #160]
   84924:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84928:	f9446800 	ldr	x0, [x0, #2256]
   8492c:	2a0103e1 	mov	w1, w1
   84930:	f94013e2 	ldr	x2, [sp, #32]
   84934:	f8217802 	str	x2, [x0, x1, lsl #3]
    list_add(&new_thread->node, &ready_queue);
   84938:	f94013e0 	ldr	x0, [sp, #32]
   8493c:	9102c002 	add	x2, x0, #0xb0
   84940:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84944:	f9446c01 	ldr	x1, [x0, #2264]
   84948:	aa0203e0 	mov	x0, x2
   8494c:	97fffd01 	bl	83d50 <list_add>

    return 0;
   84950:	52800000 	mov	w0, #0x0                   	// #0
}
   84954:	a94153f3 	ldp	x19, x20, [sp, #16]
   84958:	a8c67bfd 	ldp	x29, x30, [sp], #96
   8495c:	d65f03c0 	ret

0000000000084960 <thread_init>:



int thread_init(){
   84960:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   84964:	910003fd 	mov	x29, sp
    INIT_LIST_HEAD(&ready_queue);
   84968:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8496c:	f9446c00 	ldr	x0, [x0, #2264]
   84970:	97fffced 	bl	83d24 <INIT_LIST_HEAD>
    INIT_LIST_HEAD(&block_queue);
   84974:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84978:	f9446000 	ldr	x0, [x0, #2240]
   8497c:	97fffcea 	bl	83d24 <INIT_LIST_HEAD>
    INIT_LIST_HEAD(&exit_queue);
   84980:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84984:	f9447c00 	ldr	x0, [x0, #2296]
   84988:	97fffce7 	bl	83d24 <INIT_LIST_HEAD>
    
    // kernel thread
    cur_thread = (thread_info*)malloc(sizeof(thread_info));
   8498c:	52801800 	mov	w0, #0xc0                  	// #192
   84990:	9400016a 	bl	84f38 <malloc>
   84994:	aa0003e1 	mov	x1, x0
   84998:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8499c:	f9447400 	ldr	x0, [x0, #2280]
   849a0:	f9000001 	str	x1, [x0]
    cur_thread->id = 0;
   849a4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   849a8:	f9447400 	ldr	x0, [x0, #2280]
   849ac:	f9400000 	ldr	x0, [x0]
   849b0:	b900a01f 	str	wzr, [x0, #160]
    threads[0] = cur_thread;
   849b4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   849b8:	f9447400 	ldr	x0, [x0, #2280]
   849bc:	f9400001 	ldr	x1, [x0]
   849c0:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   849c4:	f9446800 	ldr	x0, [x0, #2256]
   849c8:	f9000001 	str	x1, [x0]
    cur_thread->state = RUN;
   849cc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   849d0:	f9447400 	ldr	x0, [x0, #2280]
   849d4:	f9400000 	ldr	x0, [x0]
   849d8:	b900a81f 	str	wzr, [x0, #168]

    return 0;
   849dc:	52800000 	mov	w0, #0x0                   	// #0
}
   849e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
   849e4:	d65f03c0 	ret

00000000000849e8 <cpio_fdt_callback>:
#include "initramfs.h"

char *CPIO_ADDR = 0;

int cpio_fdt_callback(char *nodename, char *propname, char *propvalue, unsigned int proplen){
   849e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   849ec:	910003fd 	mov	x29, sp
   849f0:	f90017e0 	str	x0, [sp, #40]
   849f4:	f90013e1 	str	x1, [sp, #32]
   849f8:	f9000fe2 	str	x2, [sp, #24]
   849fc:	b90017e3 	str	w3, [sp, #20]
    if(m_strcmp(propname, "linux,initrd-start\0") || m_strcmp(nodename, "chosen\0"))
   84a00:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84a04:	91028001 	add	x1, x0, #0xa0
   84a08:	f94013e0 	ldr	x0, [sp, #32]
   84a0c:	97fff5a2 	bl	82094 <m_strcmp>
   84a10:	7100001f 	cmp	w0, #0x0
   84a14:	540000e1 	b.ne	84a30 <cpio_fdt_callback+0x48>  // b.any
   84a18:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84a1c:	9102e001 	add	x1, x0, #0xb8
   84a20:	f94017e0 	ldr	x0, [sp, #40]
   84a24:	97fff59c 	bl	82094 <m_strcmp>
   84a28:	7100001f 	cmp	w0, #0x0
   84a2c:	54000060 	b.eq	84a38 <cpio_fdt_callback+0x50>  // b.none
        return -1;
   84a30:	12800000 	mov	w0, #0xffffffff            	// #-1
   84a34:	14000009 	b	84a58 <cpio_fdt_callback+0x70>
    CPIO_ADDR = (char *)(long)read_bigendian((unsigned int *)propvalue); 
   84a38:	f9400fe0 	ldr	x0, [sp, #24]
   84a3c:	97fffaa1 	bl	834c0 <read_bigendian>
   84a40:	2a0003e0 	mov	w0, w0
   84a44:	aa0003e1 	mov	x1, x0
   84a48:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84a4c:	912a4000 	add	x0, x0, #0xa90
   84a50:	f9000001 	str	x1, [x0]
    return 0;
   84a54:	52800000 	mov	w0, #0x0                   	// #0
}
   84a58:	a8c37bfd 	ldp	x29, x30, [sp], #48
   84a5c:	d65f03c0 	ret

0000000000084a60 <cpio_get_start_addr>:

int cpio_get_start_addr(char **addr){
   84a60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   84a64:	910003fd 	mov	x29, sp
   84a68:	f9000fe0 	str	x0, [sp, #24]
    if(CPIO_ADDR == 0)
   84a6c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84a70:	912a4000 	add	x0, x0, #0xa90
   84a74:	f9400000 	ldr	x0, [x0]
   84a78:	f100001f 	cmp	x0, #0x0
   84a7c:	54000081 	b.ne	84a8c <cpio_get_start_addr+0x2c>  // b.any
        fdt_traverse(cpio_fdt_callback);
   84a80:	90000000 	adrp	x0, 84000 <thread_schedule+0x128>
   84a84:	9127a000 	add	x0, x0, #0x9e8
   84a88:	97fffb15 	bl	836dc <fdt_traverse>
    *addr = CPIO_ADDR;
   84a8c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84a90:	912a4000 	add	x0, x0, #0xa90
   84a94:	f9400001 	ldr	x1, [x0]
   84a98:	f9400fe0 	ldr	x0, [sp, #24]
   84a9c:	f9000001 	str	x1, [x0]
    return 0;
   84aa0:	52800000 	mov	w0, #0x0                   	// #0
}
   84aa4:	a8c27bfd 	ldp	x29, x30, [sp], #32
   84aa8:	d65f03c0 	ret

0000000000084aac <cpio_align_filename>:

char* cpio_align_filename(char* addr){
   84aac:	d10043ff 	sub	sp, sp, #0x10
   84ab0:	f90007e0 	str	x0, [sp, #8]
    return addr + sizeof(cpio_newc_header);
   84ab4:	f94007e0 	ldr	x0, [sp, #8]
   84ab8:	9101b800 	add	x0, x0, #0x6e
}
   84abc:	910043ff 	add	sp, sp, #0x10
   84ac0:	d65f03c0 	ret

0000000000084ac4 <cpio_align_filedata>:

char* cpio_align_filedata(char* filename, int namesize){
   84ac4:	d10043ff 	sub	sp, sp, #0x10
   84ac8:	f90007e0 	str	x0, [sp, #8]
   84acc:	b90007e1 	str	w1, [sp, #4]
    return filename + 2 + ((namesize-2+3)/4)*4;
   84ad0:	b94007e0 	ldr	w0, [sp, #4]
   84ad4:	11000400 	add	w0, w0, #0x1
   84ad8:	11000c01 	add	w1, w0, #0x3
   84adc:	7100001f 	cmp	w0, #0x0
   84ae0:	1a80b020 	csel	w0, w1, w0, lt  // lt = tstop
   84ae4:	13027c00 	asr	w0, w0, #2
   84ae8:	531e7400 	lsl	w0, w0, #2
   84aec:	93407c00 	sxtw	x0, w0
   84af0:	91000800 	add	x0, x0, #0x2
   84af4:	f94007e1 	ldr	x1, [sp, #8]
   84af8:	8b000020 	add	x0, x1, x0
}
   84afc:	910043ff 	add	sp, sp, #0x10
   84b00:	d65f03c0 	ret

0000000000084b04 <cpio_align_nextfile>:

char* cpio_align_nextfile(char* filedata, int datasize){
   84b04:	d10043ff 	sub	sp, sp, #0x10
   84b08:	f90007e0 	str	x0, [sp, #8]
   84b0c:	b90007e1 	str	w1, [sp, #4]
    return filedata + ((datasize+3)/4)*4;
   84b10:	b94007e0 	ldr	w0, [sp, #4]
   84b14:	11000c00 	add	w0, w0, #0x3
   84b18:	11000c01 	add	w1, w0, #0x3
   84b1c:	7100001f 	cmp	w0, #0x0
   84b20:	1a80b020 	csel	w0, w1, w0, lt  // lt = tstop
   84b24:	13027c00 	asr	w0, w0, #2
   84b28:	531e7400 	lsl	w0, w0, #2
   84b2c:	93407c00 	sxtw	x0, w0
   84b30:	f94007e1 	ldr	x1, [sp, #8]
   84b34:	8b000020 	add	x0, x1, x0
}
   84b38:	910043ff 	add	sp, sp, #0x10
   84b3c:	d65f03c0 	ret

0000000000084b40 <cpio_parse>:

int cpio_parse(cpio_path* path){
   84b40:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
   84b44:	910003fd 	mov	x29, sp
   84b48:	f9000fe0 	str	x0, [sp, #24]
    char* addr = path->next;
   84b4c:	f9400fe0 	ldr	x0, [sp, #24]
   84b50:	f9401400 	ldr	x0, [x0, #40]
   84b54:	f90033e0 	str	x0, [sp, #96]
    if(addr == 0) return -1;
   84b58:	f94033e0 	ldr	x0, [sp, #96]
   84b5c:	f100001f 	cmp	x0, #0x0
   84b60:	54000061 	b.ne	84b6c <cpio_parse+0x2c>  // b.any
   84b64:	12800000 	mov	w0, #0xffffffff            	// #-1
   84b68:	14000060 	b	84ce8 <cpio_parse+0x1a8>
    
    cpio_newc_header* ptr = (cpio_newc_header *)addr;
   84b6c:	f94033e0 	ldr	x0, [sp, #96]
   84b70:	f9002fe0 	str	x0, [sp, #88]
    char magic[] = "070701\0";    
   84b74:	d286e600 	mov	x0, #0x3730                	// #14128
   84b78:	f2a6e600 	movk	x0, #0x3730, lsl #16
   84b7c:	f2c62600 	movk	x0, #0x3130, lsl #32
   84b80:	f90027e0 	str	x0, [sp, #72]
    for(int i=0; i<6; ++i)
   84b84:	b9006fff 	str	wzr, [sp, #108]
   84b88:	1400000e 	b	84bc0 <cpio_parse+0x80>
        if(ptr->c_magic[i] != magic[i]) return -1;
   84b8c:	f9402fe1 	ldr	x1, [sp, #88]
   84b90:	b9806fe0 	ldrsw	x0, [sp, #108]
   84b94:	38606821 	ldrb	w1, [x1, x0]
   84b98:	b9806fe0 	ldrsw	x0, [sp, #108]
   84b9c:	910123e2 	add	x2, sp, #0x48
   84ba0:	38606840 	ldrb	w0, [x2, x0]
   84ba4:	6b00003f 	cmp	w1, w0
   84ba8:	54000060 	b.eq	84bb4 <cpio_parse+0x74>  // b.none
   84bac:	12800000 	mov	w0, #0xffffffff            	// #-1
   84bb0:	1400004e 	b	84ce8 <cpio_parse+0x1a8>
    for(int i=0; i<6; ++i)
   84bb4:	b9406fe0 	ldr	w0, [sp, #108]
   84bb8:	11000400 	add	w0, w0, #0x1
   84bbc:	b9006fe0 	str	w0, [sp, #108]
   84bc0:	b9406fe0 	ldr	w0, [sp, #108]
   84bc4:	7100141f 	cmp	w0, #0x5
   84bc8:	54fffe2d 	b.le	84b8c <cpio_parse+0x4c>
    
    char c_namesize[9];
    char c_filesize[9];
    for(int i=0; i<8; ++i){
   84bcc:	b9006bff 	str	wzr, [sp, #104]
   84bd0:	14000012 	b	84c18 <cpio_parse+0xd8>
        c_namesize[i] = ptr->c_namesize[i];
   84bd4:	f9402fe1 	ldr	x1, [sp, #88]
   84bd8:	b9806be0 	ldrsw	x0, [sp, #104]
   84bdc:	8b000020 	add	x0, x1, x0
   84be0:	39417802 	ldrb	w2, [x0, #94]
   84be4:	b9806be0 	ldrsw	x0, [sp, #104]
   84be8:	9100e3e1 	add	x1, sp, #0x38
   84bec:	38206822 	strb	w2, [x1, x0]
        c_filesize[i] = ptr->c_filesize[i];
   84bf0:	f9402fe1 	ldr	x1, [sp, #88]
   84bf4:	b9806be0 	ldrsw	x0, [sp, #104]
   84bf8:	8b000020 	add	x0, x1, x0
   84bfc:	3940d802 	ldrb	w2, [x0, #54]
   84c00:	b9806be0 	ldrsw	x0, [sp, #104]
   84c04:	9100a3e1 	add	x1, sp, #0x28
   84c08:	38206822 	strb	w2, [x1, x0]
    for(int i=0; i<8; ++i){
   84c0c:	b9406be0 	ldr	w0, [sp, #104]
   84c10:	11000400 	add	w0, w0, #0x1
   84c14:	b9006be0 	str	w0, [sp, #104]
   84c18:	b9406be0 	ldr	w0, [sp, #104]
   84c1c:	71001c1f 	cmp	w0, #0x7
   84c20:	54fffdad 	b.le	84bd4 <cpio_parse+0x94>
    }
    c_namesize[8] = '\0';
   84c24:	390103ff 	strb	wzr, [sp, #64]
    c_filesize[8] = '\0';
   84c28:	3900c3ff 	strb	wzr, [sp, #48]
    int namesize = m_htoi(c_namesize);
   84c2c:	9100e3e0 	add	x0, sp, #0x38
   84c30:	97fff575 	bl	82204 <m_htoi>
   84c34:	b90057e0 	str	w0, [sp, #84]
    int filesize = m_htoi(c_filesize);
   84c38:	9100a3e0 	add	x0, sp, #0x28
   84c3c:	97fff572 	bl	82204 <m_htoi>
   84c40:	b90053e0 	str	w0, [sp, #80]
    path->name = cpio_align_filename(addr);
   84c44:	f94033e0 	ldr	x0, [sp, #96]
   84c48:	97ffff99 	bl	84aac <cpio_align_filename>
   84c4c:	aa0003e1 	mov	x1, x0
   84c50:	f9400fe0 	ldr	x0, [sp, #24]
   84c54:	f9000001 	str	x1, [x0]
    path->mode = ptr->c_mode[4];
   84c58:	f9402fe0 	ldr	x0, [sp, #88]
   84c5c:	39404800 	ldrb	w0, [x0, #18]
   84c60:	2a0003e1 	mov	w1, w0
   84c64:	f9400fe0 	ldr	x0, [sp, #24]
   84c68:	b9002001 	str	w1, [x0, #32]
    path->data = cpio_align_filedata(path->name, namesize);
   84c6c:	f9400fe0 	ldr	x0, [sp, #24]
   84c70:	f9400000 	ldr	x0, [x0]
   84c74:	b94057e1 	ldr	w1, [sp, #84]
   84c78:	97ffff93 	bl	84ac4 <cpio_align_filedata>
   84c7c:	aa0003e1 	mov	x1, x0
   84c80:	f9400fe0 	ldr	x0, [sp, #24]
   84c84:	f9000401 	str	x1, [x0, #8]
    path->next = cpio_align_nextfile(path->data, filesize);
   84c88:	f9400fe0 	ldr	x0, [sp, #24]
   84c8c:	f9400400 	ldr	x0, [x0, #8]
   84c90:	b94053e1 	ldr	w1, [sp, #80]
   84c94:	97ffff9c 	bl	84b04 <cpio_align_nextfile>
   84c98:	aa0003e1 	mov	x1, x0
   84c9c:	f9400fe0 	ldr	x0, [sp, #24]
   84ca0:	f9001401 	str	x1, [x0, #40]
    path->namesize = namesize;
   84ca4:	b98057e1 	ldrsw	x1, [sp, #84]
   84ca8:	f9400fe0 	ldr	x0, [sp, #24]
   84cac:	f9000801 	str	x1, [x0, #16]
    path->filesize = filesize;
   84cb0:	b98053e1 	ldrsw	x1, [sp, #80]
   84cb4:	f9400fe0 	ldr	x0, [sp, #24]
   84cb8:	f9000c01 	str	x1, [x0, #24]
    if(0 == m_strcmp(path->name, "TRAILER!!!\0"))
   84cbc:	f9400fe0 	ldr	x0, [sp, #24]
   84cc0:	f9400002 	ldr	x2, [x0]
   84cc4:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84cc8:	91030001 	add	x1, x0, #0xc0
   84ccc:	aa0203e0 	mov	x0, x2
   84cd0:	97fff4f1 	bl	82094 <m_strcmp>
   84cd4:	7100001f 	cmp	w0, #0x0
   84cd8:	54000061 	b.ne	84ce4 <cpio_parse+0x1a4>  // b.any
        return -1;
   84cdc:	12800000 	mov	w0, #0xffffffff            	// #-1
   84ce0:	14000002 	b	84ce8 <cpio_parse+0x1a8>
    return 0;
   84ce4:	52800000 	mov	w0, #0x0                   	// #0
}
   84ce8:	a8c77bfd 	ldp	x29, x30, [sp], #112
   84cec:	d65f03c0 	ret

0000000000084cf0 <cpio_search>:

cpio_path cpio_search(char* pathname){
   84cf0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
   84cf4:	910003fd 	mov	x29, sp
   84cf8:	f9000bf3 	str	x19, [sp, #16]
   84cfc:	aa0803f3 	mov	x19, x8
   84d00:	f90017e0 	str	x0, [sp, #40]
    cpio_path path;
    cpio_get_start_addr(&path.next);
   84d04:	9100c3e0 	add	x0, sp, #0x30
   84d08:	9100a000 	add	x0, x0, #0x28
   84d0c:	97ffff55 	bl	84a60 <cpio_get_start_addr>
    
    while(0 == cpio_parse(&path)){
   84d10:	14000010 	b	84d50 <cpio_search+0x60>
        if(0 == m_strcmp(pathname, path.name))
   84d14:	f9401be0 	ldr	x0, [sp, #48]
   84d18:	aa0003e1 	mov	x1, x0
   84d1c:	f94017e0 	ldr	x0, [sp, #40]
   84d20:	97fff4dd 	bl	82094 <m_strcmp>
   84d24:	7100001f 	cmp	w0, #0x0
   84d28:	54000141 	b.ne	84d50 <cpio_search+0x60>  // b.any
            return path;
   84d2c:	aa1303e1 	mov	x1, x19
   84d30:	9100c3e0 	add	x0, sp, #0x30
   84d34:	a9400c02 	ldp	x2, x3, [x0]
   84d38:	a9000c22 	stp	x2, x3, [x1]
   84d3c:	a9410c02 	ldp	x2, x3, [x0, #16]
   84d40:	a9010c22 	stp	x2, x3, [x1, #16]
   84d44:	a9420c02 	ldp	x2, x3, [x0, #32]
   84d48:	a9020c22 	stp	x2, x3, [x1, #32]
   84d4c:	14000011 	b	84d90 <cpio_search+0xa0>
    while(0 == cpio_parse(&path)){
   84d50:	9100c3e0 	add	x0, sp, #0x30
   84d54:	97ffff7b 	bl	84b40 <cpio_parse>
   84d58:	7100001f 	cmp	w0, #0x0
   84d5c:	54fffdc0 	b.eq	84d14 <cpio_search+0x24>  // b.none
    }
    path.name = NULL;
   84d60:	f9001bff 	str	xzr, [sp, #48]
    path.mode = 0;
   84d64:	b90053ff 	str	wzr, [sp, #80]
    path.namesize = 0;
   84d68:	f90023ff 	str	xzr, [sp, #64]
    path.filesize = 0;
   84d6c:	f90027ff 	str	xzr, [sp, #72]
    return path;
   84d70:	aa1303e1 	mov	x1, x19
   84d74:	9100c3e0 	add	x0, sp, #0x30
   84d78:	a9400c02 	ldp	x2, x3, [x0]
   84d7c:	a9000c22 	stp	x2, x3, [x1]
   84d80:	a9410c02 	ldp	x2, x3, [x0, #16]
   84d84:	a9010c22 	stp	x2, x3, [x1, #16]
   84d88:	a9420c02 	ldp	x2, x3, [x0, #32]
   84d8c:	a9020c22 	stp	x2, x3, [x1, #32]
}
   84d90:	f9400bf3 	ldr	x19, [sp, #16]
   84d94:	a8c67bfd 	ldp	x29, x30, [sp], #96
   84d98:	d65f03c0 	ret

0000000000084d9c <cpio_ls>:

void cpio_ls(){
   84d9c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   84da0:	910003fd 	mov	x29, sp
    cpio_path path;
    cpio_get_start_addr(&path.next);
   84da4:	910043e0 	add	x0, sp, #0x10
   84da8:	9100a000 	add	x0, x0, #0x28
   84dac:	97ffff2d 	bl	84a60 <cpio_get_start_addr>
    while(0 == cpio_parse(&path))
   84db0:	14000006 	b	84dc8 <cpio_ls+0x2c>
        uart_printf("%s\n", path.name);
   84db4:	f9400be0 	ldr	x0, [sp, #16]
   84db8:	aa0003e1 	mov	x1, x0
   84dbc:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84dc0:	91034000 	add	x0, x0, #0xd0
   84dc4:	97fff80b 	bl	82df0 <uart_printf>
    while(0 == cpio_parse(&path))
   84dc8:	910043e0 	add	x0, sp, #0x10
   84dcc:	97ffff5d 	bl	84b40 <cpio_parse>
   84dd0:	7100001f 	cmp	w0, #0x0
   84dd4:	54ffff00 	b.eq	84db4 <cpio_ls+0x18>  // b.none
   84dd8:	d503201f 	nop
   84ddc:	d503201f 	nop
   84de0:	a8c47bfd 	ldp	x29, x30, [sp], #64
   84de4:	d65f03c0 	ret

0000000000084de8 <kernel_main>:
		return -1;							\
	} 										\
	uart_printf(name" start... ... "STYLE("success", FONT_GREEN)"\n"); \
})

int kernel_main(fdt_header *devicetree_ptr) {
   84de8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   84dec:	910003fd 	mov	x29, sp
   84df0:	f9000fe0 	str	x0, [sp, #24]
	
	set_devicetree_addr(devicetree_ptr);
   84df4:	f9400fe0 	ldr	x0, [sp, #24]
   84df8:	97fff991 	bl	8343c <set_devicetree_addr>
	set_exception_vector_table();
   84dfc:	94000c62 	bl	87f84 <set_exception_vector_table>
	
	uart_init();
   84e00:	97fff7b3 	bl	82ccc <uart_init>
	
	timer_init();
   84e04:	97fffab0 	bl	838c4 <timer_init>
	uart_printf("Timer system initializes... ... "STYLE("success", FONT_GREEN)"\n");
   84e08:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e0c:	91036000 	add	x0, x0, #0xd8
   84e10:	97fff7f8 	bl	82df0 <uart_printf>

	init_system("Buddy system inilization", mframe_init);
   84e14:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e18:	91044000 	add	x0, x0, #0x110
   84e1c:	97fff7f5 	bl	82df0 <uart_printf>
   84e20:	94000426 	bl	85eb8 <mframe_init>
   84e24:	7100001f 	cmp	w0, #0x0
   84e28:	540000c0 	b.eq	84e40 <kernel_main+0x58>  // b.none
   84e2c:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e30:	9104e000 	add	x0, x0, #0x138
   84e34:	97fff7ef 	bl	82df0 <uart_printf>
   84e38:	12800000 	mov	w0, #0xffffffff            	// #-1
   84e3c:	14000019 	b	84ea0 <kernel_main+0xb8>
   84e40:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e44:	9105c000 	add	x0, x0, #0x170
   84e48:	97fff7ea 	bl	82df0 <uart_printf>

	set_interrupt_el1(1);
   84e4c:	52800020 	mov	w0, #0x1                   	// #1
   84e50:	97fff094 	bl	810a0 <set_interrupt_el1>
	uart_printf("Interrput mechanism opening... ... "STYLE("success", FONT_GREEN)"\n");
   84e54:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e58:	9106a000 	add	x0, x0, #0x1a8
   84e5c:	97fff7e5 	bl	82df0 <uart_printf>
	
	init_system("Thread system inilization", thread_init);
   84e60:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e64:	91078000 	add	x0, x0, #0x1e0
   84e68:	97fff7e2 	bl	82df0 <uart_printf>
   84e6c:	97fffebd 	bl	84960 <thread_init>
   84e70:	7100001f 	cmp	w0, #0x0
   84e74:	540000c0 	b.eq	84e8c <kernel_main+0xa4>  // b.none
   84e78:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e7c:	91082000 	add	x0, x0, #0x208
   84e80:	97fff7dc 	bl	82df0 <uart_printf>
   84e84:	12800000 	mov	w0, #0xffffffff            	// #-1
   84e88:	14000006 	b	84ea0 <kernel_main+0xb8>
   84e8c:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84e90:	91090000 	add	x0, x0, #0x240
   84e94:	97fff7d7 	bl	82df0 <uart_printf>

	shell_loop();
   84e98:	97fff3b4 	bl	81d68 <shell_loop>
	return 0;
   84e9c:	52800000 	mov	w0, #0x0                   	// #0
   84ea0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   84ea4:	d65f03c0 	ret

0000000000084ea8 <simple_malloc>:
#include "initramfs.h"

extern char _heap_begin;
char* __heap_ptr = (char* )&_heap_begin;

void* simple_malloc(unsigned int bytes){
   84ea8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   84eac:	910003fd 	mov	x29, sp
   84eb0:	b9001fe0 	str	w0, [sp, #28]
    if(__heap_ptr + bytes >= HEAP_MAX){
   84eb4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84eb8:	91294000 	add	x0, x0, #0xa50
   84ebc:	f9400001 	ldr	x1, [x0]
   84ec0:	b9401fe0 	ldr	w0, [sp, #28]
   84ec4:	8b000021 	add	x1, x1, x0
   84ec8:	b24047e0 	mov	x0, #0x3ffff               	// #262143
   84ecc:	eb00003f 	cmp	x1, x0
   84ed0:	54000169 	b.ls	84efc <simple_malloc+0x54>  // b.plast
        debug("heap buffer overflow");
   84ed4:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84ed8:	91216003 	add	x3, x0, #0x858
   84edc:	52800182 	mov	w2, #0xc                   	// #12
   84ee0:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84ee4:	910a0001 	add	x1, x0, #0x280
   84ee8:	b0000020 	adrp	x0, 89000 <__func__.3025+0x420>
   84eec:	910a4000 	add	x0, x0, #0x290
   84ef0:	97fff7c0 	bl	82df0 <uart_printf>
        return (void *)0;
   84ef4:	d2800000 	mov	x0, #0x0                   	// #0
   84ef8:	1400000e 	b	84f30 <simple_malloc+0x88>
    }
    void *ret = __heap_ptr;
   84efc:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84f00:	91294000 	add	x0, x0, #0xa50
   84f04:	f9400000 	ldr	x0, [x0]
   84f08:	f90017e0 	str	x0, [sp, #40]
    __heap_ptr += bytes;
   84f0c:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84f10:	91294000 	add	x0, x0, #0xa50
   84f14:	f9400001 	ldr	x1, [x0]
   84f18:	b9401fe0 	ldr	w0, [sp, #28]
   84f1c:	8b000021 	add	x1, x1, x0
   84f20:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84f24:	91294000 	add	x0, x0, #0xa50
   84f28:	f9000001 	str	x1, [x0]
    return ret;
   84f2c:	f94017e0 	ldr	x0, [sp, #40]
}
   84f30:	a8c37bfd 	ldp	x29, x30, [sp], #48
   84f34:	d65f03c0 	ret

0000000000084f38 <malloc>:

void* malloc(uint32_t bytes){
   84f38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   84f3c:	910003fd 	mov	x29, sp
   84f40:	b9001fe0 	str	w0, [sp, #28]
    // TODO: implement dynamic mfree
    return simple_malloc(bytes);
   84f44:	b9401fe0 	ldr	w0, [sp, #28]
   84f48:	97ffffd8 	bl	84ea8 <simple_malloc>
}
   84f4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
   84f50:	d65f03c0 	ret

0000000000084f54 <mfree>:

int mfree(void* ptr){
   84f54:	d10043ff 	sub	sp, sp, #0x10
   84f58:	f90007e0 	str	x0, [sp, #8]
    // TODO: implement mfree
    return 0;
   84f5c:	52800000 	mov	w0, #0x0                   	// #0
}
   84f60:	910043ff 	add	sp, sp, #0x10
   84f64:	d65f03c0 	ret

0000000000084f68 <memcopy>:

void memcopy(void* src, void *dest, size_t bytes){
   84f68:	d100c3ff 	sub	sp, sp, #0x30
   84f6c:	f9000fe0 	str	x0, [sp, #24]
   84f70:	f9000be1 	str	x1, [sp, #16]
   84f74:	f90007e2 	str	x2, [sp, #8]
   uint8_t *s = (uint8_t*) src;
   84f78:	f9400fe0 	ldr	x0, [sp, #24]
   84f7c:	f90017e0 	str	x0, [sp, #40]
   uint8_t *d = (uint8_t*) dest;
   84f80:	f9400be0 	ldr	x0, [sp, #16]
   84f84:	f90013e0 	str	x0, [sp, #32]
   while(bytes--) *d++ = *s++;
   84f88:	14000009 	b	84fac <memcopy+0x44>
   84f8c:	f94017e1 	ldr	x1, [sp, #40]
   84f90:	91000420 	add	x0, x1, #0x1
   84f94:	f90017e0 	str	x0, [sp, #40]
   84f98:	f94013e0 	ldr	x0, [sp, #32]
   84f9c:	91000402 	add	x2, x0, #0x1
   84fa0:	f90013e2 	str	x2, [sp, #32]
   84fa4:	39400021 	ldrb	w1, [x1]
   84fa8:	39000001 	strb	w1, [x0]
   84fac:	f94007e0 	ldr	x0, [sp, #8]
   84fb0:	d1000401 	sub	x1, x0, #0x1
   84fb4:	f90007e1 	str	x1, [sp, #8]
   84fb8:	f100001f 	cmp	x0, #0x0
   84fbc:	54fffe81 	b.ne	84f8c <memcopy+0x24>  // b.any
   return ;
   84fc0:	d503201f 	nop
}
   84fc4:	9100c3ff 	add	sp, sp, #0x30
   84fc8:	d65f03c0 	ret

0000000000084fcc <get_parent>:
#define MFRAME_FREE     0
#define MFRAME_DIVIDE   1
#define MFRAME_USED     2
#define MFRAME_RESERVE  3

unsigned char* get_parent(unsigned char* mptr){
   84fcc:	d10043ff 	sub	sp, sp, #0x10
   84fd0:	f90007e0 	str	x0, [sp, #8]
    return (mptr == mframe)? (unsigned char*)0: mframe+(mptr-mframe-1)/2;
   84fd4:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84fd8:	f9445800 	ldr	x0, [x0, #2224]
   84fdc:	f94007e1 	ldr	x1, [sp, #8]
   84fe0:	eb00003f 	cmp	x1, x0
   84fe4:	540001a0 	b.eq	85018 <get_parent+0x4c>  // b.none
   84fe8:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84fec:	f9445801 	ldr	x1, [x0, #2224]
   84ff0:	d0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   84ff4:	f9445800 	ldr	x0, [x0, #2224]
   84ff8:	f94007e2 	ldr	x2, [sp, #8]
   84ffc:	cb000040 	sub	x0, x2, x0
   85000:	d1000400 	sub	x0, x0, #0x1
   85004:	d37ffc02 	lsr	x2, x0, #63
   85008:	8b000040 	add	x0, x2, x0
   8500c:	9341fc00 	asr	x0, x0, #1
   85010:	8b000020 	add	x0, x1, x0
   85014:	14000002 	b	8501c <get_parent+0x50>
   85018:	d2800000 	mov	x0, #0x0                   	// #0
}
   8501c:	910043ff 	add	sp, sp, #0x10
   85020:	d65f03c0 	ret

0000000000085024 <get_left>:

unsigned char* get_left(unsigned char* mptr){
   85024:	d10043ff 	sub	sp, sp, #0x10
   85028:	f90007e0 	str	x0, [sp, #8]
    return mframe+2*(mptr-mframe)+1;
   8502c:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85030:	f9445801 	ldr	x1, [x0, #2224]
   85034:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85038:	f9445800 	ldr	x0, [x0, #2224]
   8503c:	f94007e2 	ldr	x2, [sp, #8]
   85040:	cb000040 	sub	x0, x2, x0
   85044:	d37ff800 	lsl	x0, x0, #1
   85048:	91000400 	add	x0, x0, #0x1
   8504c:	8b000020 	add	x0, x1, x0
}
   85050:	910043ff 	add	sp, sp, #0x10
   85054:	d65f03c0 	ret

0000000000085058 <get_right>:

unsigned char* get_right(unsigned char* mptr){
   85058:	d10043ff 	sub	sp, sp, #0x10
   8505c:	f90007e0 	str	x0, [sp, #8]
    return mframe+2*(mptr-mframe)+2;
   85060:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85064:	f9445801 	ldr	x1, [x0, #2224]
   85068:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   8506c:	f9445800 	ldr	x0, [x0, #2224]
   85070:	f94007e2 	ldr	x2, [sp, #8]
   85074:	cb000040 	sub	x0, x2, x0
   85078:	d37ff800 	lsl	x0, x0, #1
   8507c:	91000800 	add	x0, x0, #0x2
   85080:	8b000020 	add	x0, x1, x0
}
   85084:	910043ff 	add	sp, sp, #0x10
   85088:	d65f03c0 	ret

000000000008508c <get_shift>:

unsigned char get_shift(unsigned char* mptr){
   8508c:	d10043ff 	sub	sp, sp, #0x10
   85090:	f90007e0 	str	x0, [sp, #8]
    return 0b111111 & *mptr;
   85094:	f94007e0 	ldr	x0, [sp, #8]
   85098:	39400000 	ldrb	w0, [x0]
   8509c:	12001400 	and	w0, w0, #0x3f
   850a0:	12001c00 	and	w0, w0, #0xff
}
   850a4:	910043ff 	add	sp, sp, #0x10
   850a8:	d65f03c0 	ret

00000000000850ac <get_status>:

unsigned char get_status(unsigned char* mptr){
   850ac:	d10043ff 	sub	sp, sp, #0x10
   850b0:	f90007e0 	str	x0, [sp, #8]
    return ((*mptr) >> 6) & 0b11;
   850b4:	f94007e0 	ldr	x0, [sp, #8]
   850b8:	39400000 	ldrb	w0, [x0]
   850bc:	53067c00 	lsr	w0, w0, #6
   850c0:	12001c00 	and	w0, w0, #0xff
}
   850c4:	910043ff 	add	sp, sp, #0x10
   850c8:	d65f03c0 	ret

00000000000850cc <get_mid>:

char* get_mid(char* begin, char* end){
   850cc:	d10043ff 	sub	sp, sp, #0x10
   850d0:	f90007e0 	str	x0, [sp, #8]
   850d4:	f90003e1 	str	x1, [sp]
    return (char*)(((unsigned long)begin + (unsigned long)end) / 2);
   850d8:	f94007e1 	ldr	x1, [sp, #8]
   850dc:	f94003e0 	ldr	x0, [sp]
   850e0:	8b000020 	add	x0, x1, x0
   850e4:	d341fc00 	lsr	x0, x0, #1
}
   850e8:	910043ff 	add	sp, sp, #0x10
   850ec:	d65f03c0 	ret

00000000000850f0 <set_mframe>:

void set_mframe(unsigned char* mptr, unsigned char status, unsigned char shift){
   850f0:	d10043ff 	sub	sp, sp, #0x10
   850f4:	f90007e0 	str	x0, [sp, #8]
   850f8:	39001fe1 	strb	w1, [sp, #7]
   850fc:	39001be2 	strb	w2, [sp, #6]
    *mptr = ((status & 0b11) << 6) | (shift & 0b111111);  
   85100:	39401fe0 	ldrb	w0, [sp, #7]
   85104:	531a6400 	lsl	w0, w0, #6
   85108:	13001c01 	sxtb	w1, w0
   8510c:	39c01be0 	ldrsb	w0, [sp, #6]
   85110:	12001400 	and	w0, w0, #0x3f
   85114:	13001c00 	sxtb	w0, w0
   85118:	2a000020 	orr	w0, w1, w0
   8511c:	13001c00 	sxtb	w0, w0
   85120:	12001c01 	and	w1, w0, #0xff
   85124:	f94007e0 	ldr	x0, [sp, #8]
   85128:	39000001 	strb	w1, [x0]
}
   8512c:	d503201f 	nop
   85130:	910043ff 	add	sp, sp, #0x10
   85134:	d65f03c0 	ret

0000000000085138 <update_mframe>:

void update_mframe(unsigned char* mptr){
   85138:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   8513c:	910003fd 	mov	x29, sp
   85140:	f9000fe0 	str	x0, [sp, #24]
    unsigned char* left = get_left(mptr);
   85144:	f9400fe0 	ldr	x0, [sp, #24]
   85148:	97ffffb7 	bl	85024 <get_left>
   8514c:	f9001be0 	str	x0, [sp, #48]
    unsigned char* right = get_right(mptr);
   85150:	f9400fe0 	ldr	x0, [sp, #24]
   85154:	97ffffc1 	bl	85058 <get_right>
   85158:	f90017e0 	str	x0, [sp, #40]
    unsigned char left_status = get_status(left);
   8515c:	f9401be0 	ldr	x0, [sp, #48]
   85160:	97ffffd3 	bl	850ac <get_status>
   85164:	39009fe0 	strb	w0, [sp, #39]
    unsigned char right_status = get_status(right);
   85168:	f94017e0 	ldr	x0, [sp, #40]
   8516c:	97ffffd0 	bl	850ac <get_status>
   85170:	39009be0 	strb	w0, [sp, #38]
    unsigned char left_shift = get_shift(left);
   85174:	f9401be0 	ldr	x0, [sp, #48]
   85178:	97ffffc5 	bl	8508c <get_shift>
   8517c:	390097e0 	strb	w0, [sp, #37]
    unsigned char right_shift = get_shift(right);
   85180:	f94017e0 	ldr	x0, [sp, #40]
   85184:	97ffffc2 	bl	8508c <get_shift>
   85188:	390093e0 	strb	w0, [sp, #36]

    if(left_status == MFRAME_FREE && right_status == MFRAME_FREE)
   8518c:	39409fe0 	ldrb	w0, [sp, #39]
   85190:	7100001f 	cmp	w0, #0x0
   85194:	54000181 	b.ne	851c4 <update_mframe+0x8c>  // b.any
   85198:	39409be0 	ldrb	w0, [sp, #38]
   8519c:	7100001f 	cmp	w0, #0x0
   851a0:	54000121 	b.ne	851c4 <update_mframe+0x8c>  // b.any
        set_mframe(mptr, MFRAME_FREE, left_shift + 1);
   851a4:	394097e0 	ldrb	w0, [sp, #37]
   851a8:	11000400 	add	w0, w0, #0x1
   851ac:	12001c00 	and	w0, w0, #0xff
   851b0:	2a0003e2 	mov	w2, w0
   851b4:	52800001 	mov	w1, #0x0                   	// #0
   851b8:	f9400fe0 	ldr	x0, [sp, #24]
   851bc:	97ffffcd 	bl	850f0 <set_mframe>
   851c0:	1400001c 	b	85230 <update_mframe+0xf8>
    else{
        unsigned char new_shift = 0;
   851c4:	3900ffff 	strb	wzr, [sp, #63]
        if(left_status == MFRAME_FREE || left_status == MFRAME_DIVIDE)
   851c8:	39409fe0 	ldrb	w0, [sp, #39]
   851cc:	7100001f 	cmp	w0, #0x0
   851d0:	54000080 	b.eq	851e0 <update_mframe+0xa8>  // b.none
   851d4:	39409fe0 	ldrb	w0, [sp, #39]
   851d8:	7100041f 	cmp	w0, #0x1
   851dc:	54000061 	b.ne	851e8 <update_mframe+0xb0>  // b.any
            new_shift = left_shift;
   851e0:	394097e0 	ldrb	w0, [sp, #37]
   851e4:	3900ffe0 	strb	w0, [sp, #63]
        if(right_status == MFRAME_FREE || right_status == MFRAME_DIVIDE)
   851e8:	39409be0 	ldrb	w0, [sp, #38]
   851ec:	7100001f 	cmp	w0, #0x0
   851f0:	54000080 	b.eq	85200 <update_mframe+0xc8>  // b.none
   851f4:	39409be0 	ldrb	w0, [sp, #38]
   851f8:	7100041f 	cmp	w0, #0x1
   851fc:	54000101 	b.ne	8521c <update_mframe+0xe4>  // b.any
            new_shift = (right_shift > new_shift)? right_shift: new_shift;
   85200:	394093e0 	ldrb	w0, [sp, #36]
   85204:	3940ffe3 	ldrb	w3, [sp, #63]
   85208:	12001c02 	and	w2, w0, #0xff
   8520c:	3940ffe1 	ldrb	w1, [sp, #63]
   85210:	6b02007f 	cmp	w3, w2
   85214:	1a802020 	csel	w0, w1, w0, cs  // cs = hs, nlast
   85218:	3900ffe0 	strb	w0, [sp, #63]
        set_mframe(mptr, MFRAME_DIVIDE, new_shift);
   8521c:	3940ffe2 	ldrb	w2, [sp, #63]
   85220:	52800021 	mov	w1, #0x1                   	// #1
   85224:	f9400fe0 	ldr	x0, [sp, #24]
   85228:	97ffffb2 	bl	850f0 <set_mframe>
    }
}
   8522c:	d503201f 	nop
   85230:	d503201f 	nop
   85234:	a8c47bfd 	ldp	x29, x30, [sp], #64
   85238:	d65f03c0 	ret

000000000008523c <mframe_alloc_iter>:


char* mframe_alloc_iter(unsigned int bytes, unsigned char* mptr, char* mbegin, char* mend){
   8523c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
   85240:	910003fd 	mov	x29, sp
   85244:	b9002fe0 	str	w0, [sp, #44]
   85248:	f90013e1 	str	x1, [sp, #32]
   8524c:	f9000fe2 	str	x2, [sp, #24]
   85250:	f9000be3 	str	x3, [sp, #16]
    unsigned char status = get_status(mptr);
   85254:	f94013e0 	ldr	x0, [sp, #32]
   85258:	97ffff95 	bl	850ac <get_status>
   8525c:	3901dfe0 	strb	w0, [sp, #119]
    unsigned char shift = get_shift(mptr);
   85260:	f94013e0 	ldr	x0, [sp, #32]
   85264:	97ffff8a 	bl	8508c <get_shift>
   85268:	3901dbe0 	strb	w0, [sp, #118]
    unsigned long size = 1 << shift;
   8526c:	3941dbe0 	ldrb	w0, [sp, #118]
   85270:	52800021 	mov	w1, #0x1                   	// #1
   85274:	1ac02020 	lsl	w0, w1, w0
   85278:	93407c00 	sxtw	x0, w0
   8527c:	f90037e0 	str	x0, [sp, #104]
    char* ret_ptr = (char*) 0;
   85280:	f90047ff 	str	xzr, [sp, #136]

    if(status == MFRAME_FREE){
   85284:	3941dfe0 	ldrb	w0, [sp, #119]
   85288:	7100001f 	cmp	w0, #0x0
   8528c:	54000901 	b.ne	853ac <mframe_alloc_iter+0x170>  // b.any
        if(bytes > size){
   85290:	b9402fe0 	ldr	w0, [sp, #44]
   85294:	f94037e1 	ldr	x1, [sp, #104]
   85298:	eb00003f 	cmp	x1, x0
   8529c:	54000162 	b.cs	852c8 <mframe_alloc_iter+0x8c>  // b.hs, b.nlast
            debug("not enough space");
   852a0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   852a4:	9121a003 	add	x3, x0, #0x868
   852a8:	52800d22 	mov	w2, #0x69                  	// #105
   852ac:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   852b0:	910a0001 	add	x1, x0, #0x280
   852b4:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   852b8:	910b4000 	add	x0, x0, #0x2d0
   852bc:	97fff6cd 	bl	82df0 <uart_printf>
            return ret_ptr;
   852c0:	f94047e0 	ldr	x0, [sp, #136]
   852c4:	140000c1 	b	855c8 <mframe_alloc_iter+0x38c>
        }
        else if(bytes > size/2 || size <= PAGE_SIZE){
   852c8:	b9402fe1 	ldr	w1, [sp, #44]
   852cc:	f94037e0 	ldr	x0, [sp, #104]
   852d0:	d341fc00 	lsr	x0, x0, #1
   852d4:	eb00003f 	cmp	x1, x0
   852d8:	54000088 	b.hi	852e8 <mframe_alloc_iter+0xac>  // b.pmore
   852dc:	f94037e0 	ldr	x0, [sp, #104]
   852e0:	f140041f 	cmp	x0, #0x1, lsl #12
   852e4:	54000168 	b.hi	85310 <mframe_alloc_iter+0xd4>  // b.pmore
            set_mframe(mptr, MFRAME_USED, get_shift(mptr));
   852e8:	f94013e0 	ldr	x0, [sp, #32]
   852ec:	97ffff68 	bl	8508c <get_shift>
   852f0:	12001c00 	and	w0, w0, #0xff
   852f4:	2a0003e2 	mov	w2, w0
   852f8:	52800041 	mov	w1, #0x2                   	// #2
   852fc:	f94013e0 	ldr	x0, [sp, #32]
   85300:	97ffff7c 	bl	850f0 <set_mframe>
            ret_ptr = mbegin;
   85304:	f9400fe0 	ldr	x0, [sp, #24]
   85308:	f90047e0 	str	x0, [sp, #136]
   8530c:	140000a1 	b	85590 <mframe_alloc_iter+0x354>
        }
        else{
            unsigned char* left = get_left(mptr);
   85310:	f94013e0 	ldr	x0, [sp, #32]
   85314:	97ffff44 	bl	85024 <get_left>
   85318:	f90023e0 	str	x0, [sp, #64]
            unsigned char* right = get_right(mptr);
   8531c:	f94013e0 	ldr	x0, [sp, #32]
   85320:	97ffff4e 	bl	85058 <get_right>
   85324:	f9001fe0 	str	x0, [sp, #56]
            set_mframe(mptr, MFRAME_DIVIDE, shift-1);
   85328:	3941dbe0 	ldrb	w0, [sp, #118]
   8532c:	51000400 	sub	w0, w0, #0x1
   85330:	12001c00 	and	w0, w0, #0xff
   85334:	2a0003e2 	mov	w2, w0
   85338:	52800021 	mov	w1, #0x1                   	// #1
   8533c:	f94013e0 	ldr	x0, [sp, #32]
   85340:	97ffff6c 	bl	850f0 <set_mframe>
            set_mframe(left, MFRAME_FREE, shift-1);
   85344:	3941dbe0 	ldrb	w0, [sp, #118]
   85348:	51000400 	sub	w0, w0, #0x1
   8534c:	12001c00 	and	w0, w0, #0xff
   85350:	2a0003e2 	mov	w2, w0
   85354:	52800001 	mov	w1, #0x0                   	// #0
   85358:	f94023e0 	ldr	x0, [sp, #64]
   8535c:	97ffff65 	bl	850f0 <set_mframe>
            set_mframe(right, MFRAME_FREE, shift-1);
   85360:	3941dbe0 	ldrb	w0, [sp, #118]
   85364:	51000400 	sub	w0, w0, #0x1
   85368:	12001c00 	and	w0, w0, #0xff
   8536c:	2a0003e2 	mov	w2, w0
   85370:	52800001 	mov	w1, #0x0                   	// #0
   85374:	f9401fe0 	ldr	x0, [sp, #56]
   85378:	97ffff5e 	bl	850f0 <set_mframe>
            ret_ptr =  mframe_alloc_iter(bytes, left, mbegin, get_mid(mbegin, mend));
   8537c:	f9400be1 	ldr	x1, [sp, #16]
   85380:	f9400fe0 	ldr	x0, [sp, #24]
   85384:	97ffff52 	bl	850cc <get_mid>
   85388:	aa0003e3 	mov	x3, x0
   8538c:	f9400fe2 	ldr	x2, [sp, #24]
   85390:	f94023e1 	ldr	x1, [sp, #64]
   85394:	b9402fe0 	ldr	w0, [sp, #44]
   85398:	97ffffa9 	bl	8523c <mframe_alloc_iter>
   8539c:	f90047e0 	str	x0, [sp, #136]
            update_mframe(mptr);
   853a0:	f94013e0 	ldr	x0, [sp, #32]
   853a4:	97ffff65 	bl	85138 <update_mframe>
   853a8:	1400007a 	b	85590 <mframe_alloc_iter+0x354>
        }
    }
    else if(status == MFRAME_DIVIDE){ 
   853ac:	3941dfe0 	ldrb	w0, [sp, #119]
   853b0:	7100041f 	cmp	w0, #0x1
   853b4:	54000ee1 	b.ne	85590 <mframe_alloc_iter+0x354>  // b.any
        if(bytes > size){
   853b8:	b9402fe0 	ldr	w0, [sp, #44]
   853bc:	f94037e1 	ldr	x1, [sp, #104]
   853c0:	eb00003f 	cmp	x1, x0
   853c4:	54000162 	b.cs	853f0 <mframe_alloc_iter+0x1b4>  // b.hs, b.nlast
            debug();
   853c8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   853cc:	9121a003 	add	x3, x0, #0x868
   853d0:	52800f82 	mov	w2, #0x7c                  	// #124
   853d4:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   853d8:	910a0001 	add	x1, x0, #0x280
   853dc:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   853e0:	910c2000 	add	x0, x0, #0x308
   853e4:	97fff683 	bl	82df0 <uart_printf>
            return (char*) 0;
   853e8:	d2800000 	mov	x0, #0x0                   	// #0
   853ec:	14000077 	b	855c8 <mframe_alloc_iter+0x38c>
        }
        
        unsigned char* left = get_left(mptr);
   853f0:	f94013e0 	ldr	x0, [sp, #32]
   853f4:	97ffff0c 	bl	85024 <get_left>
   853f8:	f90033e0 	str	x0, [sp, #96]
        unsigned char* right = get_right(mptr);
   853fc:	f94013e0 	ldr	x0, [sp, #32]
   85400:	97ffff16 	bl	85058 <get_right>
   85404:	f9002fe0 	str	x0, [sp, #88]
        unsigned char left_status = get_status(left);
   85408:	f94033e0 	ldr	x0, [sp, #96]
   8540c:	97ffff28 	bl	850ac <get_status>
   85410:	39015fe0 	strb	w0, [sp, #87]
        unsigned char right_status = get_status(right);
   85414:	f9402fe0 	ldr	x0, [sp, #88]
   85418:	97ffff25 	bl	850ac <get_status>
   8541c:	39015be0 	strb	w0, [sp, #86]
        unsigned long left_size = 1 << get_shift(left);
   85420:	f94033e0 	ldr	x0, [sp, #96]
   85424:	97ffff1a 	bl	8508c <get_shift>
   85428:	12001c00 	and	w0, w0, #0xff
   8542c:	2a0003e1 	mov	w1, w0
   85430:	52800020 	mov	w0, #0x1                   	// #1
   85434:	1ac12000 	lsl	w0, w0, w1
   85438:	93407c00 	sxtw	x0, w0
   8543c:	f90043e0 	str	x0, [sp, #128]
        unsigned long right_size = 1 << get_shift(right);
   85440:	f9402fe0 	ldr	x0, [sp, #88]
   85444:	97ffff12 	bl	8508c <get_shift>
   85448:	12001c00 	and	w0, w0, #0xff
   8544c:	2a0003e1 	mov	w1, w0
   85450:	52800020 	mov	w0, #0x1                   	// #1
   85454:	1ac12000 	lsl	w0, w0, w1
   85458:	93407c00 	sxtw	x0, w0
   8545c:	f9003fe0 	str	x0, [sp, #120]

        if(left_status == MFRAME_USED || left_status == MFRAME_RESERVE)
   85460:	39415fe0 	ldrb	w0, [sp, #87]
   85464:	7100081f 	cmp	w0, #0x2
   85468:	54000080 	b.eq	85478 <mframe_alloc_iter+0x23c>  // b.none
   8546c:	39415fe0 	ldrb	w0, [sp, #87]
   85470:	71000c1f 	cmp	w0, #0x3
   85474:	54000041 	b.ne	8547c <mframe_alloc_iter+0x240>  // b.any
            left_size = 0;
   85478:	f90043ff 	str	xzr, [sp, #128]
        if(right_status == MFRAME_USED || right_status == MFRAME_RESERVE)
   8547c:	39415be0 	ldrb	w0, [sp, #86]
   85480:	7100081f 	cmp	w0, #0x2
   85484:	54000080 	b.eq	85494 <mframe_alloc_iter+0x258>  // b.none
   85488:	39415be0 	ldrb	w0, [sp, #86]
   8548c:	71000c1f 	cmp	w0, #0x3
   85490:	54000041 	b.ne	85498 <mframe_alloc_iter+0x25c>  // b.any
            right_size = 0;
   85494:	f9003fff 	str	xzr, [sp, #120]
        // debug("left size: %d, right size: %d bytes: %d", left_size ,right_size, bytes);

        char* mid = get_mid(mbegin, mend);
   85498:	f9400be1 	ldr	x1, [sp, #16]
   8549c:	f9400fe0 	ldr	x0, [sp, #24]
   854a0:	97ffff0b 	bl	850cc <get_mid>
   854a4:	f90027e0 	str	x0, [sp, #72]

        if(left_size > bytes && right_size > bytes){
   854a8:	b9402fe0 	ldr	w0, [sp, #44]
   854ac:	f94043e1 	ldr	x1, [sp, #128]
   854b0:	eb00003f 	cmp	x1, x0
   854b4:	540002e9 	b.ls	85510 <mframe_alloc_iter+0x2d4>  // b.plast
   854b8:	b9402fe0 	ldr	w0, [sp, #44]
   854bc:	f9403fe1 	ldr	x1, [sp, #120]
   854c0:	eb00003f 	cmp	x1, x0
   854c4:	54000269 	b.ls	85510 <mframe_alloc_iter+0x2d4>  // b.plast
            if(left_size <= right_size)
   854c8:	f94043e1 	ldr	x1, [sp, #128]
   854cc:	f9403fe0 	ldr	x0, [sp, #120]
   854d0:	eb00003f 	cmp	x1, x0
   854d4:	54000108 	b.hi	854f4 <mframe_alloc_iter+0x2b8>  // b.pmore
                ret_ptr = mframe_alloc_iter(bytes, left, mbegin, mid);
   854d8:	f94027e3 	ldr	x3, [sp, #72]
   854dc:	f9400fe2 	ldr	x2, [sp, #24]
   854e0:	f94033e1 	ldr	x1, [sp, #96]
   854e4:	b9402fe0 	ldr	w0, [sp, #44]
   854e8:	97ffff55 	bl	8523c <mframe_alloc_iter>
   854ec:	f90047e0 	str	x0, [sp, #136]
            if(left_size <= right_size)
   854f0:	14000026 	b	85588 <mframe_alloc_iter+0x34c>
            else
                ret_ptr = mframe_alloc_iter(bytes, right, mid, mend);
   854f4:	f9400be3 	ldr	x3, [sp, #16]
   854f8:	f94027e2 	ldr	x2, [sp, #72]
   854fc:	f9402fe1 	ldr	x1, [sp, #88]
   85500:	b9402fe0 	ldr	w0, [sp, #44]
   85504:	97ffff4e 	bl	8523c <mframe_alloc_iter>
   85508:	f90047e0 	str	x0, [sp, #136]
            if(left_size <= right_size)
   8550c:	1400001f 	b	85588 <mframe_alloc_iter+0x34c>
        }
        else{
            if(bytes < left_size)
   85510:	b9402fe0 	ldr	w0, [sp, #44]
   85514:	f94043e1 	ldr	x1, [sp, #128]
   85518:	eb00003f 	cmp	x1, x0
   8551c:	54000109 	b.ls	8553c <mframe_alloc_iter+0x300>  // b.plast
                ret_ptr = mframe_alloc_iter(bytes, left, mbegin, mid);
   85520:	f94027e3 	ldr	x3, [sp, #72]
   85524:	f9400fe2 	ldr	x2, [sp, #24]
   85528:	f94033e1 	ldr	x1, [sp, #96]
   8552c:	b9402fe0 	ldr	w0, [sp, #44]
   85530:	97ffff43 	bl	8523c <mframe_alloc_iter>
   85534:	f90047e0 	str	x0, [sp, #136]
   85538:	14000014 	b	85588 <mframe_alloc_iter+0x34c>
            else if (bytes < right_size)
   8553c:	b9402fe0 	ldr	w0, [sp, #44]
   85540:	f9403fe1 	ldr	x1, [sp, #120]
   85544:	eb00003f 	cmp	x1, x0
   85548:	54000109 	b.ls	85568 <mframe_alloc_iter+0x32c>  // b.plast
                ret_ptr = mframe_alloc_iter(bytes, right, mid, mend);
   8554c:	f9400be3 	ldr	x3, [sp, #16]
   85550:	f94027e2 	ldr	x2, [sp, #72]
   85554:	f9402fe1 	ldr	x1, [sp, #88]
   85558:	b9402fe0 	ldr	w0, [sp, #44]
   8555c:	97ffff38 	bl	8523c <mframe_alloc_iter>
   85560:	f90047e0 	str	x0, [sp, #136]
   85564:	14000009 	b	85588 <mframe_alloc_iter+0x34c>
            else 
                debug("into wrong mframe");
   85568:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   8556c:	9121a003 	add	x3, x0, #0x868
   85570:	52801362 	mov	w2, #0x9b                  	// #155
   85574:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85578:	910a0001 	add	x1, x0, #0x280
   8557c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85580:	910cc000 	add	x0, x0, #0x330
   85584:	97fff61b 	bl	82df0 <uart_printf>
        }
        update_mframe(mptr);
   85588:	f94013e0 	ldr	x0, [sp, #32]
   8558c:	97fffeeb 	bl	85138 <update_mframe>
    }
    if(ret_ptr == 0){
   85590:	f94047e0 	ldr	x0, [sp, #136]
   85594:	f100001f 	cmp	x0, #0x0
   85598:	54000161 	b.ne	855c4 <mframe_alloc_iter+0x388>  // b.any
        debug("Already in used mbegin: 0x%x mend: 0x%x", mbegin, mend);
   8559c:	f9400be5 	ldr	x5, [sp, #16]
   855a0:	f9400fe4 	ldr	x4, [sp, #24]
   855a4:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   855a8:	9121a003 	add	x3, x0, #0x868
   855ac:	52801402 	mov	w2, #0xa0                  	// #160
   855b0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   855b4:	910a0001 	add	x1, x0, #0x280
   855b8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   855bc:	910da000 	add	x0, x0, #0x368
   855c0:	97fff60c 	bl	82df0 <uart_printf>
    }
    return ret_ptr;
   855c4:	f94047e0 	ldr	x0, [sp, #136]
}
   855c8:	a8c97bfd 	ldp	x29, x30, [sp], #144
   855cc:	d65f03c0 	ret

00000000000855d0 <mframe_alloc>:

char* mframe_alloc(unsigned int bytes){
   855d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   855d4:	910003fd 	mov	x29, sp
   855d8:	b9001fe0 	str	w0, [sp, #28]
    char* ret = mframe_alloc_iter(bytes, mframe, mbegin, mend);
   855dc:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   855e0:	f9445801 	ldr	x1, [x0, #2224]
   855e4:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   855e8:	912a6000 	add	x0, x0, #0xa98
   855ec:	f9400002 	ldr	x2, [x0]
   855f0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   855f4:	91226000 	add	x0, x0, #0x898
   855f8:	f9400000 	ldr	x0, [x0]
   855fc:	aa0003e3 	mov	x3, x0
   85600:	b9401fe0 	ldr	w0, [sp, #28]
   85604:	97ffff0e 	bl	8523c <mframe_alloc_iter>
   85608:	f90017e0 	str	x0, [sp, #40]
    // kprintf("return %x -> %x\n", ret, ret+bytes);
    // mframe_dump(-1);
    return ret;
   8560c:	f94017e0 	ldr	x0, [sp, #40]
}
   85610:	a8c37bfd 	ldp	x29, x30, [sp], #48
   85614:	d65f03c0 	ret

0000000000085618 <mframe_free_iter>:

int mframe_free_iter(char* addr, unsigned char* mptr, char* mbegin, char* mend){
   85618:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   8561c:	910003fd 	mov	x29, sp
   85620:	f90017e0 	str	x0, [sp, #40]
   85624:	f90013e1 	str	x1, [sp, #32]
   85628:	f9000fe2 	str	x2, [sp, #24]
   8562c:	f9000be3 	str	x3, [sp, #16]
    unsigned char status = get_status(mptr);
   85630:	f94013e0 	ldr	x0, [sp, #32]
   85634:	97fffe9e 	bl	850ac <get_status>
   85638:	39013fe0 	strb	w0, [sp, #79]
    char* mid = get_mid(mbegin, mend);
   8563c:	f9400be1 	ldr	x1, [sp, #16]
   85640:	f9400fe0 	ldr	x0, [sp, #24]
   85644:	97fffea2 	bl	850cc <get_mid>
   85648:	f90023e0 	str	x0, [sp, #64]
    if(status == MFRAME_FREE){
   8564c:	39413fe0 	ldrb	w0, [sp, #79]
   85650:	7100001f 	cmp	w0, #0x0
   85654:	54000181 	b.ne	85684 <mframe_free_iter+0x6c>  // b.any
        debug("this addr 0x%x hasn't been used", addr);
   85658:	f94017e4 	ldr	x4, [sp, #40]
   8565c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85660:	91220003 	add	x3, x0, #0x880
   85664:	52801602 	mov	w2, #0xb0                  	// #176
   85668:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   8566c:	910a0001 	add	x1, x0, #0x280
   85670:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85674:	910ee000 	add	x0, x0, #0x3b8
   85678:	97fff5de 	bl	82df0 <uart_printf>
        return -1;
   8567c:	12800000 	mov	w0, #0xffffffff            	// #-1
   85680:	14000040 	b	85780 <mframe_free_iter+0x168>
    }
    else if(status == MFRAME_DIVIDE){
   85684:	39413fe0 	ldrb	w0, [sp, #79]
   85688:	7100041f 	cmp	w0, #0x1
   8568c:	54000341 	b.ne	856f4 <mframe_free_iter+0xdc>  // b.any
        unsigned char* left = get_left(mptr);
   85690:	f94013e0 	ldr	x0, [sp, #32]
   85694:	97fffe64 	bl	85024 <get_left>
   85698:	f9001fe0 	str	x0, [sp, #56]
        unsigned char* right = get_right(mptr);
   8569c:	f94013e0 	ldr	x0, [sp, #32]
   856a0:	97fffe6e 	bl	85058 <get_right>
   856a4:	f9001be0 	str	x0, [sp, #48]
        if(addr < mid)
   856a8:	f94017e1 	ldr	x1, [sp, #40]
   856ac:	f94023e0 	ldr	x0, [sp, #64]
   856b0:	eb00003f 	cmp	x1, x0
   856b4:	540000e2 	b.cs	856d0 <mframe_free_iter+0xb8>  // b.hs, b.nlast
            mframe_free_iter(addr, left, mbegin, mid);
   856b8:	f94023e3 	ldr	x3, [sp, #64]
   856bc:	f9400fe2 	ldr	x2, [sp, #24]
   856c0:	f9401fe1 	ldr	x1, [sp, #56]
   856c4:	f94017e0 	ldr	x0, [sp, #40]
   856c8:	97ffffd4 	bl	85618 <mframe_free_iter>
   856cc:	14000006 	b	856e4 <mframe_free_iter+0xcc>
        else
            mframe_free_iter(addr, right, mid, mend);
   856d0:	f9400be3 	ldr	x3, [sp, #16]
   856d4:	f94023e2 	ldr	x2, [sp, #64]
   856d8:	f9401be1 	ldr	x1, [sp, #48]
   856dc:	f94017e0 	ldr	x0, [sp, #40]
   856e0:	97ffffce 	bl	85618 <mframe_free_iter>
        
        update_mframe(mptr);
   856e4:	f94013e0 	ldr	x0, [sp, #32]
   856e8:	97fffe94 	bl	85138 <update_mframe>
        return 0;
   856ec:	52800000 	mov	w0, #0x0                   	// #0
   856f0:	14000024 	b	85780 <mframe_free_iter+0x168>
    }
    else if(status == MFRAME_USED){
   856f4:	39413fe0 	ldrb	w0, [sp, #79]
   856f8:	7100081f 	cmp	w0, #0x2
   856fc:	54000141 	b.ne	85724 <mframe_free_iter+0x10c>  // b.any
        set_mframe(mptr, MFRAME_FREE, get_shift(mptr));
   85700:	f94013e0 	ldr	x0, [sp, #32]
   85704:	97fffe62 	bl	8508c <get_shift>
   85708:	12001c00 	and	w0, w0, #0xff
   8570c:	2a0003e2 	mov	w2, w0
   85710:	52800001 	mov	w1, #0x0                   	// #0
   85714:	f94013e0 	ldr	x0, [sp, #32]
   85718:	97fffe76 	bl	850f0 <set_mframe>
        return 0;
   8571c:	52800000 	mov	w0, #0x0                   	// #0
   85720:	14000018 	b	85780 <mframe_free_iter+0x168>
    }
    else if(status == MFRAME_RESERVE){
   85724:	39413fe0 	ldrb	w0, [sp, #79]
   85728:	71000c1f 	cmp	w0, #0x3
   8572c:	54000181 	b.ne	8575c <mframe_free_iter+0x144>  // b.any
        debug("this addr 0x%x is reserved", addr);
   85730:	f94017e4 	ldr	x4, [sp, #40]
   85734:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85738:	91220003 	add	x3, x0, #0x880
   8573c:	52801862 	mov	w2, #0xc3                  	// #195
   85740:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85744:	910a0001 	add	x1, x0, #0x280
   85748:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   8574c:	91100000 	add	x0, x0, #0x400
   85750:	97fff5a8 	bl	82df0 <uart_printf>
        return -1;
   85754:	12800000 	mov	w0, #0xffffffff            	// #-1
   85758:	1400000a 	b	85780 <mframe_free_iter+0x168>
    }
    debug("never go here");
   8575c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85760:	91220003 	add	x3, x0, #0x880
   85764:	528018c2 	mov	w2, #0xc6                  	// #198
   85768:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   8576c:	910a0001 	add	x1, x0, #0x280
   85770:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85774:	91112000 	add	x0, x0, #0x448
   85778:	97fff59e 	bl	82df0 <uart_printf>
    return -1;
   8577c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
   85780:	a8c57bfd 	ldp	x29, x30, [sp], #80
   85784:	d65f03c0 	ret

0000000000085788 <mframe_free>:

int mframe_free(char* addr){
   85788:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   8578c:	910003fd 	mov	x29, sp
   85790:	f9000fe0 	str	x0, [sp, #24]
    return mframe_free_iter(addr, mframe, mbegin, mend);
   85794:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85798:	f9445801 	ldr	x1, [x0, #2224]
   8579c:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   857a0:	912a6000 	add	x0, x0, #0xa98
   857a4:	f9400002 	ldr	x2, [x0]
   857a8:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   857ac:	91226000 	add	x0, x0, #0x898
   857b0:	f9400000 	ldr	x0, [x0]
   857b4:	aa0003e3 	mov	x3, x0
   857b8:	f9400fe0 	ldr	x0, [sp, #24]
   857bc:	97ffff97 	bl	85618 <mframe_free_iter>
}
   857c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   857c4:	d65f03c0 	ret

00000000000857c8 <mframe_reserve_iter>:

int mframe_reserve_iter(char* begin, char* end, unsigned char* mptr, char* mbegin, char* mend){
   857c8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
   857cc:	910003fd 	mov	x29, sp
   857d0:	f9001fe0 	str	x0, [sp, #56]
   857d4:	f9001be1 	str	x1, [sp, #48]
   857d8:	f90017e2 	str	x2, [sp, #40]
   857dc:	f90013e3 	str	x3, [sp, #32]
   857e0:	f9000fe4 	str	x4, [sp, #24]
    unsigned long reserve_size = end - begin;
   857e4:	f9401be1 	ldr	x1, [sp, #48]
   857e8:	f9401fe0 	ldr	x0, [sp, #56]
   857ec:	cb000020 	sub	x0, x1, x0
   857f0:	f9003fe0 	str	x0, [sp, #120]
    unsigned char shift = get_shift(mptr);
   857f4:	f94017e0 	ldr	x0, [sp, #40]
   857f8:	97fffe25 	bl	8508c <get_shift>
   857fc:	3901dfe0 	strb	w0, [sp, #119]
    unsigned long size = (1 << shift);
   85800:	3941dfe0 	ldrb	w0, [sp, #119]
   85804:	52800021 	mov	w1, #0x1                   	// #1
   85808:	1ac02020 	lsl	w0, w1, w0
   8580c:	93407c00 	sxtw	x0, w0
   85810:	f90037e0 	str	x0, [sp, #104]


    unsigned char status = get_status(mptr);
   85814:	f94017e0 	ldr	x0, [sp, #40]
   85818:	97fffe25 	bl	850ac <get_status>
   8581c:	39019fe0 	strb	w0, [sp, #103]
    if(status == MFRAME_FREE){
   85820:	39419fe0 	ldrb	w0, [sp, #103]
   85824:	7100001f 	cmp	w0, #0x0
   85828:	540002c1 	b.ne	85880 <mframe_reserve_iter+0xb8>  // b.any
        set_mframe(get_left(mptr), MFRAME_FREE, shift - 1);
   8582c:	f94017e0 	ldr	x0, [sp, #40]
   85830:	97fffdfd 	bl	85024 <get_left>
   85834:	aa0003e3 	mov	x3, x0
   85838:	3941dfe0 	ldrb	w0, [sp, #119]
   8583c:	51000400 	sub	w0, w0, #0x1
   85840:	12001c00 	and	w0, w0, #0xff
   85844:	2a0003e2 	mov	w2, w0
   85848:	52800001 	mov	w1, #0x0                   	// #0
   8584c:	aa0303e0 	mov	x0, x3
   85850:	97fffe28 	bl	850f0 <set_mframe>
        set_mframe(get_right(mptr), MFRAME_FREE, shift - 1);
   85854:	f94017e0 	ldr	x0, [sp, #40]
   85858:	97fffe00 	bl	85058 <get_right>
   8585c:	aa0003e3 	mov	x3, x0
   85860:	3941dfe0 	ldrb	w0, [sp, #119]
   85864:	51000400 	sub	w0, w0, #0x1
   85868:	12001c00 	and	w0, w0, #0xff
   8586c:	2a0003e2 	mov	w2, w0
   85870:	52800001 	mov	w1, #0x0                   	// #0
   85874:	aa0303e0 	mov	x0, x3
   85878:	97fffe1e 	bl	850f0 <set_mframe>
   8587c:	1400002b 	b	85928 <mframe_reserve_iter+0x160>
    }
    else if(status == MFRAME_DIVIDE){
   85880:	39419fe0 	ldrb	w0, [sp, #103]
   85884:	7100041f 	cmp	w0, #0x1
   85888:	540001c1 	b.ne	858c0 <mframe_reserve_iter+0xf8>  // b.any
        if(reserve_size > size)
   8588c:	f9403fe1 	ldr	x1, [sp, #120]
   85890:	f94037e0 	ldr	x0, [sp, #104]
   85894:	eb00003f 	cmp	x1, x0
   85898:	54000489 	b.ls	85928 <mframe_reserve_iter+0x160>  // b.plast
            debug("no enough space");    
   8589c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858a0:	91226003 	add	x3, x0, #0x898
   858a4:	52801b62 	mov	w2, #0xdb                  	// #219
   858a8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858ac:	910a0001 	add	x1, x0, #0x280
   858b0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858b4:	91120000 	add	x0, x0, #0x480
   858b8:	97fff54e 	bl	82df0 <uart_printf>
   858bc:	1400001b 	b	85928 <mframe_reserve_iter+0x160>
    }
    else if(status == MFRAME_USED){
   858c0:	39419fe0 	ldrb	w0, [sp, #103]
   858c4:	7100081f 	cmp	w0, #0x2
   858c8:	54000161 	b.ne	858f4 <mframe_reserve_iter+0x12c>  // b.any
        debug("this node has been used");
   858cc:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858d0:	91226003 	add	x3, x0, #0x898
   858d4:	52801bc2 	mov	w2, #0xde                  	// #222
   858d8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858dc:	910a0001 	add	x1, x0, #0x280
   858e0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   858e4:	9112e000 	add	x0, x0, #0x4b8
   858e8:	97fff542 	bl	82df0 <uart_printf>
        return 0;
   858ec:	52800000 	mov	w0, #0x0                   	// #0
   858f0:	14000058 	b	85a50 <mframe_reserve_iter+0x288>
    }
    else if(status == MFRAME_RESERVE){
   858f4:	39419fe0 	ldrb	w0, [sp, #103]
   858f8:	71000c1f 	cmp	w0, #0x3
   858fc:	54000161 	b.ne	85928 <mframe_reserve_iter+0x160>  // b.any
        debug("already reserve");
   85900:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85904:	91226003 	add	x3, x0, #0x898
   85908:	52801c42 	mov	w2, #0xe2                  	// #226
   8590c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85910:	910a0001 	add	x1, x0, #0x280
   85914:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85918:	9113e000 	add	x0, x0, #0x4f8
   8591c:	97fff535 	bl	82df0 <uart_printf>
        return 0;
   85920:	52800000 	mov	w0, #0x0                   	// #0
   85924:	1400004b 	b	85a50 <mframe_reserve_iter+0x288>
    }

    if(reserve_size > (size >> 1) || PAGE_SIZE >= size){
   85928:	f94037e0 	ldr	x0, [sp, #104]
   8592c:	d341fc00 	lsr	x0, x0, #1
   85930:	f9403fe1 	ldr	x1, [sp, #120]
   85934:	eb00003f 	cmp	x1, x0
   85938:	54000088 	b.hi	85948 <mframe_reserve_iter+0x180>  // b.pmore
   8593c:	f94037e0 	ldr	x0, [sp, #104]
   85940:	f140041f 	cmp	x0, #0x1, lsl #12
   85944:	54000288 	b.hi	85994 <mframe_reserve_iter+0x1cc>  // b.pmore
        // reserve interval claim this mframe 
        debug("reserve 0x%x 0x%x", mbegin, mend);
   85948:	f9400fe5 	ldr	x5, [sp, #24]
   8594c:	f94013e4 	ldr	x4, [sp, #32]
   85950:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85954:	91226003 	add	x3, x0, #0x898
   85958:	52801d02 	mov	w2, #0xe8                  	// #232
   8595c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85960:	910a0001 	add	x1, x0, #0x280
   85964:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85968:	9114c000 	add	x0, x0, #0x530
   8596c:	97fff521 	bl	82df0 <uart_printf>
        set_mframe(mptr, MFRAME_RESERVE, get_shift(mptr));
   85970:	f94017e0 	ldr	x0, [sp, #40]
   85974:	97fffdc6 	bl	8508c <get_shift>
   85978:	12001c00 	and	w0, w0, #0xff
   8597c:	2a0003e2 	mov	w2, w0
   85980:	52800061 	mov	w1, #0x3                   	// #3
   85984:	f94017e0 	ldr	x0, [sp, #40]
   85988:	97fffdda 	bl	850f0 <set_mframe>
        return 0;
   8598c:	52800000 	mov	w0, #0x0                   	// #0
   85990:	14000030 	b	85a50 <mframe_reserve_iter+0x288>
    }

    char* mid = get_mid(mbegin, mend);
   85994:	f9400fe1 	ldr	x1, [sp, #24]
   85998:	f94013e0 	ldr	x0, [sp, #32]
   8599c:	97fffdcc 	bl	850cc <get_mid>
   859a0:	f9002fe0 	str	x0, [sp, #88]
    unsigned char* left  = get_left(mptr);
   859a4:	f94017e0 	ldr	x0, [sp, #40]
   859a8:	97fffd9f 	bl	85024 <get_left>
   859ac:	f9002be0 	str	x0, [sp, #80]
    unsigned char* right = get_right(mptr);
   859b0:	f94017e0 	ldr	x0, [sp, #40]
   859b4:	97fffda9 	bl	85058 <get_right>
   859b8:	f90027e0 	str	x0, [sp, #72]
    if(end <= mid)          // on left side
   859bc:	f9401be1 	ldr	x1, [sp, #48]
   859c0:	f9402fe0 	ldr	x0, [sp, #88]
   859c4:	eb00003f 	cmp	x1, x0
   859c8:	54000108 	b.hi	859e8 <mframe_reserve_iter+0x220>  // b.pmore
        mframe_reserve_iter(begin, end, left, mbegin, mid);
   859cc:	f9402fe4 	ldr	x4, [sp, #88]
   859d0:	f94013e3 	ldr	x3, [sp, #32]
   859d4:	f9402be2 	ldr	x2, [sp, #80]
   859d8:	f9401be1 	ldr	x1, [sp, #48]
   859dc:	f9401fe0 	ldr	x0, [sp, #56]
   859e0:	97ffff7a 	bl	857c8 <mframe_reserve_iter>
   859e4:	14000018 	b	85a44 <mframe_reserve_iter+0x27c>
    else if(begin >= mid)   // on right side
   859e8:	f9401fe1 	ldr	x1, [sp, #56]
   859ec:	f9402fe0 	ldr	x0, [sp, #88]
   859f0:	eb00003f 	cmp	x1, x0
   859f4:	54000103 	b.cc	85a14 <mframe_reserve_iter+0x24c>  // b.lo, b.ul, b.last
        mframe_reserve_iter(begin, end, right, mid, mend);
   859f8:	f9400fe4 	ldr	x4, [sp, #24]
   859fc:	f9402fe3 	ldr	x3, [sp, #88]
   85a00:	f94027e2 	ldr	x2, [sp, #72]
   85a04:	f9401be1 	ldr	x1, [sp, #48]
   85a08:	f9401fe0 	ldr	x0, [sp, #56]
   85a0c:	97ffff6f 	bl	857c8 <mframe_reserve_iter>
   85a10:	1400000d 	b	85a44 <mframe_reserve_iter+0x27c>
    else{                   // across middle
        mframe_reserve_iter(begin, mid, left, mbegin, mid);
   85a14:	f9402fe4 	ldr	x4, [sp, #88]
   85a18:	f94013e3 	ldr	x3, [sp, #32]
   85a1c:	f9402be2 	ldr	x2, [sp, #80]
   85a20:	f9402fe1 	ldr	x1, [sp, #88]
   85a24:	f9401fe0 	ldr	x0, [sp, #56]
   85a28:	97ffff68 	bl	857c8 <mframe_reserve_iter>
        mframe_reserve_iter(mid, end, right, mid, mend);
   85a2c:	f9400fe4 	ldr	x4, [sp, #24]
   85a30:	f9402fe3 	ldr	x3, [sp, #88]
   85a34:	f94027e2 	ldr	x2, [sp, #72]
   85a38:	f9401be1 	ldr	x1, [sp, #48]
   85a3c:	f9402fe0 	ldr	x0, [sp, #88]
   85a40:	97ffff62 	bl	857c8 <mframe_reserve_iter>
    } 

    update_mframe(mptr);
   85a44:	f94017e0 	ldr	x0, [sp, #40]
   85a48:	97fffdbc 	bl	85138 <update_mframe>
    return 0;
   85a4c:	52800000 	mov	w0, #0x0                   	// #0
}
   85a50:	a8c87bfd 	ldp	x29, x30, [sp], #128
   85a54:	d65f03c0 	ret

0000000000085a58 <mframe_reserve>:

int mframe_reserve(char* begin, char* end){
   85a58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   85a5c:	910003fd 	mov	x29, sp
   85a60:	f9000fe0 	str	x0, [sp, #24]
   85a64:	f9000be1 	str	x1, [sp, #16]
    if(begin > end){
   85a68:	f9400fe1 	ldr	x1, [sp, #24]
   85a6c:	f9400be0 	ldr	x0, [sp, #16]
   85a70:	eb00003f 	cmp	x1, x0
   85a74:	54000169 	b.ls	85aa0 <mframe_reserve+0x48>  // b.plast
        debug("begin > end");
   85a78:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85a7c:	9122c003 	add	x3, x0, #0x8b0
   85a80:	52801fe2 	mov	w2, #0xff                  	// #255
   85a84:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85a88:	910a0001 	add	x1, x0, #0x280
   85a8c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85a90:	9115a000 	add	x0, x0, #0x568
   85a94:	97fff4d7 	bl	82df0 <uart_printf>
        return -1;
   85a98:	12800000 	mov	w0, #0xffffffff            	// #-1
   85a9c:	1400001f 	b	85b18 <mframe_reserve+0xc0>
    }
    end = (end > mend)? mend: end;
   85aa0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85aa4:	91226000 	add	x0, x0, #0x898
   85aa8:	f9400000 	ldr	x0, [x0]
   85aac:	f9400be2 	ldr	x2, [sp, #16]
   85ab0:	f9400be1 	ldr	x1, [sp, #16]
   85ab4:	eb00005f 	cmp	x2, x0
   85ab8:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
   85abc:	f9000be0 	str	x0, [sp, #16]
    begin = (begin < mbegin)? mbegin: begin;
   85ac0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85ac4:	912a6000 	add	x0, x0, #0xa98
   85ac8:	f9400000 	ldr	x0, [x0]
   85acc:	f9400fe2 	ldr	x2, [sp, #24]
   85ad0:	f9400fe1 	ldr	x1, [sp, #24]
   85ad4:	eb00005f 	cmp	x2, x0
   85ad8:	9a802020 	csel	x0, x1, x0, cs  // cs = hs, nlast
   85adc:	f9000fe0 	str	x0, [sp, #24]
    return mframe_reserve_iter(begin, end, mframe, mbegin, mend);
   85ae0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85ae4:	f9445801 	ldr	x1, [x0, #2224]
   85ae8:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85aec:	912a6000 	add	x0, x0, #0xa98
   85af0:	f9400002 	ldr	x2, [x0]
   85af4:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85af8:	91226000 	add	x0, x0, #0x898
   85afc:	f9400000 	ldr	x0, [x0]
   85b00:	aa0003e4 	mov	x4, x0
   85b04:	aa0203e3 	mov	x3, x2
   85b08:	aa0103e2 	mov	x2, x1
   85b0c:	f9400be1 	ldr	x1, [sp, #16]
   85b10:	f9400fe0 	ldr	x0, [sp, #24]
   85b14:	97ffff2d 	bl	857c8 <mframe_reserve_iter>
}
   85b18:	a8c27bfd 	ldp	x29, x30, [sp], #32
   85b1c:	d65f03c0 	ret

0000000000085b20 <mframe_dump_iter>:

// enable filter if non-negetive value
void mframe_dump_iter(unsigned char* mptr, char* begin, char* end, int depth, int filter){
   85b20:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
   85b24:	910003fd 	mov	x29, sp
   85b28:	f9000bf3 	str	x19, [sp, #16]
   85b2c:	f9001fe0 	str	x0, [sp, #56]
   85b30:	f9001be1 	str	x1, [sp, #48]
   85b34:	f90017e2 	str	x2, [sp, #40]
   85b38:	b90027e3 	str	w3, [sp, #36]
   85b3c:	b90023e4 	str	w4, [sp, #32]
    unsigned char status = get_status(mptr);
   85b40:	f9401fe0 	ldr	x0, [sp, #56]
   85b44:	97fffd5a 	bl	850ac <get_status>
   85b48:	39013fe0 	strb	w0, [sp, #79]
    // for(int i=0; i<depth; ++i) uart_send((i%2)?' ':'|');
    if(filter < 0)
   85b4c:	b94023e0 	ldr	w0, [sp, #32]
   85b50:	7100001f 	cmp	w0, #0x0
   85b54:	540000aa 	b.ge	85b68 <mframe_dump_iter+0x48>  // b.tcont
        uart_printf("%d", depth);
   85b58:	b94027e1 	ldr	w1, [sp, #36]
   85b5c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85b60:	91168000 	add	x0, x0, #0x5a0
   85b64:	97fff4a3 	bl	82df0 <uart_printf>
    if(status == MFRAME_FREE){
   85b68:	39413fe0 	ldrb	w0, [sp, #79]
   85b6c:	7100001f 	cmp	w0, #0x0
   85b70:	54000241 	b.ne	85bb8 <mframe_dump_iter+0x98>  // b.any
        if(filter < 0 || status == filter)
   85b74:	b94023e0 	ldr	w0, [sp, #32]
   85b78:	7100001f 	cmp	w0, #0x0
   85b7c:	540000ab 	b.lt	85b90 <mframe_dump_iter+0x70>  // b.tstop
   85b80:	39413fe0 	ldrb	w0, [sp, #79]
   85b84:	b94023e1 	ldr	w1, [sp, #32]
   85b88:	6b00003f 	cmp	w1, w0
   85b8c:	54000da1 	b.ne	85d40 <mframe_dump_iter+0x220>  // b.any
            uart_printf("\t["STYLE("FREE", FONT_GREEN)"] shift: %d 0x%x to 0x%x\n", get_shift(mptr), begin, end);
   85b90:	f9401fe0 	ldr	x0, [sp, #56]
   85b94:	97fffd3e 	bl	8508c <get_shift>
   85b98:	12001c00 	and	w0, w0, #0xff
   85b9c:	f94017e3 	ldr	x3, [sp, #40]
   85ba0:	f9401be2 	ldr	x2, [sp, #48]
   85ba4:	2a0003e1 	mov	w1, w0
   85ba8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85bac:	9116a000 	add	x0, x0, #0x5a8
   85bb0:	97fff490 	bl	82df0 <uart_printf>
        return;
   85bb4:	14000063 	b	85d40 <mframe_dump_iter+0x220>
    }
    else if(status == MFRAME_DIVIDE){
   85bb8:	39413fe0 	ldrb	w0, [sp, #79]
   85bbc:	7100041f 	cmp	w0, #0x1
   85bc0:	540005e1 	b.ne	85c7c <mframe_dump_iter+0x15c>  // b.any
        if(filter < 0 || status == filter)
   85bc4:	b94023e0 	ldr	w0, [sp, #32]
   85bc8:	7100001f 	cmp	w0, #0x0
   85bcc:	540000ab 	b.lt	85be0 <mframe_dump_iter+0xc0>  // b.tstop
   85bd0:	39413fe0 	ldrb	w0, [sp, #79]
   85bd4:	b94023e1 	ldr	w1, [sp, #32]
   85bd8:	6b00003f 	cmp	w1, w0
   85bdc:	54000141 	b.ne	85c04 <mframe_dump_iter+0xe4>  // b.any
            uart_printf("\t["STYLE("DIVI", FONT_BLUE)"] shift: %d 0x%x to 0x%x\n", get_shift(mptr), begin, end);
   85be0:	f9401fe0 	ldr	x0, [sp, #56]
   85be4:	97fffd2a 	bl	8508c <get_shift>
   85be8:	12001c00 	and	w0, w0, #0xff
   85bec:	f94017e3 	ldr	x3, [sp, #40]
   85bf0:	f9401be2 	ldr	x2, [sp, #48]
   85bf4:	2a0003e1 	mov	w1, w0
   85bf8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85bfc:	91176000 	add	x0, x0, #0x5d8
   85c00:	97fff47c 	bl	82df0 <uart_printf>
        mframe_dump_iter(get_left(mptr), begin, get_mid(begin, end), depth + 1, filter);
   85c04:	f9401fe0 	ldr	x0, [sp, #56]
   85c08:	97fffd07 	bl	85024 <get_left>
   85c0c:	aa0003f3 	mov	x19, x0
   85c10:	f94017e1 	ldr	x1, [sp, #40]
   85c14:	f9401be0 	ldr	x0, [sp, #48]
   85c18:	97fffd2d 	bl	850cc <get_mid>
   85c1c:	aa0003e1 	mov	x1, x0
   85c20:	b94027e0 	ldr	w0, [sp, #36]
   85c24:	11000400 	add	w0, w0, #0x1
   85c28:	b94023e4 	ldr	w4, [sp, #32]
   85c2c:	2a0003e3 	mov	w3, w0
   85c30:	aa0103e2 	mov	x2, x1
   85c34:	f9401be1 	ldr	x1, [sp, #48]
   85c38:	aa1303e0 	mov	x0, x19
   85c3c:	97ffffb9 	bl	85b20 <mframe_dump_iter>
        mframe_dump_iter(get_right(mptr), get_mid(begin, end), end, depth + 1, filter);
   85c40:	f9401fe0 	ldr	x0, [sp, #56]
   85c44:	97fffd05 	bl	85058 <get_right>
   85c48:	aa0003f3 	mov	x19, x0
   85c4c:	f94017e1 	ldr	x1, [sp, #40]
   85c50:	f9401be0 	ldr	x0, [sp, #48]
   85c54:	97fffd1e 	bl	850cc <get_mid>
   85c58:	aa0003e1 	mov	x1, x0
   85c5c:	b94027e0 	ldr	w0, [sp, #36]
   85c60:	11000400 	add	w0, w0, #0x1
   85c64:	b94023e4 	ldr	w4, [sp, #32]
   85c68:	2a0003e3 	mov	w3, w0
   85c6c:	f94017e2 	ldr	x2, [sp, #40]
   85c70:	aa1303e0 	mov	x0, x19
   85c74:	97ffffab 	bl	85b20 <mframe_dump_iter>
        return;
   85c78:	14000037 	b	85d54 <mframe_dump_iter+0x234>
    }
    else if(status == MFRAME_USED){
   85c7c:	39413fe0 	ldrb	w0, [sp, #79]
   85c80:	7100081f 	cmp	w0, #0x2
   85c84:	54000241 	b.ne	85ccc <mframe_dump_iter+0x1ac>  // b.any
        if(filter < 0 || status == filter)
   85c88:	b94023e0 	ldr	w0, [sp, #32]
   85c8c:	7100001f 	cmp	w0, #0x0
   85c90:	540000ab 	b.lt	85ca4 <mframe_dump_iter+0x184>  // b.tstop
   85c94:	39413fe0 	ldrb	w0, [sp, #79]
   85c98:	b94023e1 	ldr	w1, [sp, #32]
   85c9c:	6b00003f 	cmp	w1, w0
   85ca0:	54000541 	b.ne	85d48 <mframe_dump_iter+0x228>  // b.any
            uart_printf("\t["STYLE("USED", FONT_RED)"] shift: %d 0x%x to 0x%x\n", get_shift(mptr), begin, end);
   85ca4:	f9401fe0 	ldr	x0, [sp, #56]
   85ca8:	97fffcf9 	bl	8508c <get_shift>
   85cac:	12001c00 	and	w0, w0, #0xff
   85cb0:	f94017e3 	ldr	x3, [sp, #40]
   85cb4:	f9401be2 	ldr	x2, [sp, #48]
   85cb8:	2a0003e1 	mov	w1, w0
   85cbc:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85cc0:	91182000 	add	x0, x0, #0x608
   85cc4:	97fff44b 	bl	82df0 <uart_printf>
        return;
   85cc8:	14000020 	b	85d48 <mframe_dump_iter+0x228>
    }
    else if(status == MFRAME_RESERVE){
   85ccc:	39413fe0 	ldrb	w0, [sp, #79]
   85cd0:	71000c1f 	cmp	w0, #0x3
   85cd4:	54000241 	b.ne	85d1c <mframe_dump_iter+0x1fc>  // b.any
        if(filter < 0 || status == filter)
   85cd8:	b94023e0 	ldr	w0, [sp, #32]
   85cdc:	7100001f 	cmp	w0, #0x0
   85ce0:	540000ab 	b.lt	85cf4 <mframe_dump_iter+0x1d4>  // b.tstop
   85ce4:	39413fe0 	ldrb	w0, [sp, #79]
   85ce8:	b94023e1 	ldr	w1, [sp, #32]
   85cec:	6b00003f 	cmp	w1, w0
   85cf0:	54000301 	b.ne	85d50 <mframe_dump_iter+0x230>  // b.any
            uart_printf("\t["STYLE("RESV", FONT_RED)"] shift: %d 0x%x to 0x%x\n", get_shift(mptr), begin, end);
   85cf4:	f9401fe0 	ldr	x0, [sp, #56]
   85cf8:	97fffce5 	bl	8508c <get_shift>
   85cfc:	12001c00 	and	w0, w0, #0xff
   85d00:	f94017e3 	ldr	x3, [sp, #40]
   85d04:	f9401be2 	ldr	x2, [sp, #48]
   85d08:	2a0003e1 	mov	w1, w0
   85d0c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85d10:	9118e000 	add	x0, x0, #0x638
   85d14:	97fff437 	bl	82df0 <uart_printf>
        return;
   85d18:	1400000e 	b	85d50 <mframe_dump_iter+0x230>
    }
    debug("never go here");
   85d1c:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85d20:	91230003 	add	x3, x0, #0x8c0
   85d24:	52802462 	mov	w2, #0x123                 	// #291
   85d28:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85d2c:	910a0001 	add	x1, x0, #0x280
   85d30:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85d34:	91112000 	add	x0, x0, #0x448
   85d38:	97fff42e 	bl	82df0 <uart_printf>
   85d3c:	14000006 	b	85d54 <mframe_dump_iter+0x234>
        return;
   85d40:	d503201f 	nop
   85d44:	14000004 	b	85d54 <mframe_dump_iter+0x234>
        return;
   85d48:	d503201f 	nop
   85d4c:	14000002 	b	85d54 <mframe_dump_iter+0x234>
        return;
   85d50:	d503201f 	nop
}
   85d54:	f9400bf3 	ldr	x19, [sp, #16]
   85d58:	a8c57bfd 	ldp	x29, x30, [sp], #80
   85d5c:	d65f03c0 	ret

0000000000085d60 <mframe_dump>:

void mframe_dump(int filter){
   85d60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   85d64:	910003fd 	mov	x29, sp
   85d68:	b9001fe0 	str	w0, [sp, #28]
    return mframe_dump_iter(mframe, mbegin, mend, 0, filter);
   85d6c:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85d70:	f9445805 	ldr	x5, [x0, #2224]
   85d74:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85d78:	912a6000 	add	x0, x0, #0xa98
   85d7c:	f9400001 	ldr	x1, [x0]
   85d80:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85d84:	91226000 	add	x0, x0, #0x898
   85d88:	f9400000 	ldr	x0, [x0]
   85d8c:	b9401fe4 	ldr	w4, [sp, #28]
   85d90:	52800003 	mov	w3, #0x0                   	// #0
   85d94:	aa0003e2 	mov	x2, x0
   85d98:	aa0503e0 	mov	x0, x5
   85d9c:	97ffff61 	bl	85b20 <mframe_dump_iter>
}
   85da0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   85da4:	d65f03c0 	ret

0000000000085da8 <mframe_get_mem_section>:


char* mem_begin = (char*)0;
char* mem_end   = (char*)0x3C000000;

int mframe_get_mem_section(char* nodename, char* propname, char* propvalue, unsigned int proplen){
   85da8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
   85dac:	910003fd 	mov	x29, sp
   85db0:	f90017e0 	str	x0, [sp, #40]
   85db4:	f90013e1 	str	x1, [sp, #32]
   85db8:	f9000fe2 	str	x2, [sp, #24]
   85dbc:	b90017e3 	str	w3, [sp, #20]
    if(0 == m_strcmp(nodename, "memory@0") && 0 == m_strcmp(propname, "reg")){
   85dc0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85dc4:	9119a001 	add	x1, x0, #0x668
   85dc8:	f94017e0 	ldr	x0, [sp, #40]
   85dcc:	97fff0b2 	bl	82094 <m_strcmp>
   85dd0:	7100001f 	cmp	w0, #0x0
   85dd4:	54000541 	b.ne	85e7c <mframe_get_mem_section+0xd4>  // b.any
   85dd8:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85ddc:	9119e001 	add	x1, x0, #0x678
   85de0:	f94013e0 	ldr	x0, [sp, #32]
   85de4:	97fff0ac 	bl	82094 <m_strcmp>
   85de8:	7100001f 	cmp	w0, #0x0
   85dec:	54000481 	b.ne	85e7c <mframe_get_mem_section+0xd4>  // b.any
        unsigned int* ptr = (unsigned int *)propvalue;
   85df0:	f9400fe0 	ldr	x0, [sp, #24]
   85df4:	f9001fe0 	str	x0, [sp, #56]
        mem_begin = (char*)(long)read_bigendian(ptr);
   85df8:	f9401fe0 	ldr	x0, [sp, #56]
   85dfc:	97fff5b1 	bl	834c0 <read_bigendian>
   85e00:	2a0003e0 	mov	w0, w0
   85e04:	aa0003e1 	mov	x1, x0
   85e08:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85e0c:	912a8000 	add	x0, x0, #0xaa0
   85e10:	f9000001 	str	x1, [x0]
        mem_end = (char*)(long)read_bigendian(ptr+1);
   85e14:	f9401fe0 	ldr	x0, [sp, #56]
   85e18:	91001000 	add	x0, x0, #0x4
   85e1c:	97fff5a9 	bl	834c0 <read_bigendian>
   85e20:	2a0003e0 	mov	w0, w0
   85e24:	aa0003e1 	mov	x1, x0
   85e28:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85e2c:	91228000 	add	x0, x0, #0x8a0
   85e30:	f9000001 	str	x1, [x0]
        debug("mem_begin end %x %x", mem_begin, mem_end);
   85e34:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85e38:	912a8000 	add	x0, x0, #0xaa0
   85e3c:	f9400001 	ldr	x1, [x0]
   85e40:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85e44:	91228000 	add	x0, x0, #0x8a0
   85e48:	f9400000 	ldr	x0, [x0]
   85e4c:	aa0003e5 	mov	x5, x0
   85e50:	aa0103e4 	mov	x4, x1
   85e54:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85e58:	91236003 	add	x3, x0, #0x8d8
   85e5c:	52802662 	mov	w2, #0x133                 	// #307
   85e60:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85e64:	910a0001 	add	x1, x0, #0x280
   85e68:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85e6c:	911a0000 	add	x0, x0, #0x680
   85e70:	97fff3e0 	bl	82df0 <uart_printf>
        return 0;
   85e74:	52800000 	mov	w0, #0x0                   	// #0
   85e78:	14000002 	b	85e80 <mframe_get_mem_section+0xd8>
    }
    return -1;
   85e7c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
   85e80:	a8c47bfd 	ldp	x29, x30, [sp], #64
   85e84:	d65f03c0 	ret

0000000000085e88 <mframe_get_mem_reservation>:

int mframe_get_mem_reservation(unsigned long long addr, unsigned long long size){
   85e88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
   85e8c:	910003fd 	mov	x29, sp
   85e90:	f9000fe0 	str	x0, [sp, #24]
   85e94:	f9000be1 	str	x1, [sp, #16]
    uart_printf("%l %l\n", addr, size);
   85e98:	f9400be2 	ldr	x2, [sp, #16]
   85e9c:	f9400fe1 	ldr	x1, [sp, #24]
   85ea0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85ea4:	911b0000 	add	x0, x0, #0x6c0
   85ea8:	97fff3d2 	bl	82df0 <uart_printf>
    return 0;
   85eac:	52800000 	mov	w0, #0x0                   	// #0
}
   85eb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
   85eb4:	d65f03c0 	ret

0000000000085eb8 <mframe_init>:

int mframe_init(){
   85eb8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
   85ebc:	910003fd 	mov	x29, sp
    fdt_traverse(mframe_get_mem_section);
   85ec0:	90000000 	adrp	x0, 85000 <get_parent+0x34>
   85ec4:	9136a000 	add	x0, x0, #0xda8
   85ec8:	97fff605 	bl	836dc <fdt_traverse>
    unsigned long shift = 1;
   85ecc:	d2800020 	mov	x0, #0x1                   	// #1
   85ed0:	f9003fe0 	str	x0, [sp, #120]
    unsigned long size = (unsigned long)(mem_end - mem_begin);
   85ed4:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85ed8:	91228000 	add	x0, x0, #0x8a0
   85edc:	f9400001 	ldr	x1, [x0]
   85ee0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85ee4:	912a8000 	add	x0, x0, #0xaa0
   85ee8:	f9400000 	ldr	x0, [x0]
   85eec:	cb000020 	sub	x0, x1, x0
   85ef0:	f9003be0 	str	x0, [sp, #112]
    // aligned size to next power of 2
    while((1<<shift) < size) shift++;
   85ef4:	14000004 	b	85f04 <mframe_init+0x4c>
   85ef8:	f9403fe0 	ldr	x0, [sp, #120]
   85efc:	91000400 	add	x0, x0, #0x1
   85f00:	f9003fe0 	str	x0, [sp, #120]
   85f04:	f9403fe0 	ldr	x0, [sp, #120]
   85f08:	2a0003e1 	mov	w1, w0
   85f0c:	52800020 	mov	w0, #0x1                   	// #1
   85f10:	1ac12000 	lsl	w0, w0, w1
   85f14:	93407c00 	sxtw	x0, w0
   85f18:	f9403be1 	ldr	x1, [sp, #112]
   85f1c:	eb00003f 	cmp	x1, x0
   85f20:	54fffec8 	b.hi	85ef8 <mframe_init+0x40>  // b.pmore
    mframe[0] = shift;
   85f24:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f28:	f9445800 	ldr	x0, [x0, #2224]
   85f2c:	f9403fe1 	ldr	x1, [sp, #120]
   85f30:	12001c21 	and	w1, w1, #0xff
   85f34:	39000001 	strb	w1, [x0]
    mbegin = mem_begin;
   85f38:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f3c:	912a8000 	add	x0, x0, #0xaa0
   85f40:	f9400001 	ldr	x1, [x0]
   85f44:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f48:	912a6000 	add	x0, x0, #0xa98
   85f4c:	f9000001 	str	x1, [x0]
    mend   = mbegin + (1<<shift);
   85f50:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f54:	912a6000 	add	x0, x0, #0xa98
   85f58:	f9400001 	ldr	x1, [x0]
   85f5c:	f9403fe0 	ldr	x0, [sp, #120]
   85f60:	2a0003e2 	mov	w2, w0
   85f64:	52800020 	mov	w0, #0x1                   	// #1
   85f68:	1ac22000 	lsl	w0, w0, w2
   85f6c:	93407c00 	sxtw	x0, w0
   85f70:	8b000021 	add	x1, x1, x0
   85f74:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f78:	91226000 	add	x0, x0, #0x898
   85f7c:	f9000001 	str	x1, [x0]
    debug("mframe init section 0x%x 0x%x", mbegin, mend);
   85f80:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f84:	912a6000 	add	x0, x0, #0xa98
   85f88:	f9400001 	ldr	x1, [x0]
   85f8c:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85f90:	91226000 	add	x0, x0, #0x898
   85f94:	f9400000 	ldr	x0, [x0]
   85f98:	aa0003e5 	mov	x5, x0
   85f9c:	aa0103e4 	mov	x4, x1
   85fa0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85fa4:	9123c003 	add	x3, x0, #0x8f0
   85fa8:	528028e2 	mov	w2, #0x147                 	// #327
   85fac:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85fb0:	910a0001 	add	x1, x0, #0x280
   85fb4:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85fb8:	911b2000 	add	x0, x0, #0x6c8
   85fbc:	97fff38d 	bl	82df0 <uart_printf>
    
    // reserve for unexisted memory (truncate)
    debug("reserve for unexisted memory 0x%x 0x%x", mem_end, mend);
   85fc0:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85fc4:	91228000 	add	x0, x0, #0x8a0
   85fc8:	f9400001 	ldr	x1, [x0]
   85fcc:	b0000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   85fd0:	91226000 	add	x0, x0, #0x898
   85fd4:	f9400000 	ldr	x0, [x0]
   85fd8:	aa0003e5 	mov	x5, x0
   85fdc:	aa0103e4 	mov	x4, x1
   85fe0:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85fe4:	9123c003 	add	x3, x0, #0x8f0
   85fe8:	52802942 	mov	w2, #0x14a                 	// #330
   85fec:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85ff0:	910a0001 	add	x1, x0, #0x280
   85ff4:	90000020 	adrp	x0, 89000 <__func__.3025+0x420>
   85ff8:	911c4000 	add	x0, x0, #0x710
   85ffc:	97fff37d 	bl	82df0 <uart_printf>
    mframe_reserve((char*)mem_end, mend);
   86000:	90000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   86004:	91228000 	add	x0, x0, #0x8a0
   86008:	f9400002 	ldr	x2, [x0]
   8600c:	90000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   86010:	91226000 	add	x0, x0, #0x898
   86014:	f9400000 	ldr	x0, [x0]
   86018:	aa0003e1 	mov	x1, x0
   8601c:	aa0203e0 	mov	x0, x2
   86020:	97fffe8e 	bl	85a58 <mframe_reserve>

    // compute mframe size
    unsigned long mframe_size = (size / PAGE_SIZE) << 1;
   86024:	f9403be0 	ldr	x0, [sp, #112]
   86028:	d34cfc00 	lsr	x0, x0, #12
   8602c:	d37ff800 	lsl	x0, x0, #1
   86030:	f90037e0 	str	x0, [sp, #104]
    char* mframe_end = (char*)mframe + mframe_size;
   86034:	90000020 	adrp	x0, 8a000 <__func__.3228+0x710>
   86038:	f9445801 	ldr	x1, [x0, #2224]
   8603c:	f94037e0 	ldr	x0, [sp, #104]
   86040:	8b000020 	add	x0, x1, x0
   86044:	f90033e0 	str	x0, [sp, #96]
    
    // reserve 0x0 to 0x1000 spin tables
    // reserve 0x1000 to 0x80000 heap and stack
    // reserve 0x80000 to 0x8xxxx kernel code
    // reserve 0x8xxxx to mframe_end 
    debug("reserve for spin table, heap, stack, kernel, mframe 0x%x 0x%x", 0, mframe_end);
   86048:	f94033e5 	ldr	x5, [sp, #96]
   8604c:	52800004 	mov	w4, #0x0                   	// #0
   86050:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   86054:	9123c003 	add	x3, x0, #0x8f0
   86058:	52802aa2 	mov	w2, #0x155                 	// #341
   8605c:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   86060:	910a0001 	add	x1, x0, #0x280
   86064:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   86068:	911d8000 	add	x0, x0, #0x760
   8606c:	97fff361 	bl	82df0 <uart_printf>
    mframe_reserve((char*)0, mframe_end);
   86070:	f94033e1 	ldr	x1, [sp, #96]
   86074:	d2800000 	mov	x0, #0x0                   	// #0
   86078:	97fffe78 	bl	85a58 <mframe_reserve>

    // reserve for iniramfs
    cpio_path cpio;
    if(0 == cpio_get_start_addr(&cpio.next)){
   8607c:	910083e0 	add	x0, sp, #0x20
   86080:	9100a000 	add	x0, x0, #0x28
   86084:	97fffa77 	bl	84a60 <cpio_get_start_addr>
   86088:	7100001f 	cmp	w0, #0x0
   8608c:	540002e1 	b.ne	860e8 <mframe_init+0x230>  // b.any
        char *cpio_begin = cpio.next;
   86090:	f94027e0 	ldr	x0, [sp, #72]
   86094:	f9002fe0 	str	x0, [sp, #88]
        while(0 == cpio_parse(&cpio));
   86098:	d503201f 	nop
   8609c:	910083e0 	add	x0, sp, #0x20
   860a0:	97fffaa8 	bl	84b40 <cpio_parse>
   860a4:	7100001f 	cmp	w0, #0x0
   860a8:	54ffffa0 	b.eq	8609c <mframe_init+0x1e4>  // b.none
        char *cpio_end = cpio.next;
   860ac:	f94027e0 	ldr	x0, [sp, #72]
   860b0:	f9002be0 	str	x0, [sp, #80]
        debug("reserve for iniramfs 0x%x 0x%x", cpio_begin, cpio_end);
   860b4:	f9402be5 	ldr	x5, [sp, #80]
   860b8:	f9402fe4 	ldr	x4, [sp, #88]
   860bc:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   860c0:	9123c003 	add	x3, x0, #0x8f0
   860c4:	52802bc2 	mov	w2, #0x15e                 	// #350
   860c8:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   860cc:	910a0001 	add	x1, x0, #0x280
   860d0:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   860d4:	911f2000 	add	x0, x0, #0x7c8
   860d8:	97fff346 	bl	82df0 <uart_printf>
        mframe_reserve(cpio_begin, cpio_end);
   860dc:	f9402be1 	ldr	x1, [sp, #80]
   860e0:	f9402fe0 	ldr	x0, [sp, #88]
   860e4:	97fffe5d 	bl	85a58 <mframe_reserve>
    }
    

    // reserve for device tree
    char* dt_begin = 0;
   860e8:	f9000fff 	str	xzr, [sp, #24]
    char* dt_end = 0;
   860ec:	f9000bff 	str	xzr, [sp, #16]
    if(0 == fdt_get_begin_end(&dt_begin, &dt_end)){
   860f0:	910043e1 	add	x1, sp, #0x10
   860f4:	910063e0 	add	x0, sp, #0x18
   860f8:	97fff52a 	bl	835a0 <fdt_get_begin_end>
   860fc:	7100001f 	cmp	w0, #0x0
   86100:	54000201 	b.ne	86140 <mframe_init+0x288>  // b.any
        debug("reserve for device tree 0x%x 0x%x", dt_begin, dt_end);
   86104:	f9400fe0 	ldr	x0, [sp, #24]
   86108:	f9400be1 	ldr	x1, [sp, #16]
   8610c:	aa0103e5 	mov	x5, x1
   86110:	aa0003e4 	mov	x4, x0
   86114:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   86118:	9123c003 	add	x3, x0, #0x8f0
   8611c:	52802ce2 	mov	w2, #0x167                 	// #359
   86120:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   86124:	910a0001 	add	x1, x0, #0x280
   86128:	f0000000 	adrp	x0, 89000 <__func__.3025+0x420>
   8612c:	91204000 	add	x0, x0, #0x810
   86130:	97fff330 	bl	82df0 <uart_printf>
        mframe_reserve(dt_begin, dt_end);
   86134:	f9400fe0 	ldr	x0, [sp, #24]
   86138:	f9400be1 	ldr	x1, [sp, #16]
   8613c:	97fffe47 	bl	85a58 <mframe_reserve>
    }


    // mframe_dump(-1);
    return 0;
   86140:	52800000 	mov	w0, #0x0                   	// #0
   86144:	a8c87bfd 	ldp	x29, x30, [sp], #128
   86148:	d65f03c0 	ret
   8614c:	00000000 	.inst	0x00000000 ; undefined

0000000000086150 <get_cpu_cycles>:
   86150:	d53be020 	mrs	x0, cntpct_el0
   86154:	d65f03c0 	ret

0000000000086158 <set_cpu_cycles>:
   86158:	d51be020 	msr	cntpct_el0, x0
   8615c:	d65f03c0 	ret

0000000000086160 <get_cpu_frequency>:
   86160:	d53be000 	mrs	x0, cntfrq_el0
   86164:	d65f03c0 	ret

0000000000086168 <set_timer_expired>:
   86168:	d51be200 	msr	cntp_tval_el0, x0
   8616c:	d65f03c0 	ret

0000000000086170 <set_timer_limit>:
   86170:	d51be240 	msr	cntp_cval_el0, x0
   86174:	d65f03c0 	ret

0000000000086178 <set_core_timer>:
   86178:	b4000140 	cbz	x0, 861a0 <disable_core_timer>
   8617c:	d2800020 	mov	x0, #0x1                   	// #1
   86180:	d51be220 	msr	cntp_ctl_el0, x0
   86184:	d2800040 	mov	x0, #0x2                   	// #2
   86188:	58000141 	ldr	x1, 861b0 <disable_core_timer+0x10>
   8618c:	b9000020 	str	w0, [x1]
   86190:	d538e100 	mrs	x0, cntkctl_el1
   86194:	b2400000 	orr	x0, x0, #0x1
   86198:	d518e100 	msr	cntkctl_el1, x0
   8619c:	d65f03c0 	ret

00000000000861a0 <disable_core_timer>:
   861a0:	d2800002 	mov	x2, #0x0                   	// #0
   861a4:	58000061 	ldr	x1, 861b0 <disable_core_timer+0x10>
   861a8:	b9000022 	str	w2, [x1]
   861ac:	d65f03c0 	ret
   861b0:	40000040 	.word	0x40000040
   861b4:	00000000 	.word	0x00000000

00000000000861b8 <put32>:
   861b8:	b9000001 	str	w1, [x0]
   861bc:	d65f03c0 	ret

00000000000861c0 <get32>:
   861c0:	b9400000 	ldr	w0, [x0]
   861c4:	d65f03c0 	ret

00000000000861c8 <delay>:
   861c8:	f1000400 	subs	x0, x0, #0x1
   861cc:	54ffffe1 	b.ne	861c8 <delay>  // b.any
   861d0:	d65f03c0 	ret

00000000000861d4 <get_el>:
   861d4:	d5384240 	mrs	x0, currentel
   861d8:	d342fc00 	lsr	x0, x0, #2
   861dc:	d65f03c0 	ret
	...

0000000000086800 <el2_to_el1>:
   86800:	5800c241 	ldr	x1, 88048 <load_all_sp+0x60>
   86804:	d5181001 	msr	sctlr_el1, x1
   86808:	5800c241 	ldr	x1, 88050 <load_all_sp+0x68>
   8680c:	d5181041 	msr	cpacr_el1, x1
   86810:	5800c241 	ldr	x1, 88058 <load_all_sp+0x70>
   86814:	d51c1101 	msr	hcr_el2, x1
   86818:	5800c241 	ldr	x1, 88060 <load_all_sp+0x78>
   8681c:	d51c4001 	msr	spsr_el2, x1
   86820:	d51c403e 	msr	elr_el2, x30
   86824:	d69f03e0 	eret

0000000000086828 <branch_el1_to_el0>:
   86828:	d2807802 	mov	x2, #0x3c0                 	// #960
   8682c:	d5184002 	msr	spsr_el1, x2
   86830:	d5184020 	msr	elr_el1, x0
   86834:	d5184101 	msr	sp_el0, x1
   86838:	d69f03e0 	eret

000000000008683c <entry_el_spel0_sync>:
   8683c:	d10483ff 	sub	sp, sp, #0x120
   86840:	a90007e0 	stp	x0, x1, [sp]
   86844:	a9010fe2 	stp	x2, x3, [sp, #16]
   86848:	a90217e4 	stp	x4, x5, [sp, #32]
   8684c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86850:	a90427e8 	stp	x8, x9, [sp, #64]
   86854:	a9052fea 	stp	x10, x11, [sp, #80]
   86858:	a90637ec 	stp	x12, x13, [sp, #96]
   8685c:	a9073fee 	stp	x14, x15, [sp, #112]
   86860:	a90847f0 	stp	x16, x17, [sp, #128]
   86864:	a9094ff2 	stp	x18, x19, [sp, #144]
   86868:	a90a57f4 	stp	x20, x21, [sp, #160]
   8686c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86870:	a90c67f8 	stp	x24, x25, [sp, #192]
   86874:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86878:	a90e77fc 	stp	x28, x29, [sp, #224]
   8687c:	f9007bfe 	str	x30, [sp, #240]
   86880:	d5384000 	mrs	x0, spsr_el1
   86884:	d5384021 	mrs	x1, elr_el1
   86888:	f90083e0 	str	x0, [sp, #256]
   8688c:	f9008be1 	str	x1, [sp, #272]
   86890:	a94007e0 	ldp	x0, x1, [sp]
   86894:	910003e0 	mov	x0, sp
   86898:	10000001 	adr	x1, 86898 <entry_el_spel0_sync+0x5c>
   8689c:	97ffea64 	bl	8122c <el_spel0_sync>
   868a0:	a94007e0 	ldp	x0, x1, [sp]
   868a4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   868a8:	a94217e4 	ldp	x4, x5, [sp, #32]
   868ac:	a9431fe6 	ldp	x6, x7, [sp, #48]
   868b0:	a94427e8 	ldp	x8, x9, [sp, #64]
   868b4:	a9452fea 	ldp	x10, x11, [sp, #80]
   868b8:	a94637ec 	ldp	x12, x13, [sp, #96]
   868bc:	a9473fee 	ldp	x14, x15, [sp, #112]
   868c0:	a94847f0 	ldp	x16, x17, [sp, #128]
   868c4:	a9494ff2 	ldp	x18, x19, [sp, #144]
   868c8:	a94a57f4 	ldp	x20, x21, [sp, #160]
   868cc:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   868d0:	a94c67f8 	ldp	x24, x25, [sp, #192]
   868d4:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   868d8:	a94e77fc 	ldp	x28, x29, [sp, #224]
   868dc:	f9407bfe 	ldr	x30, [sp, #240]
   868e0:	f94083e0 	ldr	x0, [sp, #256]
   868e4:	f9408be1 	ldr	x1, [sp, #272]
   868e8:	d5184000 	msr	spsr_el1, x0
   868ec:	d5184021 	msr	elr_el1, x1
   868f0:	a94007e0 	ldp	x0, x1, [sp]
   868f4:	910483ff 	add	sp, sp, #0x120
   868f8:	d69f03e0 	eret

00000000000868fc <entry_el_spel0_irq>:
   868fc:	d10483ff 	sub	sp, sp, #0x120
   86900:	a90007e0 	stp	x0, x1, [sp]
   86904:	a9010fe2 	stp	x2, x3, [sp, #16]
   86908:	a90217e4 	stp	x4, x5, [sp, #32]
   8690c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86910:	a90427e8 	stp	x8, x9, [sp, #64]
   86914:	a9052fea 	stp	x10, x11, [sp, #80]
   86918:	a90637ec 	stp	x12, x13, [sp, #96]
   8691c:	a9073fee 	stp	x14, x15, [sp, #112]
   86920:	a90847f0 	stp	x16, x17, [sp, #128]
   86924:	a9094ff2 	stp	x18, x19, [sp, #144]
   86928:	a90a57f4 	stp	x20, x21, [sp, #160]
   8692c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86930:	a90c67f8 	stp	x24, x25, [sp, #192]
   86934:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86938:	a90e77fc 	stp	x28, x29, [sp, #224]
   8693c:	f9007bfe 	str	x30, [sp, #240]
   86940:	d5384000 	mrs	x0, spsr_el1
   86944:	d5384021 	mrs	x1, elr_el1
   86948:	f90083e0 	str	x0, [sp, #256]
   8694c:	f9008be1 	str	x1, [sp, #272]
   86950:	a94007e0 	ldp	x0, x1, [sp]
   86954:	910003e0 	mov	x0, sp
   86958:	10000001 	adr	x1, 86958 <entry_el_spel0_irq+0x5c>
   8695c:	97ffea42 	bl	81264 <el_spel0_irq>
   86960:	a94007e0 	ldp	x0, x1, [sp]
   86964:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86968:	a94217e4 	ldp	x4, x5, [sp, #32]
   8696c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86970:	a94427e8 	ldp	x8, x9, [sp, #64]
   86974:	a9452fea 	ldp	x10, x11, [sp, #80]
   86978:	a94637ec 	ldp	x12, x13, [sp, #96]
   8697c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86980:	a94847f0 	ldp	x16, x17, [sp, #128]
   86984:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86988:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8698c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86990:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86994:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86998:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8699c:	f9407bfe 	ldr	x30, [sp, #240]
   869a0:	f94083e0 	ldr	x0, [sp, #256]
   869a4:	f9408be1 	ldr	x1, [sp, #272]
   869a8:	d5184000 	msr	spsr_el1, x0
   869ac:	d5184021 	msr	elr_el1, x1
   869b0:	a94007e0 	ldp	x0, x1, [sp]
   869b4:	910483ff 	add	sp, sp, #0x120
   869b8:	d69f03e0 	eret

00000000000869bc <entry_el_spel0_fiq>:
   869bc:	d10483ff 	sub	sp, sp, #0x120
   869c0:	a90007e0 	stp	x0, x1, [sp]
   869c4:	a9010fe2 	stp	x2, x3, [sp, #16]
   869c8:	a90217e4 	stp	x4, x5, [sp, #32]
   869cc:	a9031fe6 	stp	x6, x7, [sp, #48]
   869d0:	a90427e8 	stp	x8, x9, [sp, #64]
   869d4:	a9052fea 	stp	x10, x11, [sp, #80]
   869d8:	a90637ec 	stp	x12, x13, [sp, #96]
   869dc:	a9073fee 	stp	x14, x15, [sp, #112]
   869e0:	a90847f0 	stp	x16, x17, [sp, #128]
   869e4:	a9094ff2 	stp	x18, x19, [sp, #144]
   869e8:	a90a57f4 	stp	x20, x21, [sp, #160]
   869ec:	a90b5ff6 	stp	x22, x23, [sp, #176]
   869f0:	a90c67f8 	stp	x24, x25, [sp, #192]
   869f4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   869f8:	a90e77fc 	stp	x28, x29, [sp, #224]
   869fc:	f9007bfe 	str	x30, [sp, #240]
   86a00:	d5384000 	mrs	x0, spsr_el1
   86a04:	d5384021 	mrs	x1, elr_el1
   86a08:	f90083e0 	str	x0, [sp, #256]
   86a0c:	f9008be1 	str	x1, [sp, #272]
   86a10:	a94007e0 	ldp	x0, x1, [sp]
   86a14:	910003e0 	mov	x0, sp
   86a18:	10000001 	adr	x1, 86a18 <entry_el_spel0_fiq+0x5c>
   86a1c:	97ffea20 	bl	8129c <el_spel0_fiq>
   86a20:	a94007e0 	ldp	x0, x1, [sp]
   86a24:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86a28:	a94217e4 	ldp	x4, x5, [sp, #32]
   86a2c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86a30:	a94427e8 	ldp	x8, x9, [sp, #64]
   86a34:	a9452fea 	ldp	x10, x11, [sp, #80]
   86a38:	a94637ec 	ldp	x12, x13, [sp, #96]
   86a3c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86a40:	a94847f0 	ldp	x16, x17, [sp, #128]
   86a44:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86a48:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86a4c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86a50:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86a54:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86a58:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86a5c:	f9407bfe 	ldr	x30, [sp, #240]
   86a60:	f94083e0 	ldr	x0, [sp, #256]
   86a64:	f9408be1 	ldr	x1, [sp, #272]
   86a68:	d5184000 	msr	spsr_el1, x0
   86a6c:	d5184021 	msr	elr_el1, x1
   86a70:	a94007e0 	ldp	x0, x1, [sp]
   86a74:	910483ff 	add	sp, sp, #0x120
   86a78:	d69f03e0 	eret

0000000000086a7c <entry_el_spel0_error>:
   86a7c:	d10483ff 	sub	sp, sp, #0x120
   86a80:	a90007e0 	stp	x0, x1, [sp]
   86a84:	a9010fe2 	stp	x2, x3, [sp, #16]
   86a88:	a90217e4 	stp	x4, x5, [sp, #32]
   86a8c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86a90:	a90427e8 	stp	x8, x9, [sp, #64]
   86a94:	a9052fea 	stp	x10, x11, [sp, #80]
   86a98:	a90637ec 	stp	x12, x13, [sp, #96]
   86a9c:	a9073fee 	stp	x14, x15, [sp, #112]
   86aa0:	a90847f0 	stp	x16, x17, [sp, #128]
   86aa4:	a9094ff2 	stp	x18, x19, [sp, #144]
   86aa8:	a90a57f4 	stp	x20, x21, [sp, #160]
   86aac:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86ab0:	a90c67f8 	stp	x24, x25, [sp, #192]
   86ab4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86ab8:	a90e77fc 	stp	x28, x29, [sp, #224]
   86abc:	f9007bfe 	str	x30, [sp, #240]
   86ac0:	d5384000 	mrs	x0, spsr_el1
   86ac4:	d5384021 	mrs	x1, elr_el1
   86ac8:	f90083e0 	str	x0, [sp, #256]
   86acc:	f9008be1 	str	x1, [sp, #272]
   86ad0:	a94007e0 	ldp	x0, x1, [sp]
   86ad4:	910003e0 	mov	x0, sp
   86ad8:	10000001 	adr	x1, 86ad8 <entry_el_spel0_error+0x5c>
   86adc:	97ffe9fe 	bl	812d4 <el_spel0_error>
   86ae0:	a94007e0 	ldp	x0, x1, [sp]
   86ae4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86ae8:	a94217e4 	ldp	x4, x5, [sp, #32]
   86aec:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86af0:	a94427e8 	ldp	x8, x9, [sp, #64]
   86af4:	a9452fea 	ldp	x10, x11, [sp, #80]
   86af8:	a94637ec 	ldp	x12, x13, [sp, #96]
   86afc:	a9473fee 	ldp	x14, x15, [sp, #112]
   86b00:	a94847f0 	ldp	x16, x17, [sp, #128]
   86b04:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86b08:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86b0c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86b10:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86b14:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86b18:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86b1c:	f9407bfe 	ldr	x30, [sp, #240]
   86b20:	f94083e0 	ldr	x0, [sp, #256]
   86b24:	f9408be1 	ldr	x1, [sp, #272]
   86b28:	d5184000 	msr	spsr_el1, x0
   86b2c:	d5184021 	msr	elr_el1, x1
   86b30:	a94007e0 	ldp	x0, x1, [sp]
   86b34:	910483ff 	add	sp, sp, #0x120
   86b38:	d69f03e0 	eret

0000000000086b3c <entry_el_spelx_sync>:
   86b3c:	d10483ff 	sub	sp, sp, #0x120
   86b40:	a90007e0 	stp	x0, x1, [sp]
   86b44:	a9010fe2 	stp	x2, x3, [sp, #16]
   86b48:	a90217e4 	stp	x4, x5, [sp, #32]
   86b4c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86b50:	a90427e8 	stp	x8, x9, [sp, #64]
   86b54:	a9052fea 	stp	x10, x11, [sp, #80]
   86b58:	a90637ec 	stp	x12, x13, [sp, #96]
   86b5c:	a9073fee 	stp	x14, x15, [sp, #112]
   86b60:	a90847f0 	stp	x16, x17, [sp, #128]
   86b64:	a9094ff2 	stp	x18, x19, [sp, #144]
   86b68:	a90a57f4 	stp	x20, x21, [sp, #160]
   86b6c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86b70:	a90c67f8 	stp	x24, x25, [sp, #192]
   86b74:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86b78:	a90e77fc 	stp	x28, x29, [sp, #224]
   86b7c:	f9007bfe 	str	x30, [sp, #240]
   86b80:	d5384000 	mrs	x0, spsr_el1
   86b84:	d5384021 	mrs	x1, elr_el1
   86b88:	f90083e0 	str	x0, [sp, #256]
   86b8c:	f9008be1 	str	x1, [sp, #272]
   86b90:	a94007e0 	ldp	x0, x1, [sp]
   86b94:	910003e0 	mov	x0, sp
   86b98:	10000001 	adr	x1, 86b98 <entry_el_spelx_sync+0x5c>
   86b9c:	97ffe9dc 	bl	8130c <el_spelx_sync>
   86ba0:	a94007e0 	ldp	x0, x1, [sp]
   86ba4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86ba8:	a94217e4 	ldp	x4, x5, [sp, #32]
   86bac:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86bb0:	a94427e8 	ldp	x8, x9, [sp, #64]
   86bb4:	a9452fea 	ldp	x10, x11, [sp, #80]
   86bb8:	a94637ec 	ldp	x12, x13, [sp, #96]
   86bbc:	a9473fee 	ldp	x14, x15, [sp, #112]
   86bc0:	a94847f0 	ldp	x16, x17, [sp, #128]
   86bc4:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86bc8:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86bcc:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86bd0:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86bd4:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86bd8:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86bdc:	f9407bfe 	ldr	x30, [sp, #240]
   86be0:	f94083e0 	ldr	x0, [sp, #256]
   86be4:	f9408be1 	ldr	x1, [sp, #272]
   86be8:	d5184000 	msr	spsr_el1, x0
   86bec:	d5184021 	msr	elr_el1, x1
   86bf0:	a94007e0 	ldp	x0, x1, [sp]
   86bf4:	910483ff 	add	sp, sp, #0x120
   86bf8:	d69f03e0 	eret

0000000000086bfc <entry_el_spelx_irq>:
   86bfc:	d10483ff 	sub	sp, sp, #0x120
   86c00:	a90007e0 	stp	x0, x1, [sp]
   86c04:	a9010fe2 	stp	x2, x3, [sp, #16]
   86c08:	a90217e4 	stp	x4, x5, [sp, #32]
   86c0c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86c10:	a90427e8 	stp	x8, x9, [sp, #64]
   86c14:	a9052fea 	stp	x10, x11, [sp, #80]
   86c18:	a90637ec 	stp	x12, x13, [sp, #96]
   86c1c:	a9073fee 	stp	x14, x15, [sp, #112]
   86c20:	a90847f0 	stp	x16, x17, [sp, #128]
   86c24:	a9094ff2 	stp	x18, x19, [sp, #144]
   86c28:	a90a57f4 	stp	x20, x21, [sp, #160]
   86c2c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86c30:	a90c67f8 	stp	x24, x25, [sp, #192]
   86c34:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86c38:	a90e77fc 	stp	x28, x29, [sp, #224]
   86c3c:	f9007bfe 	str	x30, [sp, #240]
   86c40:	d5384000 	mrs	x0, spsr_el1
   86c44:	d5384021 	mrs	x1, elr_el1
   86c48:	f90083e0 	str	x0, [sp, #256]
   86c4c:	f9008be1 	str	x1, [sp, #272]
   86c50:	a94007e0 	ldp	x0, x1, [sp]
   86c54:	910003e0 	mov	x0, sp
   86c58:	10000001 	adr	x1, 86c58 <entry_el_spelx_irq+0x5c>
   86c5c:	97ffe91c 	bl	810cc <el_spelx_irq>
   86c60:	a94007e0 	ldp	x0, x1, [sp]
   86c64:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86c68:	a94217e4 	ldp	x4, x5, [sp, #32]
   86c6c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86c70:	a94427e8 	ldp	x8, x9, [sp, #64]
   86c74:	a9452fea 	ldp	x10, x11, [sp, #80]
   86c78:	a94637ec 	ldp	x12, x13, [sp, #96]
   86c7c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86c80:	a94847f0 	ldp	x16, x17, [sp, #128]
   86c84:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86c88:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86c8c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86c90:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86c94:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86c98:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86c9c:	f9407bfe 	ldr	x30, [sp, #240]
   86ca0:	f94083e0 	ldr	x0, [sp, #256]
   86ca4:	f9408be1 	ldr	x1, [sp, #272]
   86ca8:	d5184000 	msr	spsr_el1, x0
   86cac:	d5184021 	msr	elr_el1, x1
   86cb0:	a94007e0 	ldp	x0, x1, [sp]
   86cb4:	910483ff 	add	sp, sp, #0x120
   86cb8:	d69f03e0 	eret

0000000000086cbc <entry_el_spelx_fiq>:
   86cbc:	d10483ff 	sub	sp, sp, #0x120
   86cc0:	a90007e0 	stp	x0, x1, [sp]
   86cc4:	a9010fe2 	stp	x2, x3, [sp, #16]
   86cc8:	a90217e4 	stp	x4, x5, [sp, #32]
   86ccc:	a9031fe6 	stp	x6, x7, [sp, #48]
   86cd0:	a90427e8 	stp	x8, x9, [sp, #64]
   86cd4:	a9052fea 	stp	x10, x11, [sp, #80]
   86cd8:	a90637ec 	stp	x12, x13, [sp, #96]
   86cdc:	a9073fee 	stp	x14, x15, [sp, #112]
   86ce0:	a90847f0 	stp	x16, x17, [sp, #128]
   86ce4:	a9094ff2 	stp	x18, x19, [sp, #144]
   86ce8:	a90a57f4 	stp	x20, x21, [sp, #160]
   86cec:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86cf0:	a90c67f8 	stp	x24, x25, [sp, #192]
   86cf4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86cf8:	a90e77fc 	stp	x28, x29, [sp, #224]
   86cfc:	f9007bfe 	str	x30, [sp, #240]
   86d00:	d5384000 	mrs	x0, spsr_el1
   86d04:	d5384021 	mrs	x1, elr_el1
   86d08:	f90083e0 	str	x0, [sp, #256]
   86d0c:	f9008be1 	str	x1, [sp, #272]
   86d10:	a94007e0 	ldp	x0, x1, [sp]
   86d14:	910003e0 	mov	x0, sp
   86d18:	10000001 	adr	x1, 86d18 <entry_el_spelx_fiq+0x5c>
   86d1c:	97ffe99e 	bl	81394 <el_spelx_fiq>
   86d20:	a94007e0 	ldp	x0, x1, [sp]
   86d24:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86d28:	a94217e4 	ldp	x4, x5, [sp, #32]
   86d2c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86d30:	a94427e8 	ldp	x8, x9, [sp, #64]
   86d34:	a9452fea 	ldp	x10, x11, [sp, #80]
   86d38:	a94637ec 	ldp	x12, x13, [sp, #96]
   86d3c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86d40:	a94847f0 	ldp	x16, x17, [sp, #128]
   86d44:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86d48:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86d4c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86d50:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86d54:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86d58:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86d5c:	f9407bfe 	ldr	x30, [sp, #240]
   86d60:	f94083e0 	ldr	x0, [sp, #256]
   86d64:	f9408be1 	ldr	x1, [sp, #272]
   86d68:	d5184000 	msr	spsr_el1, x0
   86d6c:	d5184021 	msr	elr_el1, x1
   86d70:	a94007e0 	ldp	x0, x1, [sp]
   86d74:	910483ff 	add	sp, sp, #0x120
   86d78:	d69f03e0 	eret

0000000000086d7c <entry_el_spelx_error>:
   86d7c:	d10483ff 	sub	sp, sp, #0x120
   86d80:	a90007e0 	stp	x0, x1, [sp]
   86d84:	a9010fe2 	stp	x2, x3, [sp, #16]
   86d88:	a90217e4 	stp	x4, x5, [sp, #32]
   86d8c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86d90:	a90427e8 	stp	x8, x9, [sp, #64]
   86d94:	a9052fea 	stp	x10, x11, [sp, #80]
   86d98:	a90637ec 	stp	x12, x13, [sp, #96]
   86d9c:	a9073fee 	stp	x14, x15, [sp, #112]
   86da0:	a90847f0 	stp	x16, x17, [sp, #128]
   86da4:	a9094ff2 	stp	x18, x19, [sp, #144]
   86da8:	a90a57f4 	stp	x20, x21, [sp, #160]
   86dac:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86db0:	a90c67f8 	stp	x24, x25, [sp, #192]
   86db4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86db8:	a90e77fc 	stp	x28, x29, [sp, #224]
   86dbc:	f9007bfe 	str	x30, [sp, #240]
   86dc0:	d5384000 	mrs	x0, spsr_el1
   86dc4:	d5384021 	mrs	x1, elr_el1
   86dc8:	f90083e0 	str	x0, [sp, #256]
   86dcc:	f9008be1 	str	x1, [sp, #272]
   86dd0:	a94007e0 	ldp	x0, x1, [sp]
   86dd4:	910003e0 	mov	x0, sp
   86dd8:	10000001 	adr	x1, 86dd8 <entry_el_spelx_error+0x5c>
   86ddc:	97ffe97c 	bl	813cc <el_spelx_error>
   86de0:	a94007e0 	ldp	x0, x1, [sp]
   86de4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86de8:	a94217e4 	ldp	x4, x5, [sp, #32]
   86dec:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86df0:	a94427e8 	ldp	x8, x9, [sp, #64]
   86df4:	a9452fea 	ldp	x10, x11, [sp, #80]
   86df8:	a94637ec 	ldp	x12, x13, [sp, #96]
   86dfc:	a9473fee 	ldp	x14, x15, [sp, #112]
   86e00:	a94847f0 	ldp	x16, x17, [sp, #128]
   86e04:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86e08:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86e0c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86e10:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86e14:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86e18:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86e1c:	f9407bfe 	ldr	x30, [sp, #240]
   86e20:	f94083e0 	ldr	x0, [sp, #256]
   86e24:	f9408be1 	ldr	x1, [sp, #272]
   86e28:	d5184000 	msr	spsr_el1, x0
   86e2c:	d5184021 	msr	elr_el1, x1
   86e30:	a94007e0 	ldp	x0, x1, [sp]
   86e34:	910483ff 	add	sp, sp, #0x120
   86e38:	d69f03e0 	eret

0000000000086e3c <entry_elh_64_sync>:
   86e3c:	d10483ff 	sub	sp, sp, #0x120
   86e40:	a90007e0 	stp	x0, x1, [sp]
   86e44:	a9010fe2 	stp	x2, x3, [sp, #16]
   86e48:	a90217e4 	stp	x4, x5, [sp, #32]
   86e4c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86e50:	a90427e8 	stp	x8, x9, [sp, #64]
   86e54:	a9052fea 	stp	x10, x11, [sp, #80]
   86e58:	a90637ec 	stp	x12, x13, [sp, #96]
   86e5c:	a9073fee 	stp	x14, x15, [sp, #112]
   86e60:	a90847f0 	stp	x16, x17, [sp, #128]
   86e64:	a9094ff2 	stp	x18, x19, [sp, #144]
   86e68:	a90a57f4 	stp	x20, x21, [sp, #160]
   86e6c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86e70:	a90c67f8 	stp	x24, x25, [sp, #192]
   86e74:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86e78:	a90e77fc 	stp	x28, x29, [sp, #224]
   86e7c:	f9007bfe 	str	x30, [sp, #240]
   86e80:	d5384000 	mrs	x0, spsr_el1
   86e84:	d5384021 	mrs	x1, elr_el1
   86e88:	f90083e0 	str	x0, [sp, #256]
   86e8c:	f9008be1 	str	x1, [sp, #272]
   86e90:	a94007e0 	ldp	x0, x1, [sp]
   86e94:	910003e0 	mov	x0, sp
   86e98:	10000001 	adr	x1, 86e98 <entry_elh_64_sync+0x5c>
   86e9c:	97ffe95a 	bl	81404 <elh_64_sync>
   86ea0:	a94007e0 	ldp	x0, x1, [sp]
   86ea4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86ea8:	a94217e4 	ldp	x4, x5, [sp, #32]
   86eac:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86eb0:	a94427e8 	ldp	x8, x9, [sp, #64]
   86eb4:	a9452fea 	ldp	x10, x11, [sp, #80]
   86eb8:	a94637ec 	ldp	x12, x13, [sp, #96]
   86ebc:	a9473fee 	ldp	x14, x15, [sp, #112]
   86ec0:	a94847f0 	ldp	x16, x17, [sp, #128]
   86ec4:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86ec8:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86ecc:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86ed0:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86ed4:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86ed8:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86edc:	f9407bfe 	ldr	x30, [sp, #240]
   86ee0:	f94083e0 	ldr	x0, [sp, #256]
   86ee4:	f9408be1 	ldr	x1, [sp, #272]
   86ee8:	d5184000 	msr	spsr_el1, x0
   86eec:	d5184021 	msr	elr_el1, x1
   86ef0:	a94007e0 	ldp	x0, x1, [sp]
   86ef4:	910483ff 	add	sp, sp, #0x120
   86ef8:	d69f03e0 	eret

0000000000086efc <entry_elh_64_irq>:
   86efc:	d10483ff 	sub	sp, sp, #0x120
   86f00:	a90007e0 	stp	x0, x1, [sp]
   86f04:	a9010fe2 	stp	x2, x3, [sp, #16]
   86f08:	a90217e4 	stp	x4, x5, [sp, #32]
   86f0c:	a9031fe6 	stp	x6, x7, [sp, #48]
   86f10:	a90427e8 	stp	x8, x9, [sp, #64]
   86f14:	a9052fea 	stp	x10, x11, [sp, #80]
   86f18:	a90637ec 	stp	x12, x13, [sp, #96]
   86f1c:	a9073fee 	stp	x14, x15, [sp, #112]
   86f20:	a90847f0 	stp	x16, x17, [sp, #128]
   86f24:	a9094ff2 	stp	x18, x19, [sp, #144]
   86f28:	a90a57f4 	stp	x20, x21, [sp, #160]
   86f2c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86f30:	a90c67f8 	stp	x24, x25, [sp, #192]
   86f34:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86f38:	a90e77fc 	stp	x28, x29, [sp, #224]
   86f3c:	f9007bfe 	str	x30, [sp, #240]
   86f40:	d5384000 	mrs	x0, spsr_el1
   86f44:	d5384021 	mrs	x1, elr_el1
   86f48:	f90083e0 	str	x0, [sp, #256]
   86f4c:	f9008be1 	str	x1, [sp, #272]
   86f50:	a94007e0 	ldp	x0, x1, [sp]
   86f54:	910003e0 	mov	x0, sp
   86f58:	10000001 	adr	x1, 86f58 <entry_elh_64_irq+0x5c>
   86f5c:	97ffe94b 	bl	81488 <elh_64_irq>
   86f60:	a94007e0 	ldp	x0, x1, [sp]
   86f64:	a9410fe2 	ldp	x2, x3, [sp, #16]
   86f68:	a94217e4 	ldp	x4, x5, [sp, #32]
   86f6c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   86f70:	a94427e8 	ldp	x8, x9, [sp, #64]
   86f74:	a9452fea 	ldp	x10, x11, [sp, #80]
   86f78:	a94637ec 	ldp	x12, x13, [sp, #96]
   86f7c:	a9473fee 	ldp	x14, x15, [sp, #112]
   86f80:	a94847f0 	ldp	x16, x17, [sp, #128]
   86f84:	a9494ff2 	ldp	x18, x19, [sp, #144]
   86f88:	a94a57f4 	ldp	x20, x21, [sp, #160]
   86f8c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   86f90:	a94c67f8 	ldp	x24, x25, [sp, #192]
   86f94:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   86f98:	a94e77fc 	ldp	x28, x29, [sp, #224]
   86f9c:	f9407bfe 	ldr	x30, [sp, #240]
   86fa0:	f94083e0 	ldr	x0, [sp, #256]
   86fa4:	f9408be1 	ldr	x1, [sp, #272]
   86fa8:	d5184000 	msr	spsr_el1, x0
   86fac:	d5184021 	msr	elr_el1, x1
   86fb0:	a94007e0 	ldp	x0, x1, [sp]
   86fb4:	910483ff 	add	sp, sp, #0x120
   86fb8:	d69f03e0 	eret

0000000000086fbc <entry_elh_64_fiq>:
   86fbc:	d10483ff 	sub	sp, sp, #0x120
   86fc0:	a90007e0 	stp	x0, x1, [sp]
   86fc4:	a9010fe2 	stp	x2, x3, [sp, #16]
   86fc8:	a90217e4 	stp	x4, x5, [sp, #32]
   86fcc:	a9031fe6 	stp	x6, x7, [sp, #48]
   86fd0:	a90427e8 	stp	x8, x9, [sp, #64]
   86fd4:	a9052fea 	stp	x10, x11, [sp, #80]
   86fd8:	a90637ec 	stp	x12, x13, [sp, #96]
   86fdc:	a9073fee 	stp	x14, x15, [sp, #112]
   86fe0:	a90847f0 	stp	x16, x17, [sp, #128]
   86fe4:	a9094ff2 	stp	x18, x19, [sp, #144]
   86fe8:	a90a57f4 	stp	x20, x21, [sp, #160]
   86fec:	a90b5ff6 	stp	x22, x23, [sp, #176]
   86ff0:	a90c67f8 	stp	x24, x25, [sp, #192]
   86ff4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   86ff8:	a90e77fc 	stp	x28, x29, [sp, #224]
   86ffc:	f9007bfe 	str	x30, [sp, #240]
   87000:	d5384000 	mrs	x0, spsr_el1
   87004:	d5384021 	mrs	x1, elr_el1
   87008:	f90083e0 	str	x0, [sp, #256]
   8700c:	f9008be1 	str	x1, [sp, #272]
   87010:	a94007e0 	ldp	x0, x1, [sp]
   87014:	910003e0 	mov	x0, sp
   87018:	10000001 	adr	x1, 87018 <entry_elh_64_fiq+0x5c>
   8701c:	97ffe927 	bl	814b8 <elh_64_fiq>
   87020:	a94007e0 	ldp	x0, x1, [sp]
   87024:	a9410fe2 	ldp	x2, x3, [sp, #16]
   87028:	a94217e4 	ldp	x4, x5, [sp, #32]
   8702c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   87030:	a94427e8 	ldp	x8, x9, [sp, #64]
   87034:	a9452fea 	ldp	x10, x11, [sp, #80]
   87038:	a94637ec 	ldp	x12, x13, [sp, #96]
   8703c:	a9473fee 	ldp	x14, x15, [sp, #112]
   87040:	a94847f0 	ldp	x16, x17, [sp, #128]
   87044:	a9494ff2 	ldp	x18, x19, [sp, #144]
   87048:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8704c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   87050:	a94c67f8 	ldp	x24, x25, [sp, #192]
   87054:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   87058:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8705c:	f9407bfe 	ldr	x30, [sp, #240]
   87060:	f94083e0 	ldr	x0, [sp, #256]
   87064:	f9408be1 	ldr	x1, [sp, #272]
   87068:	d5184000 	msr	spsr_el1, x0
   8706c:	d5184021 	msr	elr_el1, x1
   87070:	a94007e0 	ldp	x0, x1, [sp]
   87074:	910483ff 	add	sp, sp, #0x120
   87078:	d69f03e0 	eret

000000000008707c <entry_elh_64_error>:
   8707c:	d10483ff 	sub	sp, sp, #0x120
   87080:	a90007e0 	stp	x0, x1, [sp]
   87084:	a9010fe2 	stp	x2, x3, [sp, #16]
   87088:	a90217e4 	stp	x4, x5, [sp, #32]
   8708c:	a9031fe6 	stp	x6, x7, [sp, #48]
   87090:	a90427e8 	stp	x8, x9, [sp, #64]
   87094:	a9052fea 	stp	x10, x11, [sp, #80]
   87098:	a90637ec 	stp	x12, x13, [sp, #96]
   8709c:	a9073fee 	stp	x14, x15, [sp, #112]
   870a0:	a90847f0 	stp	x16, x17, [sp, #128]
   870a4:	a9094ff2 	stp	x18, x19, [sp, #144]
   870a8:	a90a57f4 	stp	x20, x21, [sp, #160]
   870ac:	a90b5ff6 	stp	x22, x23, [sp, #176]
   870b0:	a90c67f8 	stp	x24, x25, [sp, #192]
   870b4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   870b8:	a90e77fc 	stp	x28, x29, [sp, #224]
   870bc:	f9007bfe 	str	x30, [sp, #240]
   870c0:	d5384000 	mrs	x0, spsr_el1
   870c4:	d5384021 	mrs	x1, elr_el1
   870c8:	f90083e0 	str	x0, [sp, #256]
   870cc:	f9008be1 	str	x1, [sp, #272]
   870d0:	a94007e0 	ldp	x0, x1, [sp]
   870d4:	910003e0 	mov	x0, sp
   870d8:	10000001 	adr	x1, 870d8 <entry_elh_64_error+0x5c>
   870dc:	97ffe905 	bl	814f0 <elh_64_error>
   870e0:	a94007e0 	ldp	x0, x1, [sp]
   870e4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   870e8:	a94217e4 	ldp	x4, x5, [sp, #32]
   870ec:	a9431fe6 	ldp	x6, x7, [sp, #48]
   870f0:	a94427e8 	ldp	x8, x9, [sp, #64]
   870f4:	a9452fea 	ldp	x10, x11, [sp, #80]
   870f8:	a94637ec 	ldp	x12, x13, [sp, #96]
   870fc:	a9473fee 	ldp	x14, x15, [sp, #112]
   87100:	a94847f0 	ldp	x16, x17, [sp, #128]
   87104:	a9494ff2 	ldp	x18, x19, [sp, #144]
   87108:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8710c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   87110:	a94c67f8 	ldp	x24, x25, [sp, #192]
   87114:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   87118:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8711c:	f9407bfe 	ldr	x30, [sp, #240]
   87120:	f94083e0 	ldr	x0, [sp, #256]
   87124:	f9408be1 	ldr	x1, [sp, #272]
   87128:	d5184000 	msr	spsr_el1, x0
   8712c:	d5184021 	msr	elr_el1, x1
   87130:	a94007e0 	ldp	x0, x1, [sp]
   87134:	910483ff 	add	sp, sp, #0x120
   87138:	d69f03e0 	eret

000000000008713c <entry_elh_32_sync>:
   8713c:	d10483ff 	sub	sp, sp, #0x120
   87140:	a90007e0 	stp	x0, x1, [sp]
   87144:	a9010fe2 	stp	x2, x3, [sp, #16]
   87148:	a90217e4 	stp	x4, x5, [sp, #32]
   8714c:	a9031fe6 	stp	x6, x7, [sp, #48]
   87150:	a90427e8 	stp	x8, x9, [sp, #64]
   87154:	a9052fea 	stp	x10, x11, [sp, #80]
   87158:	a90637ec 	stp	x12, x13, [sp, #96]
   8715c:	a9073fee 	stp	x14, x15, [sp, #112]
   87160:	a90847f0 	stp	x16, x17, [sp, #128]
   87164:	a9094ff2 	stp	x18, x19, [sp, #144]
   87168:	a90a57f4 	stp	x20, x21, [sp, #160]
   8716c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   87170:	a90c67f8 	stp	x24, x25, [sp, #192]
   87174:	a90d6ffa 	stp	x26, x27, [sp, #208]
   87178:	a90e77fc 	stp	x28, x29, [sp, #224]
   8717c:	f9007bfe 	str	x30, [sp, #240]
   87180:	d5384000 	mrs	x0, spsr_el1
   87184:	d5384021 	mrs	x1, elr_el1
   87188:	f90083e0 	str	x0, [sp, #256]
   8718c:	f9008be1 	str	x1, [sp, #272]
   87190:	a94007e0 	ldp	x0, x1, [sp]
   87194:	910003e0 	mov	x0, sp
   87198:	10000001 	adr	x1, 87198 <entry_elh_32_sync+0x5c>
   8719c:	97ffe8e3 	bl	81528 <elh_32_sync>
   871a0:	a94007e0 	ldp	x0, x1, [sp]
   871a4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   871a8:	a94217e4 	ldp	x4, x5, [sp, #32]
   871ac:	a9431fe6 	ldp	x6, x7, [sp, #48]
   871b0:	a94427e8 	ldp	x8, x9, [sp, #64]
   871b4:	a9452fea 	ldp	x10, x11, [sp, #80]
   871b8:	a94637ec 	ldp	x12, x13, [sp, #96]
   871bc:	a9473fee 	ldp	x14, x15, [sp, #112]
   871c0:	a94847f0 	ldp	x16, x17, [sp, #128]
   871c4:	a9494ff2 	ldp	x18, x19, [sp, #144]
   871c8:	a94a57f4 	ldp	x20, x21, [sp, #160]
   871cc:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   871d0:	a94c67f8 	ldp	x24, x25, [sp, #192]
   871d4:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   871d8:	a94e77fc 	ldp	x28, x29, [sp, #224]
   871dc:	f9407bfe 	ldr	x30, [sp, #240]
   871e0:	f94083e0 	ldr	x0, [sp, #256]
   871e4:	f9408be1 	ldr	x1, [sp, #272]
   871e8:	d5184000 	msr	spsr_el1, x0
   871ec:	d5184021 	msr	elr_el1, x1
   871f0:	a94007e0 	ldp	x0, x1, [sp]
   871f4:	910483ff 	add	sp, sp, #0x120
   871f8:	d69f03e0 	eret

00000000000871fc <entry_elh_32_irq>:
   871fc:	d10483ff 	sub	sp, sp, #0x120
   87200:	a90007e0 	stp	x0, x1, [sp]
   87204:	a9010fe2 	stp	x2, x3, [sp, #16]
   87208:	a90217e4 	stp	x4, x5, [sp, #32]
   8720c:	a9031fe6 	stp	x6, x7, [sp, #48]
   87210:	a90427e8 	stp	x8, x9, [sp, #64]
   87214:	a9052fea 	stp	x10, x11, [sp, #80]
   87218:	a90637ec 	stp	x12, x13, [sp, #96]
   8721c:	a9073fee 	stp	x14, x15, [sp, #112]
   87220:	a90847f0 	stp	x16, x17, [sp, #128]
   87224:	a9094ff2 	stp	x18, x19, [sp, #144]
   87228:	a90a57f4 	stp	x20, x21, [sp, #160]
   8722c:	a90b5ff6 	stp	x22, x23, [sp, #176]
   87230:	a90c67f8 	stp	x24, x25, [sp, #192]
   87234:	a90d6ffa 	stp	x26, x27, [sp, #208]
   87238:	a90e77fc 	stp	x28, x29, [sp, #224]
   8723c:	f9007bfe 	str	x30, [sp, #240]
   87240:	d5384000 	mrs	x0, spsr_el1
   87244:	d5384021 	mrs	x1, elr_el1
   87248:	f90083e0 	str	x0, [sp, #256]
   8724c:	f9008be1 	str	x1, [sp, #272]
   87250:	a94007e0 	ldp	x0, x1, [sp]
   87254:	910003e0 	mov	x0, sp
   87258:	10000001 	adr	x1, 87258 <entry_elh_32_irq+0x5c>
   8725c:	97ffe8c1 	bl	81560 <elh_32_irq>
   87260:	a94007e0 	ldp	x0, x1, [sp]
   87264:	a9410fe2 	ldp	x2, x3, [sp, #16]
   87268:	a94217e4 	ldp	x4, x5, [sp, #32]
   8726c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   87270:	a94427e8 	ldp	x8, x9, [sp, #64]
   87274:	a9452fea 	ldp	x10, x11, [sp, #80]
   87278:	a94637ec 	ldp	x12, x13, [sp, #96]
   8727c:	a9473fee 	ldp	x14, x15, [sp, #112]
   87280:	a94847f0 	ldp	x16, x17, [sp, #128]
   87284:	a9494ff2 	ldp	x18, x19, [sp, #144]
   87288:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8728c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   87290:	a94c67f8 	ldp	x24, x25, [sp, #192]
   87294:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   87298:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8729c:	f9407bfe 	ldr	x30, [sp, #240]
   872a0:	f94083e0 	ldr	x0, [sp, #256]
   872a4:	f9408be1 	ldr	x1, [sp, #272]
   872a8:	d5184000 	msr	spsr_el1, x0
   872ac:	d5184021 	msr	elr_el1, x1
   872b0:	a94007e0 	ldp	x0, x1, [sp]
   872b4:	910483ff 	add	sp, sp, #0x120
   872b8:	d69f03e0 	eret

00000000000872bc <entry_elh_32_fiq>:
   872bc:	d10483ff 	sub	sp, sp, #0x120
   872c0:	a90007e0 	stp	x0, x1, [sp]
   872c4:	a9010fe2 	stp	x2, x3, [sp, #16]
   872c8:	a90217e4 	stp	x4, x5, [sp, #32]
   872cc:	a9031fe6 	stp	x6, x7, [sp, #48]
   872d0:	a90427e8 	stp	x8, x9, [sp, #64]
   872d4:	a9052fea 	stp	x10, x11, [sp, #80]
   872d8:	a90637ec 	stp	x12, x13, [sp, #96]
   872dc:	a9073fee 	stp	x14, x15, [sp, #112]
   872e0:	a90847f0 	stp	x16, x17, [sp, #128]
   872e4:	a9094ff2 	stp	x18, x19, [sp, #144]
   872e8:	a90a57f4 	stp	x20, x21, [sp, #160]
   872ec:	a90b5ff6 	stp	x22, x23, [sp, #176]
   872f0:	a90c67f8 	stp	x24, x25, [sp, #192]
   872f4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   872f8:	a90e77fc 	stp	x28, x29, [sp, #224]
   872fc:	f9007bfe 	str	x30, [sp, #240]
   87300:	d5384000 	mrs	x0, spsr_el1
   87304:	d5384021 	mrs	x1, elr_el1
   87308:	f90083e0 	str	x0, [sp, #256]
   8730c:	f9008be1 	str	x1, [sp, #272]
   87310:	a94007e0 	ldp	x0, x1, [sp]
   87314:	910003e0 	mov	x0, sp
   87318:	10000001 	adr	x1, 87318 <entry_elh_32_fiq+0x5c>
   8731c:	97ffe89f 	bl	81598 <elh_32_fiq>
   87320:	a94007e0 	ldp	x0, x1, [sp]
   87324:	a9410fe2 	ldp	x2, x3, [sp, #16]
   87328:	a94217e4 	ldp	x4, x5, [sp, #32]
   8732c:	a9431fe6 	ldp	x6, x7, [sp, #48]
   87330:	a94427e8 	ldp	x8, x9, [sp, #64]
   87334:	a9452fea 	ldp	x10, x11, [sp, #80]
   87338:	a94637ec 	ldp	x12, x13, [sp, #96]
   8733c:	a9473fee 	ldp	x14, x15, [sp, #112]
   87340:	a94847f0 	ldp	x16, x17, [sp, #128]
   87344:	a9494ff2 	ldp	x18, x19, [sp, #144]
   87348:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8734c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   87350:	a94c67f8 	ldp	x24, x25, [sp, #192]
   87354:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   87358:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8735c:	f9407bfe 	ldr	x30, [sp, #240]
   87360:	f94083e0 	ldr	x0, [sp, #256]
   87364:	f9408be1 	ldr	x1, [sp, #272]
   87368:	d5184000 	msr	spsr_el1, x0
   8736c:	d5184021 	msr	elr_el1, x1
   87370:	a94007e0 	ldp	x0, x1, [sp]
   87374:	910483ff 	add	sp, sp, #0x120
   87378:	d69f03e0 	eret

000000000008737c <entry_elh_32_error>:
   8737c:	d10483ff 	sub	sp, sp, #0x120
   87380:	a90007e0 	stp	x0, x1, [sp]
   87384:	a9010fe2 	stp	x2, x3, [sp, #16]
   87388:	a90217e4 	stp	x4, x5, [sp, #32]
   8738c:	a9031fe6 	stp	x6, x7, [sp, #48]
   87390:	a90427e8 	stp	x8, x9, [sp, #64]
   87394:	a9052fea 	stp	x10, x11, [sp, #80]
   87398:	a90637ec 	stp	x12, x13, [sp, #96]
   8739c:	a9073fee 	stp	x14, x15, [sp, #112]
   873a0:	a90847f0 	stp	x16, x17, [sp, #128]
   873a4:	a9094ff2 	stp	x18, x19, [sp, #144]
   873a8:	a90a57f4 	stp	x20, x21, [sp, #160]
   873ac:	a90b5ff6 	stp	x22, x23, [sp, #176]
   873b0:	a90c67f8 	stp	x24, x25, [sp, #192]
   873b4:	a90d6ffa 	stp	x26, x27, [sp, #208]
   873b8:	a90e77fc 	stp	x28, x29, [sp, #224]
   873bc:	f9007bfe 	str	x30, [sp, #240]
   873c0:	d5384000 	mrs	x0, spsr_el1
   873c4:	d5384021 	mrs	x1, elr_el1
   873c8:	f90083e0 	str	x0, [sp, #256]
   873cc:	f9008be1 	str	x1, [sp, #272]
   873d0:	a94007e0 	ldp	x0, x1, [sp]
   873d4:	910003e0 	mov	x0, sp
   873d8:	10000001 	adr	x1, 873d8 <entry_elh_32_error+0x5c>
   873dc:	97ffe87d 	bl	815d0 <elh_32_error>
   873e0:	a94007e0 	ldp	x0, x1, [sp]
   873e4:	a9410fe2 	ldp	x2, x3, [sp, #16]
   873e8:	a94217e4 	ldp	x4, x5, [sp, #32]
   873ec:	a9431fe6 	ldp	x6, x7, [sp, #48]
   873f0:	a94427e8 	ldp	x8, x9, [sp, #64]
   873f4:	a9452fea 	ldp	x10, x11, [sp, #80]
   873f8:	a94637ec 	ldp	x12, x13, [sp, #96]
   873fc:	a9473fee 	ldp	x14, x15, [sp, #112]
   87400:	a94847f0 	ldp	x16, x17, [sp, #128]
   87404:	a9494ff2 	ldp	x18, x19, [sp, #144]
   87408:	a94a57f4 	ldp	x20, x21, [sp, #160]
   8740c:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   87410:	a94c67f8 	ldp	x24, x25, [sp, #192]
   87414:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   87418:	a94e77fc 	ldp	x28, x29, [sp, #224]
   8741c:	f9407bfe 	ldr	x30, [sp, #240]
   87420:	f94083e0 	ldr	x0, [sp, #256]
   87424:	f9408be1 	ldr	x1, [sp, #272]
   87428:	d5184000 	msr	spsr_el1, x0
   8742c:	d5184021 	msr	elr_el1, x1
   87430:	a94007e0 	ldp	x0, x1, [sp]
   87434:	910483ff 	add	sp, sp, #0x120
   87438:	d69f03e0 	eret
   8743c:	d503201f 	nop
   87440:	d503201f 	nop
   87444:	d503201f 	nop
   87448:	d503201f 	nop
   8744c:	d503201f 	nop
   87450:	d503201f 	nop
   87454:	d503201f 	nop
   87458:	d503201f 	nop
   8745c:	d503201f 	nop
   87460:	d503201f 	nop
   87464:	d503201f 	nop
   87468:	d503201f 	nop
   8746c:	d503201f 	nop
   87470:	d503201f 	nop
   87474:	d503201f 	nop
   87478:	d503201f 	nop
   8747c:	d503201f 	nop
   87480:	d503201f 	nop
   87484:	d503201f 	nop
   87488:	d503201f 	nop
   8748c:	d503201f 	nop
   87490:	d503201f 	nop
   87494:	d503201f 	nop
   87498:	d503201f 	nop
   8749c:	d503201f 	nop
   874a0:	d503201f 	nop
   874a4:	d503201f 	nop
   874a8:	d503201f 	nop
   874ac:	d503201f 	nop
   874b0:	d503201f 	nop
   874b4:	d503201f 	nop
   874b8:	d503201f 	nop
   874bc:	d503201f 	nop
   874c0:	d503201f 	nop
   874c4:	d503201f 	nop
   874c8:	d503201f 	nop
   874cc:	d503201f 	nop
   874d0:	d503201f 	nop
   874d4:	d503201f 	nop
   874d8:	d503201f 	nop
   874dc:	d503201f 	nop
   874e0:	d503201f 	nop
   874e4:	d503201f 	nop
   874e8:	d503201f 	nop
   874ec:	d503201f 	nop
   874f0:	d503201f 	nop
   874f4:	d503201f 	nop
   874f8:	d503201f 	nop
   874fc:	d503201f 	nop
   87500:	d503201f 	nop
   87504:	d503201f 	nop
   87508:	d503201f 	nop
   8750c:	d503201f 	nop
   87510:	d503201f 	nop
   87514:	d503201f 	nop
   87518:	d503201f 	nop
   8751c:	d503201f 	nop
   87520:	d503201f 	nop
   87524:	d503201f 	nop
   87528:	d503201f 	nop
   8752c:	d503201f 	nop
   87530:	d503201f 	nop
   87534:	d503201f 	nop
   87538:	d503201f 	nop
   8753c:	d503201f 	nop
   87540:	d503201f 	nop
   87544:	d503201f 	nop
   87548:	d503201f 	nop
   8754c:	d503201f 	nop
   87550:	d503201f 	nop
   87554:	d503201f 	nop
   87558:	d503201f 	nop
   8755c:	d503201f 	nop
   87560:	d503201f 	nop
   87564:	d503201f 	nop
   87568:	d503201f 	nop
   8756c:	d503201f 	nop
   87570:	d503201f 	nop
   87574:	d503201f 	nop
   87578:	d503201f 	nop
   8757c:	d503201f 	nop
   87580:	d503201f 	nop
   87584:	d503201f 	nop
   87588:	d503201f 	nop
   8758c:	d503201f 	nop
   87590:	d503201f 	nop
   87594:	d503201f 	nop
   87598:	d503201f 	nop
   8759c:	d503201f 	nop
   875a0:	d503201f 	nop
   875a4:	d503201f 	nop
   875a8:	d503201f 	nop
   875ac:	d503201f 	nop
   875b0:	d503201f 	nop
   875b4:	d503201f 	nop
   875b8:	d503201f 	nop
   875bc:	d503201f 	nop
   875c0:	d503201f 	nop
   875c4:	d503201f 	nop
   875c8:	d503201f 	nop
   875cc:	d503201f 	nop
   875d0:	d503201f 	nop
   875d4:	d503201f 	nop
   875d8:	d503201f 	nop
   875dc:	d503201f 	nop
   875e0:	d503201f 	nop
   875e4:	d503201f 	nop
   875e8:	d503201f 	nop
   875ec:	d503201f 	nop
   875f0:	d503201f 	nop
   875f4:	d503201f 	nop
   875f8:	d503201f 	nop
   875fc:	d503201f 	nop
   87600:	d503201f 	nop
   87604:	d503201f 	nop
   87608:	d503201f 	nop
   8760c:	d503201f 	nop
   87610:	d503201f 	nop
   87614:	d503201f 	nop
   87618:	d503201f 	nop
   8761c:	d503201f 	nop
   87620:	d503201f 	nop
   87624:	d503201f 	nop
   87628:	d503201f 	nop
   8762c:	d503201f 	nop
   87630:	d503201f 	nop
   87634:	d503201f 	nop
   87638:	d503201f 	nop
   8763c:	d503201f 	nop
   87640:	d503201f 	nop
   87644:	d503201f 	nop
   87648:	d503201f 	nop
   8764c:	d503201f 	nop
   87650:	d503201f 	nop
   87654:	d503201f 	nop
   87658:	d503201f 	nop
   8765c:	d503201f 	nop
   87660:	d503201f 	nop
   87664:	d503201f 	nop
   87668:	d503201f 	nop
   8766c:	d503201f 	nop
   87670:	d503201f 	nop
   87674:	d503201f 	nop
   87678:	d503201f 	nop
   8767c:	d503201f 	nop
   87680:	d503201f 	nop
   87684:	d503201f 	nop
   87688:	d503201f 	nop
   8768c:	d503201f 	nop
   87690:	d503201f 	nop
   87694:	d503201f 	nop
   87698:	d503201f 	nop
   8769c:	d503201f 	nop
   876a0:	d503201f 	nop
   876a4:	d503201f 	nop
   876a8:	d503201f 	nop
   876ac:	d503201f 	nop
   876b0:	d503201f 	nop
   876b4:	d503201f 	nop
   876b8:	d503201f 	nop
   876bc:	d503201f 	nop
   876c0:	d503201f 	nop
   876c4:	d503201f 	nop
   876c8:	d503201f 	nop
   876cc:	d503201f 	nop
   876d0:	d503201f 	nop
   876d4:	d503201f 	nop
   876d8:	d503201f 	nop
   876dc:	d503201f 	nop
   876e0:	d503201f 	nop
   876e4:	d503201f 	nop
   876e8:	d503201f 	nop
   876ec:	d503201f 	nop
   876f0:	d503201f 	nop
   876f4:	d503201f 	nop
   876f8:	d503201f 	nop
   876fc:	d503201f 	nop
   87700:	d503201f 	nop
   87704:	d503201f 	nop
   87708:	d503201f 	nop
   8770c:	d503201f 	nop
   87710:	d503201f 	nop
   87714:	d503201f 	nop
   87718:	d503201f 	nop
   8771c:	d503201f 	nop
   87720:	d503201f 	nop
   87724:	d503201f 	nop
   87728:	d503201f 	nop
   8772c:	d503201f 	nop
   87730:	d503201f 	nop
   87734:	d503201f 	nop
   87738:	d503201f 	nop
   8773c:	d503201f 	nop
   87740:	d503201f 	nop
   87744:	d503201f 	nop
   87748:	d503201f 	nop
   8774c:	d503201f 	nop
   87750:	d503201f 	nop
   87754:	d503201f 	nop
   87758:	d503201f 	nop
   8775c:	d503201f 	nop
   87760:	d503201f 	nop
   87764:	d503201f 	nop
   87768:	d503201f 	nop
   8776c:	d503201f 	nop
   87770:	d503201f 	nop
   87774:	d503201f 	nop
   87778:	d503201f 	nop
   8777c:	d503201f 	nop
   87780:	d503201f 	nop
   87784:	d503201f 	nop
   87788:	d503201f 	nop
   8778c:	d503201f 	nop
   87790:	d503201f 	nop
   87794:	d503201f 	nop
   87798:	d503201f 	nop
   8779c:	d503201f 	nop
   877a0:	d503201f 	nop
   877a4:	d503201f 	nop
   877a8:	d503201f 	nop
   877ac:	d503201f 	nop
   877b0:	d503201f 	nop
   877b4:	d503201f 	nop
   877b8:	d503201f 	nop
   877bc:	d503201f 	nop
   877c0:	d503201f 	nop
   877c4:	d503201f 	nop
   877c8:	d503201f 	nop
   877cc:	d503201f 	nop
   877d0:	d503201f 	nop
   877d4:	d503201f 	nop
   877d8:	d503201f 	nop
   877dc:	d503201f 	nop
   877e0:	d503201f 	nop
   877e4:	d503201f 	nop
   877e8:	d503201f 	nop
   877ec:	d503201f 	nop
   877f0:	d503201f 	nop
   877f4:	d503201f 	nop
   877f8:	d503201f 	nop
   877fc:	d503201f 	nop

0000000000087800 <exception_vector_table>:
   87800:	17fffc0f 	b	8683c <entry_el_spel0_sync>
   87804:	d503201f 	nop
   87808:	d503201f 	nop
   8780c:	d503201f 	nop
   87810:	d503201f 	nop
   87814:	d503201f 	nop
   87818:	d503201f 	nop
   8781c:	d503201f 	nop
   87820:	d503201f 	nop
   87824:	d503201f 	nop
   87828:	d503201f 	nop
   8782c:	d503201f 	nop
   87830:	d503201f 	nop
   87834:	d503201f 	nop
   87838:	d503201f 	nop
   8783c:	d503201f 	nop
   87840:	d503201f 	nop
   87844:	d503201f 	nop
   87848:	d503201f 	nop
   8784c:	d503201f 	nop
   87850:	d503201f 	nop
   87854:	d503201f 	nop
   87858:	d503201f 	nop
   8785c:	d503201f 	nop
   87860:	d503201f 	nop
   87864:	d503201f 	nop
   87868:	d503201f 	nop
   8786c:	d503201f 	nop
   87870:	d503201f 	nop
   87874:	d503201f 	nop
   87878:	d503201f 	nop
   8787c:	d503201f 	nop
   87880:	17fffc1f 	b	868fc <entry_el_spel0_irq>
   87884:	d503201f 	nop
   87888:	d503201f 	nop
   8788c:	d503201f 	nop
   87890:	d503201f 	nop
   87894:	d503201f 	nop
   87898:	d503201f 	nop
   8789c:	d503201f 	nop
   878a0:	d503201f 	nop
   878a4:	d503201f 	nop
   878a8:	d503201f 	nop
   878ac:	d503201f 	nop
   878b0:	d503201f 	nop
   878b4:	d503201f 	nop
   878b8:	d503201f 	nop
   878bc:	d503201f 	nop
   878c0:	d503201f 	nop
   878c4:	d503201f 	nop
   878c8:	d503201f 	nop
   878cc:	d503201f 	nop
   878d0:	d503201f 	nop
   878d4:	d503201f 	nop
   878d8:	d503201f 	nop
   878dc:	d503201f 	nop
   878e0:	d503201f 	nop
   878e4:	d503201f 	nop
   878e8:	d503201f 	nop
   878ec:	d503201f 	nop
   878f0:	d503201f 	nop
   878f4:	d503201f 	nop
   878f8:	d503201f 	nop
   878fc:	d503201f 	nop
   87900:	17fffc2f 	b	869bc <entry_el_spel0_fiq>
   87904:	d503201f 	nop
   87908:	d503201f 	nop
   8790c:	d503201f 	nop
   87910:	d503201f 	nop
   87914:	d503201f 	nop
   87918:	d503201f 	nop
   8791c:	d503201f 	nop
   87920:	d503201f 	nop
   87924:	d503201f 	nop
   87928:	d503201f 	nop
   8792c:	d503201f 	nop
   87930:	d503201f 	nop
   87934:	d503201f 	nop
   87938:	d503201f 	nop
   8793c:	d503201f 	nop
   87940:	d503201f 	nop
   87944:	d503201f 	nop
   87948:	d503201f 	nop
   8794c:	d503201f 	nop
   87950:	d503201f 	nop
   87954:	d503201f 	nop
   87958:	d503201f 	nop
   8795c:	d503201f 	nop
   87960:	d503201f 	nop
   87964:	d503201f 	nop
   87968:	d503201f 	nop
   8796c:	d503201f 	nop
   87970:	d503201f 	nop
   87974:	d503201f 	nop
   87978:	d503201f 	nop
   8797c:	d503201f 	nop
   87980:	17fffc3f 	b	86a7c <entry_el_spel0_error>
   87984:	d503201f 	nop
   87988:	d503201f 	nop
   8798c:	d503201f 	nop
   87990:	d503201f 	nop
   87994:	d503201f 	nop
   87998:	d503201f 	nop
   8799c:	d503201f 	nop
   879a0:	d503201f 	nop
   879a4:	d503201f 	nop
   879a8:	d503201f 	nop
   879ac:	d503201f 	nop
   879b0:	d503201f 	nop
   879b4:	d503201f 	nop
   879b8:	d503201f 	nop
   879bc:	d503201f 	nop
   879c0:	d503201f 	nop
   879c4:	d503201f 	nop
   879c8:	d503201f 	nop
   879cc:	d503201f 	nop
   879d0:	d503201f 	nop
   879d4:	d503201f 	nop
   879d8:	d503201f 	nop
   879dc:	d503201f 	nop
   879e0:	d503201f 	nop
   879e4:	d503201f 	nop
   879e8:	d503201f 	nop
   879ec:	d503201f 	nop
   879f0:	d503201f 	nop
   879f4:	d503201f 	nop
   879f8:	d503201f 	nop
   879fc:	d503201f 	nop
   87a00:	17fffc4f 	b	86b3c <entry_el_spelx_sync>
   87a04:	d503201f 	nop
   87a08:	d503201f 	nop
   87a0c:	d503201f 	nop
   87a10:	d503201f 	nop
   87a14:	d503201f 	nop
   87a18:	d503201f 	nop
   87a1c:	d503201f 	nop
   87a20:	d503201f 	nop
   87a24:	d503201f 	nop
   87a28:	d503201f 	nop
   87a2c:	d503201f 	nop
   87a30:	d503201f 	nop
   87a34:	d503201f 	nop
   87a38:	d503201f 	nop
   87a3c:	d503201f 	nop
   87a40:	d503201f 	nop
   87a44:	d503201f 	nop
   87a48:	d503201f 	nop
   87a4c:	d503201f 	nop
   87a50:	d503201f 	nop
   87a54:	d503201f 	nop
   87a58:	d503201f 	nop
   87a5c:	d503201f 	nop
   87a60:	d503201f 	nop
   87a64:	d503201f 	nop
   87a68:	d503201f 	nop
   87a6c:	d503201f 	nop
   87a70:	d503201f 	nop
   87a74:	d503201f 	nop
   87a78:	d503201f 	nop
   87a7c:	d503201f 	nop
   87a80:	17fffc5f 	b	86bfc <entry_el_spelx_irq>
   87a84:	d503201f 	nop
   87a88:	d503201f 	nop
   87a8c:	d503201f 	nop
   87a90:	d503201f 	nop
   87a94:	d503201f 	nop
   87a98:	d503201f 	nop
   87a9c:	d503201f 	nop
   87aa0:	d503201f 	nop
   87aa4:	d503201f 	nop
   87aa8:	d503201f 	nop
   87aac:	d503201f 	nop
   87ab0:	d503201f 	nop
   87ab4:	d503201f 	nop
   87ab8:	d503201f 	nop
   87abc:	d503201f 	nop
   87ac0:	d503201f 	nop
   87ac4:	d503201f 	nop
   87ac8:	d503201f 	nop
   87acc:	d503201f 	nop
   87ad0:	d503201f 	nop
   87ad4:	d503201f 	nop
   87ad8:	d503201f 	nop
   87adc:	d503201f 	nop
   87ae0:	d503201f 	nop
   87ae4:	d503201f 	nop
   87ae8:	d503201f 	nop
   87aec:	d503201f 	nop
   87af0:	d503201f 	nop
   87af4:	d503201f 	nop
   87af8:	d503201f 	nop
   87afc:	d503201f 	nop
   87b00:	17fffc6f 	b	86cbc <entry_el_spelx_fiq>
   87b04:	d503201f 	nop
   87b08:	d503201f 	nop
   87b0c:	d503201f 	nop
   87b10:	d503201f 	nop
   87b14:	d503201f 	nop
   87b18:	d503201f 	nop
   87b1c:	d503201f 	nop
   87b20:	d503201f 	nop
   87b24:	d503201f 	nop
   87b28:	d503201f 	nop
   87b2c:	d503201f 	nop
   87b30:	d503201f 	nop
   87b34:	d503201f 	nop
   87b38:	d503201f 	nop
   87b3c:	d503201f 	nop
   87b40:	d503201f 	nop
   87b44:	d503201f 	nop
   87b48:	d503201f 	nop
   87b4c:	d503201f 	nop
   87b50:	d503201f 	nop
   87b54:	d503201f 	nop
   87b58:	d503201f 	nop
   87b5c:	d503201f 	nop
   87b60:	d503201f 	nop
   87b64:	d503201f 	nop
   87b68:	d503201f 	nop
   87b6c:	d503201f 	nop
   87b70:	d503201f 	nop
   87b74:	d503201f 	nop
   87b78:	d503201f 	nop
   87b7c:	d503201f 	nop
   87b80:	17fffc7f 	b	86d7c <entry_el_spelx_error>
   87b84:	d503201f 	nop
   87b88:	d503201f 	nop
   87b8c:	d503201f 	nop
   87b90:	d503201f 	nop
   87b94:	d503201f 	nop
   87b98:	d503201f 	nop
   87b9c:	d503201f 	nop
   87ba0:	d503201f 	nop
   87ba4:	d503201f 	nop
   87ba8:	d503201f 	nop
   87bac:	d503201f 	nop
   87bb0:	d503201f 	nop
   87bb4:	d503201f 	nop
   87bb8:	d503201f 	nop
   87bbc:	d503201f 	nop
   87bc0:	d503201f 	nop
   87bc4:	d503201f 	nop
   87bc8:	d503201f 	nop
   87bcc:	d503201f 	nop
   87bd0:	d503201f 	nop
   87bd4:	d503201f 	nop
   87bd8:	d503201f 	nop
   87bdc:	d503201f 	nop
   87be0:	d503201f 	nop
   87be4:	d503201f 	nop
   87be8:	d503201f 	nop
   87bec:	d503201f 	nop
   87bf0:	d503201f 	nop
   87bf4:	d503201f 	nop
   87bf8:	d503201f 	nop
   87bfc:	d503201f 	nop
   87c00:	17fffc8f 	b	86e3c <entry_elh_64_sync>
   87c04:	d503201f 	nop
   87c08:	d503201f 	nop
   87c0c:	d503201f 	nop
   87c10:	d503201f 	nop
   87c14:	d503201f 	nop
   87c18:	d503201f 	nop
   87c1c:	d503201f 	nop
   87c20:	d503201f 	nop
   87c24:	d503201f 	nop
   87c28:	d503201f 	nop
   87c2c:	d503201f 	nop
   87c30:	d503201f 	nop
   87c34:	d503201f 	nop
   87c38:	d503201f 	nop
   87c3c:	d503201f 	nop
   87c40:	d503201f 	nop
   87c44:	d503201f 	nop
   87c48:	d503201f 	nop
   87c4c:	d503201f 	nop
   87c50:	d503201f 	nop
   87c54:	d503201f 	nop
   87c58:	d503201f 	nop
   87c5c:	d503201f 	nop
   87c60:	d503201f 	nop
   87c64:	d503201f 	nop
   87c68:	d503201f 	nop
   87c6c:	d503201f 	nop
   87c70:	d503201f 	nop
   87c74:	d503201f 	nop
   87c78:	d503201f 	nop
   87c7c:	d503201f 	nop
   87c80:	17fffc9f 	b	86efc <entry_elh_64_irq>
   87c84:	d503201f 	nop
   87c88:	d503201f 	nop
   87c8c:	d503201f 	nop
   87c90:	d503201f 	nop
   87c94:	d503201f 	nop
   87c98:	d503201f 	nop
   87c9c:	d503201f 	nop
   87ca0:	d503201f 	nop
   87ca4:	d503201f 	nop
   87ca8:	d503201f 	nop
   87cac:	d503201f 	nop
   87cb0:	d503201f 	nop
   87cb4:	d503201f 	nop
   87cb8:	d503201f 	nop
   87cbc:	d503201f 	nop
   87cc0:	d503201f 	nop
   87cc4:	d503201f 	nop
   87cc8:	d503201f 	nop
   87ccc:	d503201f 	nop
   87cd0:	d503201f 	nop
   87cd4:	d503201f 	nop
   87cd8:	d503201f 	nop
   87cdc:	d503201f 	nop
   87ce0:	d503201f 	nop
   87ce4:	d503201f 	nop
   87ce8:	d503201f 	nop
   87cec:	d503201f 	nop
   87cf0:	d503201f 	nop
   87cf4:	d503201f 	nop
   87cf8:	d503201f 	nop
   87cfc:	d503201f 	nop
   87d00:	17fffcaf 	b	86fbc <entry_elh_64_fiq>
   87d04:	d503201f 	nop
   87d08:	d503201f 	nop
   87d0c:	d503201f 	nop
   87d10:	d503201f 	nop
   87d14:	d503201f 	nop
   87d18:	d503201f 	nop
   87d1c:	d503201f 	nop
   87d20:	d503201f 	nop
   87d24:	d503201f 	nop
   87d28:	d503201f 	nop
   87d2c:	d503201f 	nop
   87d30:	d503201f 	nop
   87d34:	d503201f 	nop
   87d38:	d503201f 	nop
   87d3c:	d503201f 	nop
   87d40:	d503201f 	nop
   87d44:	d503201f 	nop
   87d48:	d503201f 	nop
   87d4c:	d503201f 	nop
   87d50:	d503201f 	nop
   87d54:	d503201f 	nop
   87d58:	d503201f 	nop
   87d5c:	d503201f 	nop
   87d60:	d503201f 	nop
   87d64:	d503201f 	nop
   87d68:	d503201f 	nop
   87d6c:	d503201f 	nop
   87d70:	d503201f 	nop
   87d74:	d503201f 	nop
   87d78:	d503201f 	nop
   87d7c:	d503201f 	nop
   87d80:	17fffcbf 	b	8707c <entry_elh_64_error>
   87d84:	d503201f 	nop
   87d88:	d503201f 	nop
   87d8c:	d503201f 	nop
   87d90:	d503201f 	nop
   87d94:	d503201f 	nop
   87d98:	d503201f 	nop
   87d9c:	d503201f 	nop
   87da0:	d503201f 	nop
   87da4:	d503201f 	nop
   87da8:	d503201f 	nop
   87dac:	d503201f 	nop
   87db0:	d503201f 	nop
   87db4:	d503201f 	nop
   87db8:	d503201f 	nop
   87dbc:	d503201f 	nop
   87dc0:	d503201f 	nop
   87dc4:	d503201f 	nop
   87dc8:	d503201f 	nop
   87dcc:	d503201f 	nop
   87dd0:	d503201f 	nop
   87dd4:	d503201f 	nop
   87dd8:	d503201f 	nop
   87ddc:	d503201f 	nop
   87de0:	d503201f 	nop
   87de4:	d503201f 	nop
   87de8:	d503201f 	nop
   87dec:	d503201f 	nop
   87df0:	d503201f 	nop
   87df4:	d503201f 	nop
   87df8:	d503201f 	nop
   87dfc:	d503201f 	nop
   87e00:	17fffccf 	b	8713c <entry_elh_32_sync>
   87e04:	d503201f 	nop
   87e08:	d503201f 	nop
   87e0c:	d503201f 	nop
   87e10:	d503201f 	nop
   87e14:	d503201f 	nop
   87e18:	d503201f 	nop
   87e1c:	d503201f 	nop
   87e20:	d503201f 	nop
   87e24:	d503201f 	nop
   87e28:	d503201f 	nop
   87e2c:	d503201f 	nop
   87e30:	d503201f 	nop
   87e34:	d503201f 	nop
   87e38:	d503201f 	nop
   87e3c:	d503201f 	nop
   87e40:	d503201f 	nop
   87e44:	d503201f 	nop
   87e48:	d503201f 	nop
   87e4c:	d503201f 	nop
   87e50:	d503201f 	nop
   87e54:	d503201f 	nop
   87e58:	d503201f 	nop
   87e5c:	d503201f 	nop
   87e60:	d503201f 	nop
   87e64:	d503201f 	nop
   87e68:	d503201f 	nop
   87e6c:	d503201f 	nop
   87e70:	d503201f 	nop
   87e74:	d503201f 	nop
   87e78:	d503201f 	nop
   87e7c:	d503201f 	nop
   87e80:	17fffcdf 	b	871fc <entry_elh_32_irq>
   87e84:	d503201f 	nop
   87e88:	d503201f 	nop
   87e8c:	d503201f 	nop
   87e90:	d503201f 	nop
   87e94:	d503201f 	nop
   87e98:	d503201f 	nop
   87e9c:	d503201f 	nop
   87ea0:	d503201f 	nop
   87ea4:	d503201f 	nop
   87ea8:	d503201f 	nop
   87eac:	d503201f 	nop
   87eb0:	d503201f 	nop
   87eb4:	d503201f 	nop
   87eb8:	d503201f 	nop
   87ebc:	d503201f 	nop
   87ec0:	d503201f 	nop
   87ec4:	d503201f 	nop
   87ec8:	d503201f 	nop
   87ecc:	d503201f 	nop
   87ed0:	d503201f 	nop
   87ed4:	d503201f 	nop
   87ed8:	d503201f 	nop
   87edc:	d503201f 	nop
   87ee0:	d503201f 	nop
   87ee4:	d503201f 	nop
   87ee8:	d503201f 	nop
   87eec:	d503201f 	nop
   87ef0:	d503201f 	nop
   87ef4:	d503201f 	nop
   87ef8:	d503201f 	nop
   87efc:	d503201f 	nop
   87f00:	17fffcef 	b	872bc <entry_elh_32_fiq>
   87f04:	d503201f 	nop
   87f08:	d503201f 	nop
   87f0c:	d503201f 	nop
   87f10:	d503201f 	nop
   87f14:	d503201f 	nop
   87f18:	d503201f 	nop
   87f1c:	d503201f 	nop
   87f20:	d503201f 	nop
   87f24:	d503201f 	nop
   87f28:	d503201f 	nop
   87f2c:	d503201f 	nop
   87f30:	d503201f 	nop
   87f34:	d503201f 	nop
   87f38:	d503201f 	nop
   87f3c:	d503201f 	nop
   87f40:	d503201f 	nop
   87f44:	d503201f 	nop
   87f48:	d503201f 	nop
   87f4c:	d503201f 	nop
   87f50:	d503201f 	nop
   87f54:	d503201f 	nop
   87f58:	d503201f 	nop
   87f5c:	d503201f 	nop
   87f60:	d503201f 	nop
   87f64:	d503201f 	nop
   87f68:	d503201f 	nop
   87f6c:	d503201f 	nop
   87f70:	d503201f 	nop
   87f74:	d503201f 	nop
   87f78:	d503201f 	nop
   87f7c:	d503201f 	nop
   87f80:	17fffcff 	b	8737c <entry_elh_32_error>

0000000000087f84 <set_exception_vector_table>:
   87f84:	10ffc3e0 	adr	x0, 87800 <exception_vector_table>
   87f88:	d518c000 	msr	vbar_el1, x0
   87f8c:	d65f03c0 	ret

0000000000087f90 <switch_to>:
   87f90:	a9005013 	stp	x19, x20, [x0]
   87f94:	a9015815 	stp	x21, x22, [x0, #16]
   87f98:	a9026017 	stp	x23, x24, [x0, #32]
   87f9c:	a9036819 	stp	x25, x26, [x0, #48]
   87fa0:	a904701b 	stp	x27, x28, [x0, #64]
   87fa4:	a905781d 	stp	x29, x30, [x0, #80]
   87fa8:	910003e9 	mov	x9, sp
   87fac:	d538410a 	mrs	x10, sp_el0
   87fb0:	a9062809 	stp	x9, x10, [x0, #96]
   87fb4:	a9405033 	ldp	x19, x20, [x1]
   87fb8:	a9415835 	ldp	x21, x22, [x1, #16]
   87fbc:	a9426037 	ldp	x23, x24, [x1, #32]
   87fc0:	a9436839 	ldp	x25, x26, [x1, #48]
   87fc4:	a944703b 	ldp	x27, x28, [x1, #64]
   87fc8:	a945783d 	ldp	x29, x30, [x1, #80]
   87fcc:	a9462829 	ldp	x9, x10, [x1, #96]
   87fd0:	9100013f 	mov	sp, x9
   87fd4:	d518410a 	msr	sp_el0, x10
   87fd8:	d518d082 	msr	tpidr_el1, x2
   87fdc:	d65f03c0 	ret

0000000000087fe0 <get_cur_tid>:
   87fe0:	d538d080 	mrs	x0, tpidr_el1
   87fe4:	d65f03c0 	ret

0000000000087fe8 <load_all_sp>:
   87fe8:	a94007e0 	ldp	x0, x1, [sp]
   87fec:	a9410fe2 	ldp	x2, x3, [sp, #16]
   87ff0:	a94217e4 	ldp	x4, x5, [sp, #32]
   87ff4:	a9431fe6 	ldp	x6, x7, [sp, #48]
   87ff8:	a94427e8 	ldp	x8, x9, [sp, #64]
   87ffc:	a9452fea 	ldp	x10, x11, [sp, #80]
   88000:	a94637ec 	ldp	x12, x13, [sp, #96]
   88004:	a9473fee 	ldp	x14, x15, [sp, #112]
   88008:	a94847f0 	ldp	x16, x17, [sp, #128]
   8800c:	a9494ff2 	ldp	x18, x19, [sp, #144]
   88010:	a94a57f4 	ldp	x20, x21, [sp, #160]
   88014:	a94b5ff6 	ldp	x22, x23, [sp, #176]
   88018:	a94c67f8 	ldp	x24, x25, [sp, #192]
   8801c:	a94d6ffa 	ldp	x26, x27, [sp, #208]
   88020:	a94e77fc 	ldp	x28, x29, [sp, #224]
   88024:	f9407bfe 	ldr	x30, [sp, #240]
   88028:	f94083e0 	ldr	x0, [sp, #256]
   8802c:	f9408be1 	ldr	x1, [sp, #272]
   88030:	d5184000 	msr	spsr_el1, x0
   88034:	d5184021 	msr	elr_el1, x1
   88038:	a94007e0 	ldp	x0, x1, [sp]
   8803c:	910483ff 	add	sp, sp, #0x120
   88040:	d69f03e0 	eret
	...
   88050:	00300000 	.word	0x00300000
   88054:	00000000 	.word	0x00000000
   88058:	80000000 	.word	0x80000000
   8805c:	00000000 	.word	0x00000000
   88060:	000003c5 	.word	0x000003c5
   88064:	00000000 	.word	0x00000000

0000000000088068 <memzero>:
   88068:	f800841f 	str	xzr, [x0], #8
   8806c:	f1002021 	subs	x1, x1, #0x8
   88070:	54ffffcc 	b.gt	88068 <memzero>
   88074:	d65f03c0 	ret
